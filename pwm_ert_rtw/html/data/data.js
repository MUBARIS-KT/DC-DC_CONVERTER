var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"pwm","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"pwm.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nboolean_T isRateRunning[2] = { 0, 0 };\r\n\r\nboolean_T need2runFlags[2] = { 0, 0 };\r\n\r\nvoid rt_OneStep(void)\r\n{\r\n  boolean_T eventFlags[2];\r\n\r\n  /* Check base rate for overrun */\r\n  if (isRateRunning[0]++) {\r\n    IsrOverrun = 1;\r\n    isRateRunning[0]--;                /* allow future iterations to succeed*/\r\n    return;\r\n  }\r\n\r\n  /*\r\n   * For a bare-board target (i.e., no operating system), the rates\r\n   * that execute this base step are buffered locally to allow for\r\n   * overlapping preemption.\r\n   */\r\n  pwm_SetEventsForThisBaseStep(eventFlags);\r\n  enableTimer0Interrupt();\r\n  pwm_step0();\r\n\r\n  /* Get model outputs here */\r\n  disableTimer0Interrupt();\r\n  isRateRunning[0]--;\r\n  if (eventFlags[1]) {\r\n    if (need2runFlags[1]++) {\r\n      IsrOverrun = 1;\r\n      need2runFlags[1]--;              /* allow future iterations to succeed*/\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (need2runFlags[1]) {\r\n    if (isRateRunning[1]) {\r\n      /* Yield to higher priority*/\r\n      return;\r\n    }\r\n\r\n    isRateRunning[1]++;\r\n    enableTimer0Interrupt();\r\n\r\n    /* Step the model for subrate \"1\" */\r\n    switch (1)\r\n    {\r\n     case 1 :\r\n      pwm_step1();\r\n\r\n      /* Get model outputs here */\r\n      break;\r\n\r\n     default :\r\n      break;\r\n    }\r\n\r\n    disableTimer0Interrupt();\r\n    need2runFlags[1]--;\r\n    isRateRunning[1]--;\r\n  }\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 1.0E-5;\r\n  float systemClock = 200;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  c2000_flash_init();\r\n  init_board();\r\n\r\n#if defined(MW_EXEC_PROFILER_ON) || (defined(MW_EXTMODE_RUNNING) && !defined(XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME))\r\n\r\n  hardwareTimer1Init();\r\n\r\n#endif\r\n\r\n  ;\r\n  rtmSetErrorStatus(pwm_M, 0);\r\n  pwm_initialize();\r\n  globalInterruptDisable();\r\n  configureTimer0(modelBaseRate, systemClock);\r\n  runModel =\r\n    rtmGetErrorStatus(pwm_M) == (NULL);\r\n  enableTimer0Interrupt();\r\n  config_ePWM_TBSync();\r\n  globalInterruptEnable();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(pwm_M) == (NULL));\r\n  }\r\n\r\n  /* Terminate model */\r\n  pwm_terminate();\r\n  globalInterruptDisable();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"pwm.c","type":"source","group":"model","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: pwm.c\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"pwm.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"pwm_private.h\"\r\n#include <string.h>\r\n\r\n/* Block signals (default storage) */\r\nB_pwm_T pwm_B;\r\n\r\n/* Block states (default storage) */\r\nDW_pwm_T pwm_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_pwm_T pwm_M_;\r\nRT_MODEL_pwm_T *const pwm_M = &pwm_M_;\r\nstatic void rate_monotonic_scheduler(void);\r\n\r\n#ifndef __TMS320C28XX_CLA__\r\n\r\nuint16_T MW_adcBInitFlag = 0;\r\n\r\n#endif\r\n\r\n/*\r\n * Set which subrates need to run this base step (base rate always runs).\r\n * This function must be called prior to calling the model step function\r\n * in order to remember which rates need to run this base step.  The\r\n * buffering of events allows for overlapping preemption.\r\n */\r\nvoid pwm_SetEventsForThisBaseStep(boolean_T *eventFlags)\r\n{\r\n  /* Task runs when its counter is zero, computed via rtmStepTask macro */\r\n  eventFlags[1] = ((boolean_T)rtmStepTask(pwm_M, 1));\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate\r\n *         and rate transition flags for tasks that exchange data.\r\n *         The function assumes rate-monotonic multitasking scheduler.\r\n *         The function must be called at model base rate so that\r\n *         the generated code self-manages all its subrates and rate\r\n *         transition flags.\r\n */\r\nstatic void rate_monotonic_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (pwm_M->Timing.TaskCounters.TID[1])++;\r\n  if ((pwm_M->Timing.TaskCounters.TID[1]) > 9999) {\r\n                                /* Sample time: [0.099999999999999992s, 0.0s] */\r\n    pwm_M->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n}\r\n\r\n/* Model step function for TID0 */\r\nvoid pwm_step0(void)                   /* Sample time: [1.0E-5s, 0.0s] */\r\n{\r\n  real_T rtb_Add;\r\n  real_T rtb_Gain1;\r\n\r\n  {                                    /* Sample time: [1.0E-5s, 0.0s] */\r\n    rate_monotonic_scheduler();\r\n  }\r\n\r\n  /* S-Function (c2802xadc): '<Root>/ADC1' */\r\n  {\r\n    /*  Internal Reference Voltage : Fixed scale 0 to 3.3 V range.  */\r\n    /*  External Reference Voltage : Allowable ranges of VREFHI(ADCINA0) = 3.3 and VREFLO(tied to ground) = 0  */\r\n    AdcbRegs.ADCSOCFRC1.bit.SOC3 = 1U;\r\n\r\n    /* Wait for the period of Sampling window and EOC result to be latched after trigger */\r\n#ifndef __TMS320C28XX_CLA__\r\n\r\n    asm(\" RPT #75|| NOP\");\r\n\r\n#endif\r\n\r\n#ifdef __TMS320C28XX_CLA__\r\n\r\n    real32_T wait_index;\r\n    for (wait_index= 12; wait_index > 0; wait_index--)\r\n      __mnop();\r\n\r\n#endif\r\n\r\n    pwm_B.ADC1 = (AdcbResultRegs.ADCRESULT3);\r\n  }\r\n\r\n  /* Gain: '<Root>/Gain1' */\r\n  rtb_Gain1 = pwm_P.Gain1_Gain * pwm_B.ADC1;\r\n\r\n  /* Sum: '<Root>/Add' incorporates:\r\n   *  Constant: '<Root>/Constant5'\r\n   */\r\n  rtb_Add = pwm_P.Constant5_Value - rtb_Gain1;\r\n\r\n  /* S-Function (c2802xpwm): '<Root>/ePWM' */\r\n\r\n  /*-- Update CMPA value for ePWM1 --*/\r\n  {\r\n    EPwm1Regs.CMPA.bit.CMPA = (uint16_T)((uint32_T)EPwm1Regs.TBPRD * rtb_Gain1 *\r\n      0.01);\r\n  }\r\n\r\n  /*-- Update CMPB value for ePWM1 --*/\r\n  {\r\n    EPwm1Regs.CMPB.bit.CMPB = (uint16_T)((uint32_T)EPwm1Regs.TBPRD * rtb_Add *\r\n      0.01);\r\n  }\r\n\r\n  /* S-Function (c2802xpwm): '<Root>/ePWM1' */\r\n\r\n  /*-- Update CMPA value for ePWM2 --*/\r\n  {\r\n    EPwm2Regs.CMPA.bit.CMPA = (uint16_T)((uint32_T)EPwm2Regs.TBPRD * rtb_Gain1 *\r\n      0.01);\r\n  }\r\n\r\n  /*-- Update CMPB value for ePWM2 --*/\r\n  {\r\n    EPwm2Regs.CMPB.bit.CMPB = (uint16_T)((uint32_T)EPwm2Regs.TBPRD * rtb_Add *\r\n      0.01);\r\n  }\r\n}\r\n\r\n/* Model step function for TID1 */\r\nvoid pwm_step1(void)            /* Sample time: [0.099999999999999992s, 0.0s] */\r\n{\r\n  /* DiscretePulseGenerator: '<Root>/Pulse Generator' */\r\n  pwm_B.PulseGenerator = (pwm_DW.clockTickCounter < pwm_P.PulseGenerator_Duty) &&\r\n    (pwm_DW.clockTickCounter >= 0L) ? pwm_P.PulseGenerator_Amp : 0.0;\r\n\r\n  /* DiscretePulseGenerator: '<Root>/Pulse Generator' */\r\n  if (pwm_DW.clockTickCounter >= pwm_P.PulseGenerator_Period - 1.0) {\r\n    pwm_DW.clockTickCounter = 0L;\r\n  } else {\r\n    pwm_DW.clockTickCounter++;\r\n  }\r\n\r\n  /* S-Function (c280xgpio_do): '<Root>/Digital Output' */\r\n  {\r\n    if (pwm_B.PulseGenerator) {\r\n      GpioDataRegs.GPBSET.bit.GPIO34 = 1U;\r\n    } else {\r\n      GpioDataRegs.GPBCLEAR.bit.GPIO34 = 1U;\r\n    }\r\n  }\r\n}\r\n\r\n/* Model initialize function */\r\nvoid pwm_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)pwm_M, 0,\r\n                sizeof(RT_MODEL_pwm_T));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &pwm_B), 0,\r\n                sizeof(B_pwm_T));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&pwm_DW, 0,\r\n                sizeof(DW_pwm_T));\r\n\r\n  /* Start for S-Function (c2802xadc): '<Root>/ADC1' */\r\n  if (MW_adcBInitFlag == 0U) {\r\n    InitAdcB();\r\n    MW_adcBInitFlag = 1U;\r\n  }\r\n\r\n  config_ADCB_SOC3 ();\r\n\r\n  /* Start for S-Function (c2802xpwm): '<Root>/ePWM' */\r\n\r\n  /*** Initialize ePWM1 modules ***/\r\n  {\r\n    /*  // Time Base Control Register\r\n       EPwm1Regs.TBCTL.bit.CTRMODE              = 2U;          // Counter Mode\r\n       EPwm1Regs.TBCTL.bit.SYNCOSEL             = 3U;          // Sync Output Select\r\n       EPwm1Regs.TBCTL2.bit.SYNCOSELX           = 0U;          // Sync Output Select - additional options\r\n\r\n       EPwm1Regs.TBCTL.bit.PRDLD                = 0U;          // Shadow select\r\n\r\n       EPwm1Regs.TBCTL2.bit.PRDLDSYNC           = 0U;          // Shadow select\r\n\r\n       EPwm1Regs.TBCTL.bit.PHSEN                = 0U;          // Phase Load Enable\r\n       EPwm1Regs.TBCTL.bit.PHSDIR               = 0U;          // Phase Direction Bit\r\n       EPwm1Regs.TBCTL.bit.HSPCLKDIV            = 0U;          // High Speed TBCLK Pre-scaler\r\n       EPwm1Regs.TBCTL.bit.CLKDIV               = 0U;          // Time Base Clock Pre-scaler\r\n     */\r\n    EPwm1Regs.TBCTL.all = (EPwm1Regs.TBCTL.all & ~0x3FFFU) | 0x32U;\r\n    EPwm1Regs.TBCTL2.all = (EPwm1Regs.TBCTL2.all & ~0xF000U) | 0x0U;\r\n\r\n    /*-- Setup Time-Base (TB) Submodule --*/\r\n    EPwm1Regs.TBPRD = 1667U;           // Time Base Period Register\r\n\r\n    /* // Time-Base Phase Register\r\n       EPwm1Regs.TBPHS.bit.TBPHS               = 0U;          // Phase offset register\r\n     */\r\n    EPwm1Regs.TBPHS.all = (EPwm1Regs.TBPHS.all & ~0xFFFF0000U) | 0x0U;\r\n\r\n    // Time Base Counter Register\r\n    EPwm1Regs.TBCTR = 0x0000U;         /* Clear counter*/\r\n\r\n    /*-- Setup Counter_Compare (CC) Submodule --*/\r\n    /*\t// Counter Compare Control Register\r\n\r\n       EPwm1Regs.CMPCTL.bit.LOADASYNC           = 0U;          // Active Compare A Load SYNC Option\r\n       EPwm1Regs.CMPCTL.bit.LOADBSYNC           = 0U;          // Active Compare B Load SYNC Option\r\n       EPwm1Regs.CMPCTL.bit.LOADAMODE           = 0U;          // Active Compare A Load\r\n       EPwm1Regs.CMPCTL.bit.LOADBMODE           = 0U;          // Active Compare B Load\r\n       EPwm1Regs.CMPCTL.bit.SHDWAMODE           = 0U;          // Compare A Register Block Operating Mode\r\n       EPwm1Regs.CMPCTL.bit.SHDWBMODE           = 0U;          // Compare B Register Block Operating Mode\r\n     */\r\n    EPwm1Regs.CMPCTL.all = (EPwm1Regs.CMPCTL.all & ~0x3C5FU) | 0x0U;\r\n\r\n    /* EPwm1Regs.CMPCTL2.bit.SHDWCMODE           = 0U;          // Compare C Register Block Operating Mode\r\n       EPwm1Regs.CMPCTL2.bit.SHDWDMODE           = 0U;          // Compare D Register Block Operating Mode\r\n       EPwm1Regs.CMPCTL2.bit.LOADCSYNC           = 0U;          // Active Compare C Load SYNC Option\r\n       EPwm1Regs.CMPCTL2.bit.LOADDSYNC           = 0U;          // Active Compare D Load SYNC Option\r\n       EPwm1Regs.CMPCTL2.bit.LOADCMODE           = 0U;          // Active Compare C Load\r\n       EPwm1Regs.CMPCTL2.bit.LOADDMODE           = 0U;          // Active Compare D Load\r\n     */\r\n    EPwm1Regs.CMPCTL2.all = (EPwm1Regs.CMPCTL2.all & ~0x3C5FU) | 0x0U;\r\n    EPwm1Regs.CMPA.bit.CMPA = 833U;    // Counter Compare A Register\r\n    EPwm1Regs.CMPB.bit.CMPB = 833U;    // Counter Compare B Register\r\n    EPwm1Regs.CMPC = 32000U;           // Counter Compare C Register\r\n    EPwm1Regs.CMPD = 32000U;           // Counter Compare D Register\r\n\r\n    /*-- Setup Action-Qualifier (AQ) Submodule --*/\r\n    EPwm1Regs.AQCTLA.all = 144U;\r\n                               // Action Qualifier Control Register For Output A\r\n    EPwm1Regs.AQCTLB.all = 96U;// Action Qualifier Control Register For Output B\r\n\r\n    /*\t// Action Qualifier Software Force Register\r\n       EPwm1Regs.AQSFRC.bit.RLDCSF              = 0U;          // Reload from Shadow Options\r\n     */\r\n    EPwm1Regs.AQSFRC.all = (EPwm1Regs.AQSFRC.all & ~0xC0U) | 0x0U;\r\n\r\n    /*\t// Action Qualifier Continuous S/W Force Register\r\n       EPwm1Regs.AQCSFRC.bit.CSFA               = 0U;          // Continuous Software Force on output A\r\n       EPwm1Regs.AQCSFRC.bit.CSFB               = 0U;          // Continuous Software Force on output B\r\n     */\r\n    EPwm1Regs.AQCSFRC.all = (EPwm1Regs.AQCSFRC.all & ~0xFU) | 0x0U;\r\n\r\n    /*-- Setup Dead-Band Generator (DB) Submodule --*/\r\n    /*\t// Dead-Band Generator Control Register\r\n       EPwm1Regs.DBCTL.bit.OUT_MODE             = 0U;          // Dead Band Output Mode Control\r\n       EPwm1Regs.DBCTL.bit.IN_MODE              = 0U;          // Dead Band Input Select Mode Control\r\n       EPwm1Regs.DBCTL.bit.POLSEL               = 0;          // Polarity Select Control\r\n       EPwm1Regs.DBCTL.bit.HALFCYCLE            = 0U;          // Half Cycle Clocking Enable\r\n       EPwm1Regs.DBCTL.bit.SHDWDBREDMODE        = 0U;          // DBRED shadow mode\r\n       EPwm1Regs.DBCTL.bit.SHDWDBFEDMODE        = 0U;          // DBFED shadow mode\r\n       EPwm1Regs.DBCTL.bit.LOADREDMODE          = 4U;        // DBRED load\r\n       EPwm1Regs.DBCTL.bit.LOADFEDMODE          = 4U;        // DBFED load\r\n     */\r\n    EPwm1Regs.DBCTL.all = (EPwm1Regs.DBCTL.all & ~0x8FFFU) | 0x0U;\r\n    EPwm1Regs.DBRED.bit.DBRED = (uint16_T)(0);\r\n                         // Dead-Band Generator Rising Edge Delay Count Register\r\n    EPwm1Regs.DBFED.bit.DBFED = (uint16_T)(0);\r\n                        // Dead-Band Generator Falling Edge Delay Count Register\r\n\r\n    /*-- Setup Event-Trigger (ET) Submodule --*/\r\n    /*\t// Event Trigger Selection and Pre-Scale Register\r\n       EPwm1Regs.ETSEL.bit.SOCAEN               = 0U;          // Start of Conversion A Enable\r\n       EPwm1Regs.ETSEL.bit.SOCASELCMP           = 0U;\r\n       EPwm1Regs.ETSEL.bit.SOCASEL              = 0U;          // Start of Conversion A Select\r\n       EPwm1Regs.ETPS.bit.SOCPSSEL              = 1U;          // EPWM1SOC Period Select\r\n       EPwm1Regs.ETSOCPS.bit.SOCAPRD2           = 1U;\r\n       EPwm1Regs.ETSEL.bit.SOCBEN               = 0U;          // Start of Conversion B Enable\r\n       EPwm1Regs.ETSEL.bit.SOCBSELCMP           = 0U;\r\n       EPwm1Regs.ETSEL.bit.SOCBSEL              = 1U;          // Start of Conversion A Select\r\n       EPwm1Regs.ETPS.bit.SOCPSSEL              = 1;          // EPWM1SOCB Period Select\r\n       EPwm1Regs.ETSOCPS.bit.SOCBPRD2           = 1U;\r\n       EPwm1Regs.ETSEL.bit.INTEN                = 0U;          // EPWM1INTn Enable\r\n       EPwm1Regs.ETSEL.bit.INTSELCMP            = 0U;\r\n       EPwm1Regs.ETSEL.bit.INTSEL               = 1U;          // Start of Conversion A Select\r\n       EPwm1Regs.ETPS.bit.INTPSSEL              = 1U;          // EPWM1INTn Period Select\r\n       EPwm1Regs.ETINTPS.bit.INTPRD2            = 1U;\r\n     */\r\n    EPwm1Regs.ETSEL.all = (EPwm1Regs.ETSEL.all & ~0xFF7FU) | 0x1001U;\r\n    EPwm1Regs.ETPS.all = (EPwm1Regs.ETPS.all & ~0x30U) | 0x30U;\r\n    EPwm1Regs.ETSOCPS.all = (EPwm1Regs.ETSOCPS.all & ~0xF0FU) | 0x101U;\r\n    EPwm1Regs.ETINTPS.all = (EPwm1Regs.ETINTPS.all & ~0xFU) | 0x1U;\r\n\r\n    /*-- Setup PWM-Chopper (PC) Submodule --*/\r\n    /*\t// PWM Chopper Control Register\r\n       EPwm1Regs.PCCTL.bit.CHPEN                = 0U;          // PWM chopping enable\r\n       EPwm1Regs.PCCTL.bit.CHPFREQ              = 0U;          // Chopping clock frequency\r\n       EPwm1Regs.PCCTL.bit.OSHTWTH              = 0U;          // One-shot pulse width\r\n       EPwm1Regs.PCCTL.bit.CHPDUTY              = 0U;          // Chopping clock Duty cycle\r\n     */\r\n    EPwm1Regs.PCCTL.all = (EPwm1Regs.PCCTL.all & ~0x7FFU) | 0x0U;\r\n\r\n    /*-- Set up Trip-Zone (TZ) Submodule --*/\r\n    EALLOW;\r\n    EPwm1Regs.TZSEL.all = 0U;          // Trip Zone Select Register\r\n\r\n    /*\t// Trip Zone Control Register\r\n       EPwm1Regs.TZCTL.bit.TZA                  = 3U;          // TZ1 to TZ6 Trip Action On EPWM1A\r\n       EPwm1Regs.TZCTL.bit.TZB                  = 3U;          // TZ1 to TZ6 Trip Action On EPWM1B\r\n       EPwm1Regs.TZCTL.bit.DCAEVT1              = 3U;          // EPWM1A action on DCAEVT1\r\n       EPwm1Regs.TZCTL.bit.DCAEVT2              = 3U;          // EPWM1A action on DCAEVT2\r\n       EPwm1Regs.TZCTL.bit.DCBEVT1              = 3U;          // EPWM1B action on DCBEVT1\r\n       EPwm1Regs.TZCTL.bit.DCBEVT2              = 3U;          // EPWM1B action on DCBEVT2\r\n     */\r\n    EPwm1Regs.TZCTL.all = (EPwm1Regs.TZCTL.all & ~0xFFFU) | 0xFFFU;\r\n\r\n    /*\t// Trip Zone Enable Interrupt Register\r\n       EPwm1Regs.TZEINT.bit.OST                 = 0U;          // Trip Zones One Shot Int Enable\r\n       EPwm1Regs.TZEINT.bit.CBC                 = 0U;          // Trip Zones Cycle By Cycle Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCAEVT1             = 0U;          // Digital Compare A Event 1 Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCAEVT2             = 0U;          // Digital Compare A Event 2 Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCBEVT1             = 0U;          // Digital Compare B Event 1 Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCBEVT2             = 0U;          // Digital Compare B Event 2 Int Enable\r\n     */\r\n    EPwm1Regs.TZEINT.all = (EPwm1Regs.TZEINT.all & ~0x7EU) | 0x0U;\r\n\r\n    /*\t// Digital Compare A Control Register\r\n       EPwm1Regs.DCACTL.bit.EVT1SYNCE           = 0U;          // DCAEVT1 SYNC Enable\r\n       EPwm1Regs.DCACTL.bit.EVT1SOCE            = 1U;          // DCAEVT1 SOC Enable\r\n       EPwm1Regs.DCACTL.bit.EVT1FRCSYNCSEL      = 0U;          // DCAEVT1 Force Sync Signal\r\n       EPwm1Regs.DCACTL.bit.EVT1SRCSEL          = 0U;          // DCAEVT1 Source Signal\r\n       EPwm1Regs.DCACTL.bit.EVT2FRCSYNCSEL      = 0U;          // DCAEVT2 Force Sync Signal\r\n       EPwm1Regs.DCACTL.bit.EVT2SRCSEL          = 0U;          // DCAEVT2 Source Signal\r\n     */\r\n    EPwm1Regs.DCACTL.all = (EPwm1Regs.DCACTL.all & ~0x30FU) | 0x4U;\r\n\r\n    /*\t// Digital Compare B Control Register\r\n       EPwm1Regs.DCBCTL.bit.EVT1SYNCE           = 0U;          // DCBEVT1 SYNC Enable\r\n       EPwm1Regs.DCBCTL.bit.EVT1SOCE            = 0U;          // DCBEVT1 SOC Enable\r\n       EPwm1Regs.DCBCTL.bit.EVT1FRCSYNCSEL      = 0U;          // DCBEVT1 Force Sync Signal\r\n       EPwm1Regs.DCBCTL.bit.EVT1SRCSEL          = 0U;          // DCBEVT1 Source Signal\r\n       EPwm1Regs.DCBCTL.bit.EVT2FRCSYNCSEL      = 0U;          // DCBEVT2 Force Sync Signal\r\n       EPwm1Regs.DCBCTL.bit.EVT2SRCSEL          = 0U;          // DCBEVT2 Source Signal\r\n     */\r\n    EPwm1Regs.DCBCTL.all = (EPwm1Regs.DCBCTL.all & ~0x30FU) | 0x0U;\r\n\r\n    /*\t// Digital Compare Trip Select Register\r\n       EPwm1Regs.DCTRIPSEL.bit.DCAHCOMPSEL      = 0U;          // Digital Compare A High COMP Input Select\r\n\r\n       EPwm1Regs.DCTRIPSEL.bit.DCALCOMPSEL      = 1U;          // Digital Compare A Low COMP Input Select\r\n       EPwm1Regs.DCTRIPSEL.bit.DCBHCOMPSEL      = 0U;          // Digital Compare B High COMP Input Select\r\n       EPwm1Regs.DCTRIPSEL.bit.DCBLCOMPSEL      = 1U;          // Digital Compare B Low COMP Input Select\r\n     */\r\n    EPwm1Regs.DCTRIPSEL.all = (EPwm1Regs.DCTRIPSEL.all & ~ 0xFFFFU) | 0x1010U;\r\n\r\n    /*\t// Trip Zone Digital Comparator Select Register\r\n       EPwm1Regs.TZDCSEL.bit.DCAEVT1            = 0U;          // Digital Compare Output A Event 1\r\n       EPwm1Regs.TZDCSEL.bit.DCAEVT2            = 0U;          // Digital Compare Output A Event 2\r\n       EPwm1Regs.TZDCSEL.bit.DCBEVT1            = 0U;          // Digital Compare Output B Event 1\r\n       EPwm1Regs.TZDCSEL.bit.DCBEVT2            = 0U;          // Digital Compare Output B Event 2\r\n     */\r\n    EPwm1Regs.TZDCSEL.all = (EPwm1Regs.TZDCSEL.all & ~0xFFFU) | 0x0U;\r\n\r\n    /*\t// Digital Compare Filter Control Register\r\n       EPwm1Regs.DCFCTL.bit.BLANKE              = 0U;          // Blanking Enable/Disable\r\n       EPwm1Regs.DCFCTL.bit.PULSESEL            = 1U;          // Pulse Select for Blanking & Capture Alignment\r\n       EPwm1Regs.DCFCTL.bit.BLANKINV            = 0U;          // Blanking Window Inversion\r\n       EPwm1Regs.DCFCTL.bit.SRCSEL              = 0U;          // Filter Block Signal Source Select\r\n     */\r\n    EPwm1Regs.DCFCTL.all = (EPwm1Regs.DCFCTL.all & ~0x3FU) | 0x10U;\r\n    EPwm1Regs.DCFOFFSET = 0U;          // Digital Compare Filter Offset Register\r\n    EPwm1Regs.DCFWINDOW = 0U;          // Digital Compare Filter Window Register\r\n\r\n    /*\t// Digital Compare Capture Control Register\r\n       EPwm1Regs.DCCAPCTL.bit.CAPE              = 0U;          // Counter Capture Enable\r\n     */\r\n    EPwm1Regs.DCCAPCTL.all = (EPwm1Regs.DCCAPCTL.all & ~0x1U) | 0x0U;\r\n\r\n    /*\t// HRPWM Configuration Register\r\n       EPwm1Regs.HRCNFG.bit.SWAPAB              = 0U;          // Swap EPWMA and EPWMB Outputs Bit\r\n       EPwm1Regs.HRCNFG.bit.SELOUTB             = 0U;          // EPWMB Output Selection Bit\r\n     */\r\n    EPwm1Regs.HRCNFG.all = (EPwm1Regs.HRCNFG.all & ~0xA0U) | 0x0U;\r\n\r\n    /* Update the Link Registers with the link value for all the Compare values and TBPRD */\r\n    /* No error is thrown if the ePWM register exists in the model or not */\r\n    EPwm1Regs.EPWMXLINK.bit.TBPRDLINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPALINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPBLINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPCLINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPDLINK = 0U;\r\n\r\n    /* SYNCPER - Peripheral synchronization output event\r\n       EPwm1Regs.HRPCTL.bit.PWMSYNCSEL            = 0U;          // EPWMSYNCPER selection\r\n       EPwm1Regs.HRPCTL.bit.PWMSYNCSELX           = 0U;          //  EPWMSYNCPER selection\r\n     */\r\n    EPwm1Regs.HRPCTL.all = (EPwm1Regs.HRPCTL.all & ~0x72U) | 0x0U;\r\n    EDIS;\r\n  }\r\n\r\n  /* Start for S-Function (c2802xpwm): '<Root>/ePWM1' */\r\n\r\n  /*** Initialize ePWM2 modules ***/\r\n  {\r\n    /*  // Time Base Control Register\r\n       EPwm2Regs.TBCTL.bit.CTRMODE              = 2U;          // Counter Mode\r\n       EPwm2Regs.TBCTL.bit.SYNCOSEL             = 3U;          // Sync Output Select\r\n       EPwm2Regs.TBCTL2.bit.SYNCOSELX           = 0U;          // Sync Output Select - additional options\r\n\r\n       EPwm2Regs.TBCTL.bit.PRDLD                = 0U;          // Shadow select\r\n\r\n       EPwm2Regs.TBCTL2.bit.PRDLDSYNC           = 0U;          // Shadow select\r\n\r\n       EPwm2Regs.TBCTL.bit.PHSEN                = 0U;          // Phase Load Enable\r\n       EPwm2Regs.TBCTL.bit.PHSDIR               = 0U;          // Phase Direction Bit\r\n       EPwm2Regs.TBCTL.bit.HSPCLKDIV            = 0U;          // High Speed TBCLK Pre-scaler\r\n       EPwm2Regs.TBCTL.bit.CLKDIV               = 0U;          // Time Base Clock Pre-scaler\r\n     */\r\n    EPwm2Regs.TBCTL.all = (EPwm2Regs.TBCTL.all & ~0x3FFFU) | 0x32U;\r\n    EPwm2Regs.TBCTL2.all = (EPwm2Regs.TBCTL2.all & ~0xF000U) | 0x0U;\r\n\r\n    /*-- Setup Time-Base (TB) Submodule --*/\r\n    EPwm2Regs.TBPRD = 1667U;           // Time Base Period Register\r\n\r\n    /* // Time-Base Phase Register\r\n       EPwm2Regs.TBPHS.bit.TBPHS               = 0U;          // Phase offset register\r\n     */\r\n    EPwm2Regs.TBPHS.all = (EPwm2Regs.TBPHS.all & ~0xFFFF0000U) | 0x0U;\r\n\r\n    // Time Base Counter Register\r\n    EPwm2Regs.TBCTR = 0x0000U;         /* Clear counter*/\r\n\r\n    /*-- Setup Counter_Compare (CC) Submodule --*/\r\n    /*\t// Counter Compare Control Register\r\n\r\n       EPwm2Regs.CMPCTL.bit.LOADASYNC           = 0U;          // Active Compare A Load SYNC Option\r\n       EPwm2Regs.CMPCTL.bit.LOADBSYNC           = 0U;          // Active Compare B Load SYNC Option\r\n       EPwm2Regs.CMPCTL.bit.LOADAMODE           = 0U;          // Active Compare A Load\r\n       EPwm2Regs.CMPCTL.bit.LOADBMODE           = 0U;          // Active Compare B Load\r\n       EPwm2Regs.CMPCTL.bit.SHDWAMODE           = 0U;          // Compare A Register Block Operating Mode\r\n       EPwm2Regs.CMPCTL.bit.SHDWBMODE           = 0U;          // Compare B Register Block Operating Mode\r\n     */\r\n    EPwm2Regs.CMPCTL.all = (EPwm2Regs.CMPCTL.all & ~0x3C5FU) | 0x0U;\r\n\r\n    /* EPwm2Regs.CMPCTL2.bit.SHDWCMODE           = 0U;          // Compare C Register Block Operating Mode\r\n       EPwm2Regs.CMPCTL2.bit.SHDWDMODE           = 0U;          // Compare D Register Block Operating Mode\r\n       EPwm2Regs.CMPCTL2.bit.LOADCSYNC           = 0U;          // Active Compare C Load SYNC Option\r\n       EPwm2Regs.CMPCTL2.bit.LOADDSYNC           = 0U;          // Active Compare D Load SYNC Option\r\n       EPwm2Regs.CMPCTL2.bit.LOADCMODE           = 0U;          // Active Compare C Load\r\n       EPwm2Regs.CMPCTL2.bit.LOADDMODE           = 0U;          // Active Compare D Load\r\n     */\r\n    EPwm2Regs.CMPCTL2.all = (EPwm2Regs.CMPCTL2.all & ~0x3C5FU) | 0x0U;\r\n    EPwm2Regs.CMPA.bit.CMPA = 833U;    // Counter Compare A Register\r\n    EPwm2Regs.CMPB.bit.CMPB = 833U;    // Counter Compare B Register\r\n    EPwm2Regs.CMPC = 32000U;           // Counter Compare C Register\r\n    EPwm2Regs.CMPD = 32000U;           // Counter Compare D Register\r\n\r\n    /*-- Setup Action-Qualifier (AQ) Submodule --*/\r\n    EPwm2Regs.AQCTLA.all = 96U;// Action Qualifier Control Register For Output A\r\n    EPwm2Regs.AQCTLB.all = 144U;\r\n                               // Action Qualifier Control Register For Output B\r\n\r\n    /*\t// Action Qualifier Software Force Register\r\n       EPwm2Regs.AQSFRC.bit.RLDCSF              = 0U;          // Reload from Shadow Options\r\n     */\r\n    EPwm2Regs.AQSFRC.all = (EPwm2Regs.AQSFRC.all & ~0xC0U) | 0x0U;\r\n\r\n    /*\t// Action Qualifier Continuous S/W Force Register\r\n       EPwm2Regs.AQCSFRC.bit.CSFA               = 0U;          // Continuous Software Force on output A\r\n       EPwm2Regs.AQCSFRC.bit.CSFB               = 0U;          // Continuous Software Force on output B\r\n     */\r\n    EPwm2Regs.AQCSFRC.all = (EPwm2Regs.AQCSFRC.all & ~0xFU) | 0x0U;\r\n\r\n    /*-- Setup Dead-Band Generator (DB) Submodule --*/\r\n    /*\t// Dead-Band Generator Control Register\r\n       EPwm2Regs.DBCTL.bit.OUT_MODE             = 0U;          // Dead Band Output Mode Control\r\n       EPwm2Regs.DBCTL.bit.IN_MODE              = 0U;          // Dead Band Input Select Mode Control\r\n       EPwm2Regs.DBCTL.bit.POLSEL               = 0;          // Polarity Select Control\r\n       EPwm2Regs.DBCTL.bit.HALFCYCLE            = 0U;          // Half Cycle Clocking Enable\r\n       EPwm2Regs.DBCTL.bit.SHDWDBREDMODE        = 0U;          // DBRED shadow mode\r\n       EPwm2Regs.DBCTL.bit.SHDWDBFEDMODE        = 0U;          // DBFED shadow mode\r\n       EPwm2Regs.DBCTL.bit.LOADREDMODE          = 4U;        // DBRED load\r\n       EPwm2Regs.DBCTL.bit.LOADFEDMODE          = 4U;        // DBFED load\r\n     */\r\n    EPwm2Regs.DBCTL.all = (EPwm2Regs.DBCTL.all & ~0x8FFFU) | 0x0U;\r\n    EPwm2Regs.DBRED.bit.DBRED = (uint16_T)(0);\r\n                         // Dead-Band Generator Rising Edge Delay Count Register\r\n    EPwm2Regs.DBFED.bit.DBFED = (uint16_T)(0);\r\n                        // Dead-Band Generator Falling Edge Delay Count Register\r\n\r\n    /*-- Setup Event-Trigger (ET) Submodule --*/\r\n    /*\t// Event Trigger Selection and Pre-Scale Register\r\n       EPwm2Regs.ETSEL.bit.SOCAEN               = 0U;          // Start of Conversion A Enable\r\n       EPwm2Regs.ETSEL.bit.SOCASELCMP           = 0U;\r\n       EPwm2Regs.ETSEL.bit.SOCASEL              = 0U;          // Start of Conversion A Select\r\n       EPwm2Regs.ETPS.bit.SOCPSSEL              = 1U;          // EPWM2SOC Period Select\r\n       EPwm2Regs.ETSOCPS.bit.SOCAPRD2           = 1U;\r\n       EPwm2Regs.ETSEL.bit.SOCBEN               = 0U;          // Start of Conversion B Enable\r\n       EPwm2Regs.ETSEL.bit.SOCBSELCMP           = 0U;\r\n       EPwm2Regs.ETSEL.bit.SOCBSEL              = 1U;          // Start of Conversion A Select\r\n       EPwm2Regs.ETPS.bit.SOCPSSEL              = 1;          // EPWM2SOCB Period Select\r\n       EPwm2Regs.ETSOCPS.bit.SOCBPRD2           = 1U;\r\n       EPwm2Regs.ETSEL.bit.INTEN                = 0U;          // EPWM2INTn Enable\r\n       EPwm2Regs.ETSEL.bit.INTSELCMP            = 0U;\r\n       EPwm2Regs.ETSEL.bit.INTSEL               = 1U;          // Start of Conversion A Select\r\n       EPwm2Regs.ETPS.bit.INTPSSEL              = 1U;          // EPWM2INTn Period Select\r\n       EPwm2Regs.ETINTPS.bit.INTPRD2            = 1U;\r\n     */\r\n    EPwm2Regs.ETSEL.all = (EPwm2Regs.ETSEL.all & ~0xFF7FU) | 0x1001U;\r\n    EPwm2Regs.ETPS.all = (EPwm2Regs.ETPS.all & ~0x30U) | 0x30U;\r\n    EPwm2Regs.ETSOCPS.all = (EPwm2Regs.ETSOCPS.all & ~0xF0FU) | 0x101U;\r\n    EPwm2Regs.ETINTPS.all = (EPwm2Regs.ETINTPS.all & ~0xFU) | 0x1U;\r\n\r\n    /*-- Setup PWM-Chopper (PC) Submodule --*/\r\n    /*\t// PWM Chopper Control Register\r\n       EPwm2Regs.PCCTL.bit.CHPEN                = 0U;          // PWM chopping enable\r\n       EPwm2Regs.PCCTL.bit.CHPFREQ              = 0U;          // Chopping clock frequency\r\n       EPwm2Regs.PCCTL.bit.OSHTWTH              = 0U;          // One-shot pulse width\r\n       EPwm2Regs.PCCTL.bit.CHPDUTY              = 0U;          // Chopping clock Duty cycle\r\n     */\r\n    EPwm2Regs.PCCTL.all = (EPwm2Regs.PCCTL.all & ~0x7FFU) | 0x0U;\r\n\r\n    /*-- Set up Trip-Zone (TZ) Submodule --*/\r\n    EALLOW;\r\n    EPwm2Regs.TZSEL.all = 0U;          // Trip Zone Select Register\r\n\r\n    /*\t// Trip Zone Control Register\r\n       EPwm2Regs.TZCTL.bit.TZA                  = 3U;          // TZ1 to TZ6 Trip Action On EPWM2A\r\n       EPwm2Regs.TZCTL.bit.TZB                  = 3U;          // TZ1 to TZ6 Trip Action On EPWM2B\r\n       EPwm2Regs.TZCTL.bit.DCAEVT1              = 3U;          // EPWM2A action on DCAEVT1\r\n       EPwm2Regs.TZCTL.bit.DCAEVT2              = 3U;          // EPWM2A action on DCAEVT2\r\n       EPwm2Regs.TZCTL.bit.DCBEVT1              = 3U;          // EPWM2B action on DCBEVT1\r\n       EPwm2Regs.TZCTL.bit.DCBEVT2              = 3U;          // EPWM2B action on DCBEVT2\r\n     */\r\n    EPwm2Regs.TZCTL.all = (EPwm2Regs.TZCTL.all & ~0xFFFU) | 0xFFFU;\r\n\r\n    /*\t// Trip Zone Enable Interrupt Register\r\n       EPwm2Regs.TZEINT.bit.OST                 = 0U;          // Trip Zones One Shot Int Enable\r\n       EPwm2Regs.TZEINT.bit.CBC                 = 0U;          // Trip Zones Cycle By Cycle Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCAEVT1             = 0U;          // Digital Compare A Event 1 Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCAEVT2             = 0U;          // Digital Compare A Event 2 Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCBEVT1             = 0U;          // Digital Compare B Event 1 Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCBEVT2             = 0U;          // Digital Compare B Event 2 Int Enable\r\n     */\r\n    EPwm2Regs.TZEINT.all = (EPwm2Regs.TZEINT.all & ~0x7EU) | 0x0U;\r\n\r\n    /*\t// Digital Compare A Control Register\r\n       EPwm2Regs.DCACTL.bit.EVT1SYNCE           = 0U;          // DCAEVT1 SYNC Enable\r\n       EPwm2Regs.DCACTL.bit.EVT1SOCE            = 1U;          // DCAEVT1 SOC Enable\r\n       EPwm2Regs.DCACTL.bit.EVT1FRCSYNCSEL      = 0U;          // DCAEVT1 Force Sync Signal\r\n       EPwm2Regs.DCACTL.bit.EVT1SRCSEL          = 0U;          // DCAEVT1 Source Signal\r\n       EPwm2Regs.DCACTL.bit.EVT2FRCSYNCSEL      = 0U;          // DCAEVT2 Force Sync Signal\r\n       EPwm2Regs.DCACTL.bit.EVT2SRCSEL          = 0U;          // DCAEVT2 Source Signal\r\n     */\r\n    EPwm2Regs.DCACTL.all = (EPwm2Regs.DCACTL.all & ~0x30FU) | 0x4U;\r\n\r\n    /*\t// Digital Compare B Control Register\r\n       EPwm2Regs.DCBCTL.bit.EVT1SYNCE           = 0U;          // DCBEVT1 SYNC Enable\r\n       EPwm2Regs.DCBCTL.bit.EVT1SOCE            = 0U;          // DCBEVT1 SOC Enable\r\n       EPwm2Regs.DCBCTL.bit.EVT1FRCSYNCSEL      = 0U;          // DCBEVT1 Force Sync Signal\r\n       EPwm2Regs.DCBCTL.bit.EVT1SRCSEL          = 0U;          // DCBEVT1 Source Signal\r\n       EPwm2Regs.DCBCTL.bit.EVT2FRCSYNCSEL      = 0U;          // DCBEVT2 Force Sync Signal\r\n       EPwm2Regs.DCBCTL.bit.EVT2SRCSEL          = 0U;          // DCBEVT2 Source Signal\r\n     */\r\n    EPwm2Regs.DCBCTL.all = (EPwm2Regs.DCBCTL.all & ~0x30FU) | 0x0U;\r\n\r\n    /*\t// Digital Compare Trip Select Register\r\n       EPwm2Regs.DCTRIPSEL.bit.DCAHCOMPSEL      = 0U;          // Digital Compare A High COMP Input Select\r\n\r\n       EPwm2Regs.DCTRIPSEL.bit.DCALCOMPSEL      = 1U;          // Digital Compare A Low COMP Input Select\r\n       EPwm2Regs.DCTRIPSEL.bit.DCBHCOMPSEL      = 0U;          // Digital Compare B High COMP Input Select\r\n       EPwm2Regs.DCTRIPSEL.bit.DCBLCOMPSEL      = 1U;          // Digital Compare B Low COMP Input Select\r\n     */\r\n    EPwm2Regs.DCTRIPSEL.all = (EPwm2Regs.DCTRIPSEL.all & ~ 0xFFFFU) | 0x1010U;\r\n\r\n    /*\t// Trip Zone Digital Comparator Select Register\r\n       EPwm2Regs.TZDCSEL.bit.DCAEVT1            = 0U;          // Digital Compare Output A Event 1\r\n       EPwm2Regs.TZDCSEL.bit.DCAEVT2            = 0U;          // Digital Compare Output A Event 2\r\n       EPwm2Regs.TZDCSEL.bit.DCBEVT1            = 0U;          // Digital Compare Output B Event 1\r\n       EPwm2Regs.TZDCSEL.bit.DCBEVT2            = 0U;          // Digital Compare Output B Event 2\r\n     */\r\n    EPwm2Regs.TZDCSEL.all = (EPwm2Regs.TZDCSEL.all & ~0xFFFU) | 0x0U;\r\n\r\n    /*\t// Digital Compare Filter Control Register\r\n       EPwm2Regs.DCFCTL.bit.BLANKE              = 0U;          // Blanking Enable/Disable\r\n       EPwm2Regs.DCFCTL.bit.PULSESEL            = 1U;          // Pulse Select for Blanking & Capture Alignment\r\n       EPwm2Regs.DCFCTL.bit.BLANKINV            = 0U;          // Blanking Window Inversion\r\n       EPwm2Regs.DCFCTL.bit.SRCSEL              = 0U;          // Filter Block Signal Source Select\r\n     */\r\n    EPwm2Regs.DCFCTL.all = (EPwm2Regs.DCFCTL.all & ~0x3FU) | 0x10U;\r\n    EPwm2Regs.DCFOFFSET = 0U;          // Digital Compare Filter Offset Register\r\n    EPwm2Regs.DCFWINDOW = 0U;          // Digital Compare Filter Window Register\r\n\r\n    /*\t// Digital Compare Capture Control Register\r\n       EPwm2Regs.DCCAPCTL.bit.CAPE              = 0U;          // Counter Capture Enable\r\n     */\r\n    EPwm2Regs.DCCAPCTL.all = (EPwm2Regs.DCCAPCTL.all & ~0x1U) | 0x0U;\r\n\r\n    /*\t// HRPWM Configuration Register\r\n       EPwm2Regs.HRCNFG.bit.SWAPAB              = 0U;          // Swap EPWMA and EPWMB Outputs Bit\r\n       EPwm2Regs.HRCNFG.bit.SELOUTB             = 0U;          // EPWMB Output Selection Bit\r\n     */\r\n    EPwm2Regs.HRCNFG.all = (EPwm2Regs.HRCNFG.all & ~0xA0U) | 0x0U;\r\n\r\n    /* Update the Link Registers with the link value for all the Compare values and TBPRD */\r\n    /* No error is thrown if the ePWM register exists in the model or not */\r\n    EPwm2Regs.EPWMXLINK.bit.TBPRDLINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPALINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPBLINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPCLINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPDLINK = 1U;\r\n\r\n    /* SYNCPER - Peripheral synchronization output event\r\n       EPwm2Regs.HRPCTL.bit.PWMSYNCSEL            = 0U;          // EPWMSYNCPER selection\r\n       EPwm2Regs.HRPCTL.bit.PWMSYNCSELX           = 0U;          //  EPWMSYNCPER selection\r\n     */\r\n    EPwm2Regs.HRPCTL.all = (EPwm2Regs.HRPCTL.all & ~0x72U) | 0x0U;\r\n    EDIS;\r\n  }\r\n\r\n  /* Start for DiscretePulseGenerator: '<Root>/Pulse Generator' */\r\n  pwm_DW.clockTickCounter = 0L;\r\n\r\n  /* Start for S-Function (c280xgpio_do): '<Root>/Digital Output' */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPBMUX1.all &= 0xFFFFFFCFU;\r\n  GpioCtrlRegs.GPBDIR.all |= 0x4U;\r\n  EDIS;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid pwm_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"pwm.h","type":"header","group":"model","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: pwm.h\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef pwm_h_\r\n#define pwm_h_\r\n#ifndef pwm_COMMON_INCLUDES_\r\n#define pwm_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"IQmathLib.h\"\r\n#endif                                 /* pwm_COMMON_INCLUDES_ */\r\n\r\n#include \"pwm_types.h\"\r\n#include <string.h>\r\n#include <stddef.h>\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmStepTask\r\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\r\n#endif\r\n\r\n#ifndef rtmTaskCounter\r\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\r\n#endif\r\n\r\nextern void config_ePWMSyncSource(void);\r\nextern void config_ePWM_GPIO (void);\r\nextern void config_ePWM_TBSync (void);\r\nextern void config_ePWM_XBAR(void);\r\nextern void configureIXbar(void);\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T ADC1;                         /* '<Root>/ADC1' */\r\n  real_T PulseGenerator;               /* '<Root>/Pulse Generator' */\r\n} B_pwm_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  int32_T clockTickCounter;            /* '<Root>/Pulse Generator' */\r\n  int32_T DigitalOutput_FRAC_LEN;      /* '<Root>/Digital Output' */\r\n} DW_pwm_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_pwm_T_ {\r\n  real_T Gain1_Gain;                   /* Expression: 50/4096\r\n                                        * Referenced by: '<Root>/Gain1'\r\n                                        */\r\n  real_T Constant5_Value;              /* Expression: 100\r\n                                        * Referenced by: '<Root>/Constant5'\r\n                                        */\r\n  real_T PulseGenerator_Amp;           /* Expression: 1\r\n                                        * Referenced by: '<Root>/Pulse Generator'\r\n                                        */\r\n  real_T PulseGenerator_Period;     /* Computed Parameter: PulseGenerator_Period\r\n                                     * Referenced by: '<Root>/Pulse Generator'\r\n                                     */\r\n  real_T PulseGenerator_Duty;         /* Computed Parameter: PulseGenerator_Duty\r\n                                       * Referenced by: '<Root>/Pulse Generator'\r\n                                       */\r\n  real_T PulseGenerator_PhaseDelay;    /* Expression: 0\r\n                                        * Referenced by: '<Root>/Pulse Generator'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_pwm_T {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    struct {\r\n      uint16_T TID[2];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_pwm_T pwm_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_pwm_T pwm_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_pwm_T pwm_DW;\r\n\r\n/* External function called from main */\r\nextern void pwm_SetEventsForThisBaseStep(boolean_T *eventFlags);\r\n\r\n/* Model entry point functions */\r\nextern void pwm_initialize(void);\r\nextern void pwm_step0(void);\r\nextern void pwm_step1(void);\r\nextern void pwm_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_pwm_T *const pwm_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'pwm'\r\n */\r\n#endif                                 /* pwm_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"pwm_private.h","type":"header","group":"model","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: pwm_private.h\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef pwm_private_h_\r\n#define pwm_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"pwm_types.h\"\r\n\r\nvoid InitAdcB (void);\r\nvoid config_ADCB_SOC3 (void);\r\nextern uint16_T MW_adcBInitFlag;\r\n\r\n#endif                                 /* pwm_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"pwm_types.h","type":"header","group":"model","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: pwm_types.h\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef pwm_types_h_\r\n#define pwm_types_h_\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_pwm_T_ P_pwm_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_pwm_T RT_MODEL_pwm_T;\r\n\r\n#endif                                 /* pwm_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"pwm_data.c","type":"source","group":"data","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: pwm_data.c\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"pwm.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_pwm_T pwm_P = {\r\n  /* Expression: 50/4096\r\n   * Referenced by: '<Root>/Gain1'\r\n   */\r\n  0.01220703125,\r\n\r\n  /* Expression: 100\r\n   * Referenced by: '<Root>/Constant5'\r\n   */\r\n  100.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Pulse Generator'\r\n   */\r\n  1.0,\r\n\r\n  /* Computed Parameter: PulseGenerator_Period\r\n   * Referenced by: '<Root>/Pulse Generator'\r\n   */\r\n  10.0,\r\n\r\n  /* Computed Parameter: PulseGenerator_Duty\r\n   * Referenced by: '<Root>/Pulse Generator'\r\n   */\r\n  3.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Pulse Generator'\r\n   */\r\n  0.0\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Texas Instruments->C2000\r\n *   Number of bits:     char:  16    short:   16    int:  16\r\n *                       long:  32    long long:  64\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef int int8_T;\r\ntypedef unsigned int uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned int boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'pwm'.\r\n *\r\n * Model version                  : 13.2\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Tue Aug  6 17:49:08 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"pwm.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"F2837xD_Adc.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_Adc.c\n//\n// TITLE:  F2837xD Adc Support Functions.\n//\n//###########################################################################\n//\n// $Release Date: $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// AdcSetMode - Set the resolution and signalmode for a given ADC. This will\n//              ensure that the correct trim is loaded.\n//\n// NOTE!!! There is no EALLOW/EDIS in this function! You need to make sure you\n// perform the EALLOW before calling this function or else the ADC registers\n// will not be configured.\n//\nvoid AdcSetMode(Uint16 adc, Uint16 resolution, Uint16 signalmode)\n{\n    Uint16 adcOffsetTrimOTPIndex; //index into OTP table of ADC offset trims\n    Uint16 adcOffsetTrim;         //temporary ADC offset trim\n\n    //\n    //re-populate INL trim\n    //\n    CalAdcINL(adc);\n\n    if(0xFFFF != *((Uint16*)GetAdcOffsetTrimOTP))\n    {\n        //\n        //offset trim function is programmed into OTP, so call it\n        //\n\n        //\n        //calculate the index into OTP table of offset trims and call\n        //function to return the correct offset trim\n        //\n#ifndef _DUAL_HEADERS\n        if(ADC_RESOLUTION_12BIT == resolution)\n#else\n        if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n        {\n            adcOffsetTrimOTPIndex = 4*adc + 1*signalmode;\n        }\n        else\n        {\n            adcOffsetTrimOTPIndex = 4*adc + 1*signalmode + 2;\n        }\n\n        adcOffsetTrim = (*GetAdcOffsetTrimOTP)(adcOffsetTrimOTPIndex);\n    }\n    else\n    {\n        //\n        //offset trim function is not populated, so set offset trim to 0\n        //\n        adcOffsetTrim = 0;\n    }\n\n    //\n    // Apply the resolution and signalmode to the specified ADC.\n    // Also apply the offset trim and, if needed, linearity trim correction.\n    //\n    switch(adc)\n    {\n        case ADC_ADCA:\n        {\n            AdcaRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdcaRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdcaRegs.ADCCTL2.bit.RESOLUTION = 0;\n\n                //\n                //12-bit linearity trim workaround\n                //\n                AdcaRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdcaRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdcaRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdcaRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdcaRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n        case ADC_ADCB:\n        {\n            AdcbRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdcbRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdcbRegs.ADCCTL2.bit.RESOLUTION = 0;\n\n                //\n                //12-bit linearity trim workaround\n                //\n                AdcbRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdcbRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdcbRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdcbRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdcbRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n        case ADC_ADCC:\n        {\n            AdccRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdccRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdccRegs.ADCCTL2.bit.RESOLUTION = 0;\n                //\n                //12-bit linearity trim workaround\n                //\n                AdccRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdccRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdccRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdccRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdccRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n        case ADC_ADCD:\n        {\n            AdcdRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdcdRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdcdRegs.ADCCTL2.bit.RESOLUTION = 0;\n\n                //\n                //12-bit linearity trim workaround\n                //\n                AdcdRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdcdRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdcdRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdcdRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdcdRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n    }\n}\n\n//\n// CalAdcINL - Loads INL trim values from OTP into the trim registers of the\n//             specified ADC. Use only as part of AdcSetMode function, since\n//             linearity trim correction is needed for some modes.\n//\nvoid CalAdcINL(Uint16 adc)\n{\n    switch(adc)\n    {\n        case ADC_ADCA:\n            if(0xFFFF != *((Uint16*)CalAdcaINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdcaINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n        case ADC_ADCB:\n            if(0xFFFF != *((Uint16*)CalAdcbINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdcbINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n        case ADC_ADCC:\n            if(0xFFFF != *((Uint16*)CalAdccINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdccINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n        case ADC_ADCD:\n            if(0xFFFF != *((Uint16*)CalAdcdINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdcdINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n    }\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_CodeStartBranch.asm","type":"other","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\n;//\n;// FILE:  F2837xD_CodeStartBranch.asm\n;//\n;// TITLE: Branch for redirecting code execution after boot.\n;//\n;// For these examples, code_start is the first code that is executed after\n;// exiting the boot ROM code.\n;//\n;// The codestart section in the linker cmd file is used to physically place\n;// this code at the correct memory location.  This section should be placed\n;// at the location the BOOT ROM will re-direct the code to.  For example,\n;// for boot to FLASH this code will be located at 0x3f7ff6.\n;//\n;// In addition, the example F2837xD projects are setup such that the codegen\n;// entry point is also set to the code_start label.  This is done by linker\n;// option -e in the project build options.  When the debugger loads the code,\n;// it will automatically set the PC to the \"entry point\" address indicated by\n;// the -e linker option.  In this case the debugger is simply assigning the PC,\n;// it is not the same as a full reset of the device.\n;//\n;// The compiler may warn that the entry point for the project is other then\n;//  _c_init00.  _c_init00 is the C environment setup and is run before\n;// main() is entered. The code_start code will re-direct the execution\n;// to _c_init00 and thus there is no worry and this warning can be ignored.\n;//\n;//###########################################################################\n;//\n;// $Release Date:  $\n;// $Copyright:\n;// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n;//\n;// Redistribution and use in source and binary forms, with or without \n;// modification, are permitted provided that the following conditions \n;// are met:\n;// \n;//   Redistributions of source code must retain the above copyright \n;//   notice, this list of conditions and the following disclaimer.\n;// \n;//   Redistributions in binary form must reproduce the above copyright\n;//   notice, this list of conditions and the following disclaimer in the \n;//   documentation and/or other materials provided with the   \n;//   distribution.\n;// \n;//   Neither the name of Texas Instruments Incorporated nor the names of\n;//   its contributors may be used to endorse or promote products derived\n;//   from this software without specific prior written permission.\n;// \n;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n;// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n;// $\n;//###########################################################################\n\n***********************************************************************\n\nWD_DISABLE  .set  1    ;set to 1 to disable WD, else set to 0\n\n    .ref _c_int00\n    .global code_start\n\n***********************************************************************\n* Function: codestart section\n*\n* Description: Branch to code starting point\n***********************************************************************\n\n    .sect \"codestart\"\n    .retain\n\ncode_start:\n    .if WD_DISABLE == 1\n        LB wd_disable       ;Branch to watchdog disable code\n    .else\n        LB _c_int00         ;Branch to start of boot._asm in RTS library\n    .endif\n\n;end codestart section\n\n***********************************************************************\n* Function: wd_disable\n*\n* Description: Disables the watchdog timer\n***********************************************************************\n    .if WD_DISABLE == 1\n\n    .text\nwd_disable:\n    SETC OBJMODE        ;Set OBJMODE for 28x object code\n    EALLOW              ;Enable EALLOW protected register access\n    MOVZ DP, #7029h>>6  ;Set data page for WDCR register\n    MOV @7029h, #0068h  ;Set WDDIS bit in WDCR to disable WD\n    EDIS                ;Disable EALLOW protected register access\n    LB _c_int00         ;Branch to start of boot._asm in RTS library\n\n    .endif\n\n;end wd_disable\n\n    .end\n\n;//\n;// End of file.\n;//\n"},{"name":"F2837xD_CpuTimers.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_CpuTimers.c\n//\n// TITLE:   CPU 32-bit Timers Initialization & Support Functions.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// Globals\n//\nstruct CPUTIMER_VARS CpuTimer0;\nstruct CPUTIMER_VARS CpuTimer1;\nstruct CPUTIMER_VARS CpuTimer2;\n\n//\n// InitCpuTimers - This function initializes all three CPU timers to a known\n//                 state.\n//\nvoid InitCpuTimers(void)\n{\n    //\n    // CPU Timer 0\n    // Initialize address pointers to respective timer registers:\n    //\n    CpuTimer0.RegsAddr = &CpuTimer0Regs;\n\n    //\n    // Initialize timer period to maximum:\n    //\n    CpuTimer0Regs.PRD.all  = 0xFFFFFFFF;\n\n    //\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\n    //\n    CpuTimer0Regs.TPR.all  = 0;\n    CpuTimer0Regs.TPRH.all = 0;\n\n    //\n    // Make sure timer is stopped:\n    //\n    CpuTimer0Regs.TCR.bit.TSS = 1;\n\n    //\n    // Reload all counter register with period value:\n    //\n    CpuTimer0Regs.TCR.bit.TRB = 1;\n\n    //\n    // Reset interrupt counters:\n    //\n    CpuTimer0.InterruptCount = 0;\n\n    //\n    // Initialize address pointers to respective timer registers:\n    //\n    CpuTimer1.RegsAddr = &CpuTimer1Regs;\n    CpuTimer2.RegsAddr = &CpuTimer2Regs;\n\n    //\n    // Initialize timer period to maximum:\n    //\n    CpuTimer1Regs.PRD.all  = 0xFFFFFFFF;\n    CpuTimer2Regs.PRD.all  = 0xFFFFFFFF;\n\n    //\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\n    //\n    CpuTimer1Regs.TPR.all  = 0;\n    CpuTimer1Regs.TPRH.all = 0;\n    CpuTimer2Regs.TPR.all  = 0;\n    CpuTimer2Regs.TPRH.all = 0;\n\n    //\n    // Make sure timers are stopped:\n    //\n    CpuTimer1Regs.TCR.bit.TSS = 1;\n    CpuTimer2Regs.TCR.bit.TSS = 1;\n\n    //\n    // Reload all counter register with period value:\n    //\n    CpuTimer1Regs.TCR.bit.TRB = 1;\n    CpuTimer2Regs.TCR.bit.TRB = 1;\n\n    //\n    // Reset interrupt counters:\n    //\n    CpuTimer1.InterruptCount = 0;\n    CpuTimer2.InterruptCount = 0;\n}\n\n//\n// ConfigCpuTimer - This function initializes the selected timer to the period\n//                  specified by the \"Freq\" and \"Period\" parameters. The \"Freq\"\n//                  is entered as \"MHz\" and the period in \"uSeconds\". The timer\n//                  is held in the stopped state after configuration.\n//\nvoid ConfigCpuTimer(struct CPUTIMER_VARS *Timer, float Freq, float Period)\n{\n    Uint32 temp;\n\n    //\n    // Initialize timer period:\n    //\n    Timer->CPUFreqInMHz = Freq;\n    Timer->PeriodInUSec = Period;\n    temp = (long) (Freq * Period);\n\n    //\n    // Counter decrements PRD+1 times each period\n    //\n    Timer->RegsAddr->PRD.all = temp - 1;\n\n    //\n    // Set pre-scale counter to divide by 1 (SYSCLKOUT):\n    //\n    Timer->RegsAddr->TPR.all  = 0;\n    Timer->RegsAddr->TPRH.all  = 0;\n\n    //\n    // Initialize timer control register:\n    //\n    Timer->RegsAddr->TCR.bit.TSS = 1;     // 1 = Stop timer, 0 = Start/Restart\n                                          // Timer\n    Timer->RegsAddr->TCR.bit.TRB = 1;     // 1 = reload timer\n    Timer->RegsAddr->TCR.bit.SOFT = 0;\n    Timer->RegsAddr->TCR.bit.FREE = 0;    // Timer Free Run Disabled\n    Timer->RegsAddr->TCR.bit.TIE = 1;     // 0 = Disable/ 1 = Enable Timer\n                                          // Interrupt\n\n    //\n    // Reset interrupt counter:\n    //\n    Timer->InterruptCount = 0;\n}\n\n\n//\n// End of file\n//\n"},{"name":"F2837xD_DefaultISR.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_DefaultISR.c\n//\n// TITLE:  F2837xD Device Default Interrupt Service Routines\n//\n//###########################################################################\n//   $\n// $Release Date:   $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// CPU Timer 1 Interrupt\n//\ninterrupt void TIMER1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// CPU Timer 2 Interrupt\n//\ninterrupt void TIMER2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Datalogging Interrupt\n//\ninterrupt void DATALOG_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// RTOS Interrupt\n//\ninterrupt void RTOS_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Emulation Interrupt\n//\ninterrupt void EMU_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Non-Maskable Interrupt\n//\ninterrupt void NMI_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Illegal Operation Trap\n//\ninterrupt void ILLEGAL_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 1\n//\ninterrupt void USER1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 2\n//\ninterrupt void USER2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 3\n//\ninterrupt void USER3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 4\n//\ninterrupt void USER4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 5\n//\ninterrupt void USER5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 6\n//\ninterrupt void USER6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 7\n//\ninterrupt void USER7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 8\n//\ninterrupt void USER8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 9\n//\ninterrupt void USER9_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 10\n//\ninterrupt void USER10_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 11\n//\ninterrupt void USER11_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 12\n//\ninterrupt void USER12_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.1 - ADCA Interrupt 1\n//\ninterrupt void ADCA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.2 - ADCB Interrupt 1\n//\ninterrupt void ADCB1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.3 - ADCC Interrupt 1\n//\ninterrupt void ADCC1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.4 - XINT1 Interrupt\n//\ninterrupt void XINT1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.5 - XINT2 Interrupt\n//\ninterrupt void XINT2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.6 - ADCD Interrupt 1\n//\ninterrupt void ADCD1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.7 - Timer 0 Interrupt\n//\ninterrupt void TIMER0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.8 - Standby and Halt Wakeup Interrupt\n//\ninterrupt void WAKE_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.1 - ePWM1 Trip Zone Interrupt\n//\ninterrupt void EPWM1_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.2 - ePWM2 Trip Zone Interrupt\n//\ninterrupt void EPWM2_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.3 - ePWM3 Trip Zone Interrupt\n//\ninterrupt void EPWM3_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.4 - ePWM4 Trip Zone Interrupt\n//\ninterrupt void EPWM4_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.5 - ePWM5 Trip Zone Interrupt\n//\ninterrupt void EPWM5_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.6 - ePWM6 Trip Zone Interrupt\n//\ninterrupt void EPWM6_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.7 - ePWM7 Trip Zone Interrupt\n//\ninterrupt void EPWM7_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.8 - ePWM8 Trip Zone Interrupt\n//\ninterrupt void EPWM8_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.1 - ePWM1 Interrupt\n//\ninterrupt void EPWM1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.2 - ePWM2 Interrupt\n//\ninterrupt void EPWM2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.3 - ePWM3 Interrupt\n//\ninterrupt void EPWM3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.4 - ePWM4 Interrupt\n//\ninterrupt void EPWM4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.5 - ePWM5 Interrupt\n//\ninterrupt void EPWM5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.6 - ePWM6 Interrupt\n//\ninterrupt void EPWM6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.7 - ePWM7 Interrupt\n//\ninterrupt void EPWM7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.8 - ePWM8 Interrupt\n//\ninterrupt void EPWM8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.1 - eCAP1 Interrupt\n//\ninterrupt void ECAP1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.2 - eCAP2 Interrupt\n//\ninterrupt void ECAP2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.3 - eCAP3 Interrupt\n//\ninterrupt void ECAP3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.4 - eCAP4 Interrupt\n//\ninterrupt void ECAP4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.5 - eCAP5 Interrupt\n//\ninterrupt void ECAP5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.6 - eCAP6 Interrupt\n//\ninterrupt void ECAP6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.1 - eQEP1 Interrupt\n//\ninterrupt void EQEP1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.2 - eQEP2 Interrupt\n//\ninterrupt void EQEP2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.3 - eQEP3 Interrupt\n//\ninterrupt void EQEP3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.1 - SPIA Receive Interrupt\n//\ninterrupt void SPIA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.2 - SPIA Transmit Interrupt\n//\ninterrupt void SPIA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.3 - SPIB Receive Interrupt\n//\ninterrupt void SPIB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.4 - SPIB Transmit Interrupt\n//\ninterrupt void SPIB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.5 - McBSPA Receive Interrupt\n//\ninterrupt void MCBSPA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.6 - McBSPA Transmit Interrupt\n//\ninterrupt void MCBSPA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.7 - McBSPB Receive Interrupt\n//\ninterrupt void MCBSPB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.8 - McBSPB Transmit Interrupt\n//\ninterrupt void MCBSPB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.1 - DMA Channel 1 Interrupt\n//\ninterrupt void DMA_CH1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.2 - DMA Channel 2 Interrupt\n//\ninterrupt void DMA_CH2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.3 - DMA Channel 3 Interrupt\n//\ninterrupt void DMA_CH3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.4 - DMA Channel 4 Interrupt\n//\ninterrupt void DMA_CH4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.5 - DMA Channel 5 Interrupt\n//\ninterrupt void DMA_CH5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.6 - DMA Channel 6 Interrupt\n//\ninterrupt void DMA_CH6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.1 - I2CA Interrupt 1\n//\ninterrupt void I2CA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.2 - I2CA Interrupt 2\n//\ninterrupt void I2CA_FIFO_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.3 - I2CB Interrupt 1\n//\ninterrupt void I2CB_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.4 - I2CB Interrupt 2\n//\ninterrupt void I2CB_FIFO_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.5 - SCIC Receive Interrupt\n//\ninterrupt void SCIC_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.6 - SCIC Transmit Interrupt\n//\ninterrupt void SCIC_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.7 - SCID Receive Interrupt\n//\ninterrupt void SCID_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.8 - SCID Transmit Interrupt\n//\ninterrupt void SCID_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.1 - SCIA Receive Interrupt\n//\ninterrupt void SCIA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.2 - SCIA Transmit Interrupt\n//\ninterrupt void SCIA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.3 - SCIB Receive Interrupt\n//\ninterrupt void SCIB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.4 - SCIB Transmit Interrupt\n//\ninterrupt void SCIB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.5 - CANA Interrupt 0\n//\ninterrupt void CANA0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.6 - CANA Interrupt 1\n//\ninterrupt void CANA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.7 - CANB Interrupt 0\n//\ninterrupt void CANB0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.8 - CANB Interrupt 1\n//\ninterrupt void CANB1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.1 - ADCA Event Interrupt\n//\ninterrupt void ADCA_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.2 - ADCA Interrupt 2\n//\ninterrupt void ADCA2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.3 - ADCA Interrupt 3\n//\ninterrupt void ADCA3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.4 - ADCA Interrupt 4\n//\ninterrupt void ADCA4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.5 - ADCB Event Interrupt\n//\ninterrupt void ADCB_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.6 - ADCB Interrupt 2\n//\ninterrupt void ADCB2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.7 - ADCB Interrupt 3\n//\ninterrupt void ADCB3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.8 - ADCB Interrupt 4\n//\ninterrupt void ADCB4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.1 - CLA1 Interrupt 1\n//\ninterrupt void CLA1_1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.2 - CLA1 Interrupt 2\n//\ninterrupt void CLA1_2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.3 - CLA1 Interrupt 3\n//\ninterrupt void CLA1_3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.4 - CLA1 Interrupt 4\n//\ninterrupt void CLA1_4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.5 - CLA1 Interrupt 5\n//\ninterrupt void CLA1_5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.6 - CLA1 Interrupt 6\n//\ninterrupt void CLA1_6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.7 - CLA1 Interrupt 7\n//\ninterrupt void CLA1_7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.8 - CLA1 Interrupt 8\n//\ninterrupt void CLA1_8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.1 - XINT3 Interrupt\n//\ninterrupt void XINT3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.2 - XINT4 Interrupt\n//\ninterrupt void XINT4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.3 - XINT5 Interrupt\n//\ninterrupt void XINT5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.6 - VCU Interrupt\n//\ninterrupt void VCU_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.7 - FPU Overflow Interrupt\n//\ninterrupt void FPU_OVERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.8 - FPU Underflow Interrupt\n//\ninterrupt void FPU_UNDERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.13 - IPC Interrupt 0\n//\ninterrupt void IPC0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.14 - IPC Interrupt 1\n//\ninterrupt void IPC1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.15 - IPC Interrupt 2\n//\ninterrupt void IPC2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.16 - IPC Interrupt 3\n//\ninterrupt void IPC3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.9 - ePWM9 Trip Zone Interrupt\n//\ninterrupt void EPWM9_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.10 - ePWM10 Trip Zone Interrupt\n//\ninterrupt void EPWM10_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.11 - ePWM11 Trip Zone Interrupt\n//\ninterrupt void EPWM11_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.12 - ePWM12 Trip Zone Interrupt\n//\ninterrupt void EPWM12_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.9 - ePWM9 Interrupt\n//\ninterrupt void EPWM9_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.10 - ePWM10 Interrupt\n//\ninterrupt void EPWM10_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.11 - ePWM11 Interrupt\n//\ninterrupt void EPWM11_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.12 - ePWM12 Interrupt\n//\ninterrupt void EPWM12_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.9 - SD1 Interrupt\n//\ninterrupt void SD1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.10 - SD2 Interrupt\n//\ninterrupt void SD2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.9 - SPIC Receive Interrupt\n//\ninterrupt void SPIC_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.10 - SPIC Transmit Interrupt\n//\ninterrupt void SPIC_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.15 - uPPA Interrupt\n//\ninterrupt void UPPA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.15 - USBA Interrupt\n//\ninterrupt void USBA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.9 - ADCC Event Interrupt\n//\ninterrupt void ADCC_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.10 - ADCC Interrupt 2\n//\ninterrupt void ADCC2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.11 - ADCC Interrupt 3\n//\ninterrupt void ADCC3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.12 - ADCC Interrupt 4\n//\ninterrupt void ADCC4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.13 - ADCD Event Interrupt\n//\ninterrupt void ADCD_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.14 - ADCD Interrupt 2\n//\ninterrupt void ADCD2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.15 - ADCD Interrupt 3\n//\ninterrupt void ADCD3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.16 - ADCD Interrupt 4\n//\ninterrupt void ADCD4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.9 - EMIF Error Interrupt\n//\ninterrupt void EMIF_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.10 - RAM Correctable Error Interrupt\n//\ninterrupt void RAM_CORRECTABLE_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.11 - Flash Correctable Error Interrupt\n//\ninterrupt void FLASH_CORRECTABLE_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.12 - RAM Access Violation Interrupt\n//\ninterrupt void RAM_ACCESS_VIOLATION_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.13 - System PLL Slip Interrupt\n//\ninterrupt void SYS_PLL_SLIP_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.14 - Auxiliary PLL Slip Interrupt\n//\ninterrupt void AUX_PLL_SLIP_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.15 - CLA Overflow Interrupt\n//\ninterrupt void CLA_OVERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.16 - CLA Underflow Interrupt\n//\ninterrupt void CLA_UNDERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Catch-all Default ISRs:\n//\n\n//\n// PIE_RESERVED_ISR - Reserved ISR\n//\ninterrupt void PIE_RESERVED_ISR(void)\n{\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// EMPTY_ISR - Only does a return\n//\ninterrupt void EMPTY_ISR(void)\n{\n\n}\n\n//\n// NOTUSED_ISR - Unused ISR\n//\ninterrupt void NOTUSED_ISR(void)\n{\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n"},{"name":"F2837xD_Dma.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_DMA.c\n//\n// TITLE:   F2837xD Device DMA Initialization & Support Functions.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// DMAInitialize - This function initializes the DMA to a known state.\n//\nvoid DMAInitialize(void)\n{\n    EALLOW;\n\n    //\n    // Perform a hard reset on DMA\n    //\n    DmaRegs.DMACTRL.bit.HARDRESET = 1;\n   __asm (\" nop\"); // one NOP required after HARDRESET\n\n    //\n    // Allow DMA to run free on emulation suspend\n    //\n    DmaRegs.DEBUGCTRL.bit.FREE = 1;\n\n    EDIS;\n}\n\n//\n// DMACH1AddrConfig - DMA Channel 1 Address Configuration\n//\nvoid DMACH1AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH1.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to\n                                                            // beginning of\n                                                            // source buffer\n    DmaRegs.CH1.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH1.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to\n                                                         // beginning of\n                                                         // destination buffer\n    DmaRegs.CH1.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH1BurstConfig - DMA Channel 1 Burst size configuration\n//\nvoid DMACH1BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH1.BURST_SIZE.all = bsize;      // Number of words(X-1)\n                                             // x-ferred in a burst.\n    DmaRegs.CH1.SRC_BURST_STEP = srcbstep;   // Increment source addr between\n                                             // each word x-ferred.\n    DmaRegs.CH1.DST_BURST_STEP = desbstep;   // Increment dest addr between\n                                             // each word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH1TransferConfig - DMA Channel 1 Transfer size configuration\n//\nvoid DMACH1TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH1.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH1.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored\n                                              // when WRAP occurs.\n    DmaRegs.CH1.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored\n                                              // when WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH1WrapConfig - DMA Channel 1 Wrap size configuration\n//\nvoid DMACH1WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH1.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH1.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH1.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH1.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH1ModeConfig - DMA Channel 1 Mode configuration\n//\nvoid DMACH1ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH1 = persel;\n    DmaRegs.CH1.MODE.bit.PERINTSEL = 1;\n    DmaRegs.CH1.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH1.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH1.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH1.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH1.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH1.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH1.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: interrupt and sync error flags\n    //\n    DmaRegs.CH1.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH1.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH1 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx1 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH1 - This function starts DMA Channel 1.\n//\nvoid StartDMACH1(void)\n{\n    EALLOW;\n    DmaRegs.CH1.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH2AddrConfig - DMA Channel 2 Address Configuration\n//\nvoid DMACH2AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH2.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to\n                                                            // beginning of\n                                                            // source buffer.\n    DmaRegs.CH2.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH2.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH2.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH2BurstConfig - DMA Channel 2 Burst size configuration\n//\nvoid DMACH2BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH2.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH2.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH2.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH2TransferConfig - DMA Channel 2 Transfer size Configuration\n//\nvoid DMACH2TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH2.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH2.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH2.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH2WrapConfig - DMA Channel 2 Wrap size configuration\n//\nvoid DMACH2WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH2.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH2.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH2.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH2.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH2ModeConfig - DMA Channel 2 Mode configuration\n//\nvoid DMACH2ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH2 = persel;\n    DmaRegs.CH2.MODE.bit.PERINTSEL = 2;\n    DmaRegs.CH2.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH2.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH2.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH2.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH2.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH2.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH2.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH2.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH2.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH2 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx2 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH2 - This function starts DMA Channel 2.\n//\nvoid StartDMACH2(void)\n{\n    EALLOW;\n    DmaRegs.CH2.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH3AddrConfig - DMA Channel 3 Address configuration\n//\nvoid DMACH3AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH3.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer.\n    DmaRegs.CH3.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH3.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest; // Point to beginning\n                                                        // of destination\n                                                        // buffer.\n    DmaRegs.CH3.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH3BurstConfig - DMA Channel 3 burst size configuration\n//\nvoid DMACH3BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH3.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH3.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH3.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH3TransferConfig - DMA channel 3 transfer size configuration\n//\nvoid DMACH3TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH3.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH3.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH3.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH3WrapConfig - DMA Channel 3 wrap size configuration\n//\nvoid DMACH3WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH3.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH3.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH3.DST_WRAP_SIZE = deswsize; // Wrap destination address after N\n                                          // bursts.\n    DmaRegs.CH3.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH3ModeConfig - DMA Channel 3 mode configuration\n//\nvoid DMACH3ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH3 = persel;\n    DmaRegs.CH3.MODE.bit.PERINTSEL = 3;\n    DmaRegs.CH3.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH3.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH3.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH3.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH3.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH3.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH3.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: interrupt flags and sync error flags\n    //\n    DmaRegs.CH3.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH3.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH3 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx3 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH3 - This function starts DMA Channel 3.\n//\nvoid StartDMACH3(void)\n{\n    EALLOW;\n    DmaRegs.CH3.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH4AddrConfig - DMA Channel 4 address configuration\n//\nvoid DMACH4AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH4.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer.\n    DmaRegs.CH4.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH4.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer.\n    DmaRegs.CH4.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH4BurstConfig - DMA Channel 4 burst size configuration\n//\nvoid DMACH4BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH4.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH4.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH4.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH4TransferConfig - DMA channel 4 transfer size configuration\n//\nvoid DMACH4TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH4.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH4.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH4.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH4WrapConfig - DMA channel 4 wrap size configuration\n//\nvoid DMACH4WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH4.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH4.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH4.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH4.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH4ModeConfig - DMA Channel 4 mode configuration\n//\nvoid DMACH4ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH4 = persel;\n    DmaRegs.CH4.MODE.bit.PERINTSEL = 4;\n    DmaRegs.CH4.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH4.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH4.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH4.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH4.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH4.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH4.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH4.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH4.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH4 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx4 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH4 - This function starts DMA Channel 4.\n//\nvoid StartDMACH4(void)\n{\n    EALLOW;\n    DmaRegs.CH4.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH5AddrConfig - DMA channel 5 address configuration\n//\nvoid DMACH5AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH5.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH5.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH5.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH5.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH5BurstConfig - DMA Channel 5 burst size configuration\n//\nvoid DMACH5BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH5.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH5.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH5.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH5TransferConfig - DMA channel 5 transfer size configuration\n//\nvoid DMACH5TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH5.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH5.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH5.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH5WrapConfig - DMA Channel 5 wrap size configuration\n//\nvoid DMACH5WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH5.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH5.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH5.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH5.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH5ModeConfig - DMA Channel 5 mode configuration\n//\nvoid DMACH5ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL2.bit.CH5 = persel;\n    DmaRegs.CH5.MODE.bit.PERINTSEL = 5;\n    DmaRegs.CH5.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH5.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH5.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH5.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH5.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH5.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH5.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH5.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH5.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH5 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx5 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH5 - This function starts DMA Channel 5.\n//\nvoid StartDMACH5(void)\n{\n    EALLOW;\n    DmaRegs.CH5.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH6AddrConfig - DMA Channel 6 address configuration\n//\nvoid DMACH6AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH6.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer.\n    DmaRegs.CH6.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH6.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH6.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH6BurstConfig - DMA Channel 6 burst size configuration\n//\nvoid DMACH6BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH6.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH6.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH6.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH6TransferConfig - DMA channel 6 transfer size configuration\n//\nvoid DMACH6TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH6.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH6.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH6.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH6WrapConfig - DMA Channel 6 wrap size configuration\n//\nvoid DMACH6WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH6.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH6.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH6.DST_WRAP_SIZE = deswsize; // Wrap destination address after N\n                                          // bursts.\n    DmaRegs.CH6.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH6ModeConfig - DMA Channel 6 mode configuration\n//\nvoid DMACH6ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL2.bit.CH6 = persel;\n    DmaRegs.CH6.MODE.bit.PERINTSEL = 6;\n    DmaRegs.CH6.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH6.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH6.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH6.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH6.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH6.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH6.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH6.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH6.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH6 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx6 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH6 - This function starts DMA Channel 6.\n//\nvoid StartDMACH6(void)\n{\n    EALLOW;\n    DmaRegs.CH6.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// NOTE:\n// Following functions are required for EMIF as the address is out of\n// 22bit range\n//\n\n//\n// DMACH1AddrConfig32bit - DMA Channel 1 address configuration for 32bit\n//\nvoid DMACH1AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH1.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH1.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH1.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer\n    DmaRegs.CH1.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH2AddrConfig32bit - DMA Channel 2 address configuration for 32bit\n//\nvoid DMACH2AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH2.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH2.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH2.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer\n    DmaRegs.CH2.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH3AddrConfig32bit - DMA Channel 3 address configuration for 32bit\n//\nvoid DMACH3AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH3.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH3.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH3.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH3.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH4AddrConfig32bit - DMA Channel 4 address configuration for 32bit\n//\nvoid DMACH4AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH4.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH4.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH4.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer\n    DmaRegs.CH4.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH5AddrConfig32bit - DMA Channel 5 address configuration for 32bit\n//\nvoid DMACH5AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH5.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH5.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH5.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer\n    DmaRegs.CH5.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH6AddrConfig32bit - DMA Channel 6 address configuration for 32bit\n//\nvoid DMACH6AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH6.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH6.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH6.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer\n    DmaRegs.CH6.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_GlobalVariableDefs.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\headers\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_globalvariabledefs.c\n//\n// TITLE:   F2837xD Global Variables and Data Section Pragmas.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"F2837xD_device.h\"     // F2837xD Headerfile Include File\n\n//---------------------------------------------------------------------------\n// Define Global Peripheral Variables:\n//\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AccessProtectionRegsFile\")\n#else\n#pragma DATA_SECTION(AccessProtectionRegs,\"AccessProtectionRegsFile\");\n#endif\nvolatile struct ACCESS_PROTECTION_REGS AccessProtectionRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcaRegsFile\")\n#else\n#pragma DATA_SECTION(AdcaRegs,\"AdcaRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcbRegsFile\")\n#else\n#pragma DATA_SECTION(AdcbRegs,\"AdcbRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdccRegsFile\")\n#else\n#pragma DATA_SECTION(AdccRegs,\"AdccRegsFile\");\n#endif\nvolatile struct ADC_REGS AdccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcdRegsFile\")\n#else\n#pragma DATA_SECTION(AdcdRegs,\"AdcdRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcdRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcaResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcaResultRegs,\"AdcaResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcaResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcbResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcbResultRegs,\"AdcbResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcbResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdccResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdccResultRegs,\"AdccResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdccResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcdResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcdResultRegs,\"AdcdResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcdResultRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AnalogSubsysRegsFile\")\n#else\n#pragma DATA_SECTION(AnalogSubsysRegs,\"AnalogSubsysRegsFile\");\n#endif\nvolatile struct ANALOG_SUBSYS_REGS AnalogSubsysRegs;\n#endif // ifdef CPU1\n\n#if __TI_COMPILER_VERSION__ >= 16006000\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CanaRegsFile\")\n#else\n#pragma DATA_SECTION(CanaRegs,\"CanaRegsFile\");\n#endif\nvolatile struct CAN_REGS CanaRegs;\n#endif // __TI_COMPILER_VERSION__ >= 16006000\n\n#if __TI_COMPILER_VERSION__ >= 16006000\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CanbRegsFile\")\n#else\n#pragma DATA_SECTION(CanbRegs,\"CanbRegsFile\");\n#endif\nvolatile struct CAN_REGS CanbRegs;\n#endif // __TI_COMPILER_VERSION__ >= 16006000\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cla1RegsFile\")\n#else\n#pragma DATA_SECTION(Cla1Regs,\"Cla1RegsFile\");\n#endif\nvolatile struct CLA_REGS Cla1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1DataExchRegs,\"Clb1DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb1DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2DataExchRegs,\"Clb2DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb2DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3DataExchRegs,\"Clb3DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb3DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4DataExchRegs,\"Clb4DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb4DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1LogicCfgRegs,\"Clb1LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb1LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2LogicCfgRegs,\"Clb2LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb2LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3LogicCfgRegs,\"Clb3LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb3LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4LogicCfgRegs,\"Clb4LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb4LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1LogicCtrlRegs,\"Clb1LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb1LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2LogicCtrlRegs,\"Clb2LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb2LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3LogicCtrlRegs,\"Clb3LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb3LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4LogicCtrlRegs,\"Clb4LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb4LogicCtrlRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ClbXbarRegsFile\")\n#else\n#pragma DATA_SECTION(ClbXbarRegs,\"ClbXbarRegsFile\");\n#endif\nvolatile struct CLB_XBAR_REGS ClbXbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ClkCfgRegsFile\")\n#else\n#pragma DATA_SECTION(ClkCfgRegs,\"ClkCfgRegsFile\");\n#endif\nvolatile struct CLK_CFG_REGS ClkCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss1RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss1Regs,\"Cmpss1RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss2RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss2Regs,\"Cmpss2RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss3RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss3Regs,\"Cmpss3RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss4RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss4Regs,\"Cmpss4RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss5RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss5Regs,\"Cmpss5RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss6RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss6Regs,\"Cmpss6RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss7RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss7Regs,\"Cmpss7RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss8RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss8Regs,\"Cmpss8RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss8Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer0RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer0Regs,\"CpuTimer0RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer0Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer1RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer1Regs,\"CpuTimer1RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer2RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer2Regs,\"CpuTimer2RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuSysRegsFile\")\n#else\n#pragma DATA_SECTION(CpuSysRegs,\"CpuSysRegsFile\");\n#endif\nvolatile struct CPU_SYS_REGS CpuSysRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DacaRegsFile\")\n#else\n#pragma DATA_SECTION(DacaRegs,\"DacaRegsFile\");\n#endif\nvolatile struct DAC_REGS DacaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DacbRegsFile\")\n#else\n#pragma DATA_SECTION(DacbRegs,\"DacbRegsFile\");\n#endif\nvolatile struct DAC_REGS DacbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DaccRegsFile\")\n#else\n#pragma DATA_SECTION(DaccRegs,\"DaccRegsFile\");\n#endif\nvolatile struct DAC_REGS DaccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmCommonRegsFile\")\n#else\n#pragma DATA_SECTION(DcsmCommonRegs,\"DcsmCommonRegsFile\");\n#endif\nvolatile struct DCSM_COMMON_REGS DcsmCommonRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmZ1RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmZ1Regs,\"DcsmZ1RegsFile\");\n#endif\nvolatile struct DCSM_Z1_REGS DcsmZ1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmZ2RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmZ2Regs,\"DcsmZ2RegsFile\");\n#endif\nvolatile struct DCSM_Z2_REGS DcsmZ2Regs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DevCfgRegsFile\")\n#else\n#pragma DATA_SECTION(DevCfgRegs,\"DevCfgRegsFile\");\n#endif\nvolatile struct DEV_CFG_REGS DevCfgRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaClaSrcSelRegsFile\")\n#else\n#pragma DATA_SECTION(DmaClaSrcSelRegs,\"DmaClaSrcSelRegsFile\");\n#endif\nvolatile struct DMA_CLA_SRC_SEL_REGS DmaClaSrcSelRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaRegsFile\")\n#else\n#pragma DATA_SECTION(DmaRegs,\"DmaRegsFile\");\n#endif\nvolatile struct DMA_REGS DmaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap1RegsFile\")\n#else\n#pragma DATA_SECTION(ECap1Regs,\"ECap1RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap2RegsFile\")\n#else\n#pragma DATA_SECTION(ECap2Regs,\"ECap2RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap3RegsFile\")\n#else\n#pragma DATA_SECTION(ECap3Regs,\"ECap3RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap4RegsFile\")\n#else\n#pragma DATA_SECTION(ECap4Regs,\"ECap4RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap5RegsFile\")\n#else\n#pragma DATA_SECTION(ECap5Regs,\"ECap5RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap6RegsFile\")\n#else\n#pragma DATA_SECTION(ECap6Regs,\"ECap6RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif1ConfigRegsFile\")\n#else\n#pragma DATA_SECTION(Emif1ConfigRegs,\"Emif1ConfigRegsFile\");\n#endif\nvolatile struct EMIF1_CONFIG_REGS Emif1ConfigRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif2ConfigRegsFile\")\n#else\n#pragma DATA_SECTION(Emif2ConfigRegs,\"Emif2ConfigRegsFile\");\n#endif\nvolatile struct EMIF2_CONFIG_REGS Emif2ConfigRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif1RegsFile\")\n#else\n#pragma DATA_SECTION(Emif1Regs,\"Emif1RegsFile\");\n#endif\nvolatile struct EMIF_REGS Emif1Regs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif2RegsFile\")\n#else\n#pragma DATA_SECTION(Emif2Regs,\"Emif2RegsFile\");\n#endif\nvolatile struct EMIF_REGS Emif2Regs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm1RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm1Regs,\"EPwm1RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm2RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm2Regs,\"EPwm2RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm3RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm3Regs,\"EPwm3RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm4RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm4Regs,\"EPwm4RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm5RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm5Regs,\"EPwm5RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm6RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm6Regs,\"EPwm6RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm7RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm7Regs,\"EPwm7RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm8RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm8Regs,\"EPwm8RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm8Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm9RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm9Regs,\"EPwm9RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm9Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm10RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm10Regs,\"EPwm10RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm10Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm11RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm11Regs,\"EPwm11RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm11Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm12RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm12Regs,\"EPwm12RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm12Regs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwmXbarRegsFile\")\n#else\n#pragma DATA_SECTION(EPwmXbarRegs,\"EPwmXbarRegsFile\");\n#endif\nvolatile struct EPWM_XBAR_REGS EPwmXbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep1RegsFile\")\n#else\n#pragma DATA_SECTION(EQep1Regs,\"EQep1RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep2RegsFile\")\n#else\n#pragma DATA_SECTION(EQep2Regs,\"EQep2RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep3RegsFile\")\n#else\n#pragma DATA_SECTION(EQep3Regs,\"EQep3RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Flash0CtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Flash0CtrlRegs,\"Flash0CtrlRegsFile\");\n#endif\nvolatile struct FLASH_CTRL_REGS Flash0CtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Flash0EccRegsFile\")\n#else\n#pragma DATA_SECTION(Flash0EccRegs,\"Flash0EccRegsFile\");\n#endif\nvolatile struct FLASH_ECC_REGS Flash0EccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"FlashPumpSemaphoreRegsFile\")\n#else\n#pragma DATA_SECTION(FlashPumpSemaphoreRegs,\"FlashPumpSemaphoreRegsFile\");\n#endif\nvolatile struct FLASH_PUMP_SEMAPHORE_REGS FlashPumpSemaphoreRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(GpioCtrlRegs,\"GpioCtrlRegsFile\");\n#endif\nvolatile struct GPIO_CTRL_REGS GpioCtrlRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioDataRegsFile\")\n#else\n#pragma DATA_SECTION(GpioDataRegs,\"GpioDataRegsFile\");\n#endif\nvolatile struct GPIO_DATA_REGS GpioDataRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"I2caRegsFile\")\n#else\n#pragma DATA_SECTION(I2caRegs,\"I2caRegsFile\");\n#endif\nvolatile struct I2C_REGS I2caRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"I2cbRegsFile\")\n#else\n#pragma DATA_SECTION(I2cbRegs,\"I2cbRegsFile\");\n#endif\nvolatile struct I2C_REGS I2cbRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"InputXbarRegsFile\")\n#else\n#pragma DATA_SECTION(InputXbarRegs,\"InputXbarRegsFile\");\n#endif\nvolatile struct INPUT_XBAR_REGS InputXbarRegs;\n#endif // ifdef CPU1\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"IpcRegsFile\")\n#else\n#pragma DATA_SECTION(IpcRegs,\"IpcRegsFile\");\n#endif\nvolatile struct IPC_REGS_CPU1 IpcRegs;\n#endif // ifdef CPU1\n\n#ifdef CPU2\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"IpcRegsFile\")\n#else\n#pragma DATA_SECTION(IpcRegs,\"IpcRegsFile\");\n#endif\nvolatile struct IPC_REGS_CPU2 IpcRegs;\n#endif // ifdef CPU2\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"MemoryErrorRegsFile\")\n#else\n#pragma DATA_SECTION(MemoryErrorRegs,\"MemoryErrorRegsFile\");\n#endif\nvolatile struct MEMORY_ERROR_REGS MemoryErrorRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"MemCfgRegsFile\")\n#else\n#pragma DATA_SECTION(MemCfgRegs,\"MemCfgRegsFile\");\n#endif\nvolatile struct MEM_CFG_REGS MemCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"McbspaRegsFile\")\n#else\n#pragma DATA_SECTION(McbspaRegs,\"McbspaRegsFile\");\n#endif\nvolatile struct McBSP_REGS McbspaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"McbspbRegsFile\")\n#else\n#pragma DATA_SECTION(McbspbRegs,\"McbspbRegsFile\");\n#endif\nvolatile struct McBSP_REGS McbspbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"NmiIntruptRegsFile\")\n#else\n#pragma DATA_SECTION(NmiIntruptRegs,\"NmiIntruptRegsFile\");\n#endif\nvolatile struct NMI_INTRUPT_REGS NmiIntruptRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"OutputXbarRegsFile\")\n#else\n#pragma DATA_SECTION(OutputXbarRegs,\"OutputXbarRegsFile\");\n#endif\nvolatile struct OUTPUT_XBAR_REGS OutputXbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(PieCtrlRegs,\"PieCtrlRegsFile\");\n#endif\nvolatile struct PIE_CTRL_REGS PieCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieVectTableFile\")\n#else\n#pragma DATA_SECTION(PieVectTable,\"PieVectTableFile\");\n#endif\nvolatile struct PIE_VECT_TABLE PieVectTable;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"RomPrefetchRegsFile\")\n#else\n#pragma DATA_SECTION(RomPrefetchRegs,\"RomPrefetchRegsFile\");\n#endif\nvolatile struct ROM_PREFETCH_REGS RomPrefetchRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"RomWaitStateRegsFile\")\n#else\n#pragma DATA_SECTION(RomWaitStateRegs,\"RomWaitStateRegsFile\");\n#endif\nvolatile struct ROM_WAIT_STATE_REGS RomWaitStateRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SciaRegsFile\")\n#else\n#pragma DATA_SECTION(SciaRegs,\"SciaRegsFile\");\n#endif\nvolatile struct SCI_REGS SciaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScibRegsFile\")\n#else\n#pragma DATA_SECTION(ScibRegs,\"ScibRegsFile\");\n#endif\nvolatile struct SCI_REGS ScibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScicRegsFile\")\n#else\n#pragma DATA_SECTION(ScicRegs,\"ScicRegsFile\");\n#endif\nvolatile struct SCI_REGS ScicRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScidRegsFile\")\n#else\n#pragma DATA_SECTION(ScidRegs,\"ScidRegsFile\");\n#endif\nvolatile struct SCI_REGS ScidRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Sdfm1RegsFile\")\n#else\n#pragma DATA_SECTION(Sdfm1Regs,\"Sdfm1RegsFile\");\n#endif\nvolatile struct SDFM_REGS Sdfm1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Sdfm2RegsFile\")\n#else\n#pragma DATA_SECTION(Sdfm2Regs,\"Sdfm2RegsFile\");\n#endif\nvolatile struct SDFM_REGS Sdfm2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpiaRegsFile\")\n#else\n#pragma DATA_SECTION(SpiaRegs,\"SpiaRegsFile\");\n#endif\nvolatile struct SPI_REGS SpiaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpibRegsFile\")\n#else\n#pragma DATA_SECTION(SpibRegs,\"SpibRegsFile\");\n#endif\nvolatile struct SPI_REGS SpibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpicRegsFile\")\n#else\n#pragma DATA_SECTION(SpicRegs,\"SpicRegsFile\");\n#endif\nvolatile struct SPI_REGS SpicRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SyncSocRegsFile\")\n#else\n#pragma DATA_SECTION(SyncSocRegs,\"SyncSocRegsFile\");\n#endif\nvolatile struct SYNC_SOC_REGS SyncSocRegs;\n#endif // ifdef CPU1\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"UppRegsFile\")\n#else\n#pragma DATA_SECTION(UppRegs,\"UppRegsFile\");\n#endif\nvolatile struct UPP_REGS UppRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"WdRegsFile\")\n#else\n#pragma DATA_SECTION(WdRegs,\"WdRegsFile\");\n#endif\nvolatile struct WD_REGS WdRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XbarRegsFile\")\n#else\n#pragma DATA_SECTION(XbarRegs,\"XbarRegsFile\");\n#endif\nvolatile struct XBAR_REGS XbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XintRegsFile\")\n#else\n#pragma DATA_SECTION(XintRegs,\"XintRegsFile\");\n#endif\nvolatile struct XINT_REGS XintRegs;\n\n\n\n//===========================================================================\n// End of file.\n//===========================================================================\n\n\n"},{"name":"F2837xD_Gpio.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_Gpio.c\n//\n// TITLE:    GPIO module support functions\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n//Low-level functions for GPIO configuration (CPU1 only)\n//\n\n#ifdef CPU1\n    //\n    // InitGpio - Sets all pins to be muxed to GPIO in input mode.\n    //            Also resets CPU control to CPU1 and disables open\n    //            drain and polarity inversion and sets the qualification to\n    //            synchronous. Also unlocks all GPIOs. Only one CPU should call\n    //            this function.\n    //\n    void InitGpio()\n    {\n        volatile Uint32 *gpioBaseAddr;\n        Uint16 regOffset;\n\n        //\n        //Disable pin locks\n        //\n        EALLOW;\n        GpioCtrlRegs.GPALOCK.all = 0x00000000;\n        GpioCtrlRegs.GPBLOCK.all = 0x00000000;\n        GpioCtrlRegs.GPCLOCK.all = 0x00000000;\n        GpioCtrlRegs.GPDLOCK.all = 0x00000000;\n        GpioCtrlRegs.GPELOCK.all = 0x00000000;\n        GpioCtrlRegs.GPFLOCK.all = 0x00000000;\n\n        //\n        // Fill all registers with zeros. Writing to each register separately\n        // for six GPIO modules would make this function *very* long.\n        // Fortunately, we'd be writing them all with zeros anyway, so this\n        // saves a lot of space.\n        //\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n        {\n            //\n            //Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n            //0x0C in each register group of 0x40 words. Since this is a\n            //32-bit pointer, the addresses must be divided by 2.\n            //\n            if (regOffset % (0x40/2) != (0x0C/2))\n            {\n                gpioBaseAddr[regOffset] = 0x00000000;\n            }\n        }\n\n        gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n        for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n        {\n            gpioBaseAddr[regOffset] = 0x00000000;\n        }\n\n        EDIS;\n    }\n\n    //\n    // GPIO_SetupPinMux - Set the peripheral muxing for the specified pin. The\n    //                    appropriate parameters can be found in the GPIO Muxed\n    //                    Pins table(4.4) in the  datasheet. Use the GPIO index\n    //                    row (0 to 15) to select a muxing option for the GPIO.\n    //\n    void GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n    {\n        volatile Uint32 *gpioBaseAddr;\n        volatile Uint32 *mux, *gmux, *csel;\n        Uint16 pin32, pin16, pin8;\n\n        pin32 = gpioNumber % 32;\n        pin16 = gpioNumber % 16;\n        pin8 = gpioNumber % 8;\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n        //\n        //Sanity check for valid cpu and peripheral values\n        //\n        if (cpu > GPIO_MUX_CPU2CLA || muxPosition > 0xF)\n            return;\n\n        //\n        //Create pointers to the appropriate registers. This is a workaround\n        //for the way GPIO registers are defined. The standard definition\n        //in the header file makes it very easy to do named accesses of one\n        //register or bit, but hard to do arbitrary numerical accesses. It's\n        //easier to have an array of GPIO modules with identical registers,\n        //including arrays for multi-register groups like GPyCSEL1-4. But\n        //the header file doesn't define anything we can turn into an array,\n        //so manual pointer arithmetic is used instead.\n        //\n        mux = gpioBaseAddr + GPYMUX + pin32/16;\n        gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n        csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n        //\n        //Now for the actual function\n        //\n        EALLOW;\n\n        //\n        //To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n        //glitches, then change the group mux, then set the peripheral mux to\n        //its target value. Finally, set the CPU select. This procedure is\n        //described in the TRM. Unfortunately, since we don't know the pin in\n        //advance we can't hardcode a bitfield reference, so there's some\n        //tricky bit twiddling here.\n        //\n        *mux &= ~(0x3UL << (2*pin16));\n        *gmux &= ~(0x3UL << (2*pin16));\n        *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n        *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n        *csel &= ~(0x3L << (4*pin8));\n        *csel |= (Uint32)(cpu & 0x3L) << (4*pin8);\n\n        //\n        //WARNING: This code does not touch the analog mode select registers,\n        //which are needed to give the USB module control of its IOs.\n        //\n        EDIS;\n    }\n\n    //\n    // GPIO_SetupPinOptions - Setup up the GPIO input/output options for the\n    //                        specified pin.\n    //\n    //The flags are a 16-bit mask produced by ORing together options.\n    //For input pins, the valid flags are:\n    //GPIO_PULLUP    Enable pull-up\n    //GPIO_INVERT    Enable input polarity inversion\n    //GPIO_SYNC        Synchronize the input latch to PLLSYSCLK\n    //               (default -- you don't need to specify this)\n    //GPIO_QUAL3    Use 3-sample qualification\n    //GPIO_QUAL6    Use 6-sample qualification\n    //GPIO_ASYNC    Do not use synchronization or qualification\n    //(Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n    //\n    //For output pins, the valid flags are:\n    //GPIO_OPENDRAIN    Output in open drain mode\n    //GPIO_PULLUP        If open drain enabled, also enable the pull-up\n    //and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n    //\n    //With no flags, the default input state is synchronous with no\n    //pull-up or polarity inversion. The default output state is\n    //the standard digital output.\n    //\n    void GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n    {\n        volatile Uint32 *gpioBaseAddr;\n        volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n        Uint32 pin32, pin16, pinMask, qual;\n\n        pin32 = gpioNumber % 32;\n        pin16 = gpioNumber % 16;\n        pinMask = 1UL << pin32;\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n        //\n        //Create pointers to the appropriate registers. This is a workaround\n        //for the way GPIO registers are defined. The standard definition\n        //in the header file makes it very easy to do named accesses of one\n        //register or bit, but hard to do arbitrary numerical accesses. It's\n        //easier to have an array of GPIO modules with identical registers,\n        //including arrays for multi-register groups like GPyQSEL1-2. But\n        //the header file doesn't define anything we can turn into an array,\n        //so manual pointer arithmetic is used instead.\n        //\n        dir = gpioBaseAddr + GPYDIR;\n        pud = gpioBaseAddr + GPYPUD;\n        inv = gpioBaseAddr + GPYINV;\n        odr = gpioBaseAddr + GPYODR;\n        qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n        EALLOW;\n\n        //\n        //Set the data direction\n        //\n        *dir &= ~pinMask;\n        if (output == 1)\n        {\n            //\n            //Output, with optional open drain mode and pull-up\n            //\n            *dir |= pinMask;\n\n            //\n            //Enable open drain if necessary\n            //\n            if (flags & GPIO_OPENDRAIN)\n            {\n                *odr |= pinMask;\n            }\n            else\n            {\n                *odr &= ~pinMask;\n            }\n\n            //\n            //Enable pull-up if necessary. Open drain mode must be active.\n            //\n            if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n            {\n                *pud &= ~pinMask;\n            }\n            else\n            {\n                *pud |= pinMask;\n            }\n        }\n        else\n        {\n            //\n            //Input, with optional pull-up, qualification, and polarity\n            //inversion\n            //\n            *dir &= ~pinMask;\n\n            //\n            //Enable pull-up if necessary\n            //\n            if (flags & GPIO_PULLUP)\n            {\n                *pud &= ~pinMask;\n            }\n            else\n            {\n                *pud |= pinMask;\n            }\n\n            //\n            //Invert polarity if necessary\n            //\n            if (flags & GPIO_INVERT)\n            {\n                *inv |= pinMask;\n            }\n            else\n            {\n                *inv &= ~pinMask;\n            }\n        }\n\n        //\n        //Extract the qualification parameter and load it into the register.\n        //This is also needed for open drain outputs, so we might as well do it\n        //all the time.\n        //\n        qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n        *qsel &= ~(0x3L << (2 * pin16));\n        if (qual != 0x0)\n        {\n            *qsel |= qual << (2 * pin16);\n        }\n\n        EDIS;\n    }\n\n    //\n    // GPIO_SetupLock - Enable or disable the GPIO register bit lock for the\n    //                  specified pin.\n    //                  The valid flags are:\n    //                  GPIO_UNLOCK - Unlock the pin setup register bits for\n    //                                the specified pin\n    //                  GPIO_LOCK - Lock the pin setup register bits for the\n    //                              specified pin\n    //\n    void GPIO_SetupLock(Uint16 gpioNumber, Uint16 flags)\n    {\n        volatile Uint32 *gpioBaseAddr;\n        volatile Uint32 *lock;\n        Uint32 pin32, pinMask;\n\n        pin32 = gpioNumber % 32;\n        pinMask = 1UL << pin32;\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n        //\n        //Create pointers to the appropriate registers. This is a workaround\n        //for the way GPIO registers are defined. The standard definition\n        //in the header file makes it very easy to do named accesses of one\n        //register or bit, but hard to do arbitrary numerical accesses. It's\n        //easier to have an array of GPIO modules with identical registers,\n        //including arrays for multi-register groups like GPyQSEL1-2. But\n        //the header file doesn't define anything we can turn into an array,\n        //so manual pointer arithmetic is used instead.\n        //\n        lock = gpioBaseAddr + GPYLOCK;\n\n        EALLOW;\n        if(flags)\n        {\n            //Lock the pin\n            *lock |= pinMask;\n        }\n        else\n        {\n            //Unlock the pin\n            *lock &= ~pinMask;\n        }\n        EDIS;\n    }\n\n    //\n    //External interrupt setup\n    //\n    void GPIO_SetupXINT1Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT4SELECT = gpioNumber;      //Set XINT1 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT2Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT5SELECT = gpioNumber;      //Set XINT2 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT3Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT6SELECT = gpioNumber;      //Set XINT3 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT4Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT13SELECT = gpioNumber;     //Set XINT4 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT5Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT14SELECT = gpioNumber;     //Set XINT5 source to GPIO-pin\n        EDIS;\n    }\n\n    //\n    //GPIO_EnableUnbondedIOPullupsFor176Pin - Enable pullups for the unbonded\n    //                                        GPIOs on the 176PTP package:\n    //                                        GPIOs     Grp Bits\n    //                                        95-132    C   31\n    //                                                  D   31:0\n    //                                                  E   4:0\n    //                                        134-168   E   31:6\n    //                                                  F   8:0\n    //\n    void GPIO_EnableUnbondedIOPullupsFor176Pin()\n    {\n        EALLOW;\n        GpioCtrlRegs.GPCPUD.all = ~0x80000000;  //GPIO 95\n        GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  //GPIOs 96-127\n        GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDF;  //GPIOs 128-159 except for 133\n        GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  //GPIOs 160-168\n        EDIS;\n    }\n\n    //\n    // GPIO_EnableUnbondedIOPullupsFor100Pin - Enable pullups for the unbonded\n    //                                         GPIOs on the 100PZ package:\n    //                                         GPIOs     Grp Bits\n    //                                         0-1       A   1:0\n    //                                         5-9       A   9:5\n    //                                         22-40     A   31:22\n    //                                                   B   8:0\n    //                                         44-57     B   25:12\n    //                                         67-68     C   4:3\n    //                                         74-77     C   13:10\n    //                                         79-83     C   19:15\n    //                                         93-168    C   31:29\n    //                                                   D   31:0\n    //                                                   E   31:0\n    //                                                   F   8:0\n    //\n    void GPIO_EnableUnbondedIOPullupsFor100Pin()\n    {\n        EALLOW;\n        GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3;  //GPIOs 0-1, 5-9, 22-31\n        GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FF;  //GPIOs 32-40, 44-57\n        GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18;  //GPIOs 67-68, 74-77, 79-83, 93-95\n        GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  //GPIOs 96-127\n        GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFF;  //GPIOs 128-159\n        GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  //GPIOs 160-168\n        EDIS;\n    }\n\n    //\n    // GPIO_EnableUnbondedIOPullups - InitSysCtrl would call this function\n    //                                this takes care of enabling IO pullups.\n    //\n    void GPIO_EnableUnbondedIOPullups()\n    {\n        //\n        //bits 8-10 have pin count\n        //\n        unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700) >> 8) ;\n\n        //\n        //5 = 100 pin\n        //6 = 176 pin\n        //7 = 337 pin\n        //\n        if(pin_count == 5)\n        {\n            GPIO_EnableUnbondedIOPullupsFor100Pin();\n        }\n        else if (pin_count == 6)\n        {\n            GPIO_EnableUnbondedIOPullupsFor176Pin();\n        }\n        else\n        {\n            //do nothing - this is 337 pin package\n        }\n    }\n\n#endif //CPU1\n\n//\n// GPIO_ReadPin - Read the GPyDAT register bit for the specified pin. Note that\n//                this returns the actual state of the pin, not the state of\n//                the output latch.\n//\nUint16 GPIO_ReadPin(Uint16 gpioNumber)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (gpioNumber % 32)) & 0x1;\n\n    return pinVal;\n}\n\n//\n// GPIO_WritePin - Set the GPyDAT register bit for the specified pin.\n//\nvoid GPIO_WritePin(Uint16 gpioNumber, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (gpioNumber % 32);\n\n    if (outVal == 0)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_Ipc_Driver_Lite.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_Ipc_Driver_Lite.c\n//\n// TITLE:  F2837xD Inter-Processor Communication (IPC) Lite API Driver\n//         Functions.\n//\n// DESCRIPTION:\n//         API functions for inter-processor communications between\n//         CPU1 control system and CPU2 control system (Lite version). The IPC\n//         Lite functions only allow for basic functions such as data writes,\n//         reads, bit setting, and bit clearing.  The Lite functions do not\n//         require the usage of the MSG RAM's or shared memories and can only\n//         be used with a single IPC interrupt channel.  Commands can only\n//         be processed one at a time without queuing.\n//         The driver functions in this file are available only as\n//         sample functions for application development.  Due to the generic\n//         nature of these functions and the cycle overhead inherent to a\n//         function call, the code is not intended to be used in cases where\n//         maximum efficiency is required in a system.\n//\n// NOTE:   This source code is used by both CPUs. That is both CPU1 and CPU2\n//         cores use this code.\n//         The active debug CPU will be referred to as Local CPU and the other\n//         CPU will be referred to as Remote CPU.\n//         When using this source code in CPU1, the term \"local\"\n//         will mean CPU1 and the term \"remote\" CPU will be mean CPU2.\n//         When using this source code in CPU2, the term \"local\"\n//         will mean CPU2 and the term \"remote\" CPU will be mean CPU1.\n//\n//         The abbreviations LtoR and RtoL  within the function names mean\n//         Local to Remote and Remote to Local respectively.\n//\n//###########################################################################\n//\n// $Release Date: $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//*****************************************************************************\n//! \\addtogroup ipc_lite_api IPC-Lite API Drivers\n//! @{\n//*****************************************************************************\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Ipc_drivers.h\"\n\n//\n// Function Prototypes\n//\nvoid DelayLoop (void);\n\n//*****************************************************************************\n//\n//! Reads single word data result of Local to Remote IPC command\n//!\n//! \\param pvData is a pointer to the 16/32-bit variable where the result data\n//! will be stored.\n//! \\param usLength designates 16- or 32-bit read.\n//! \\param ulStatusFlag indicates the Local to Remote CPU Flag number mask used\n//!  to report the status of the command sent back from the Remote CPU. If\n//!  a status flag was not used with the command call, set this parameter to 0.\n//!\n//! Allows the caller to read the 16/32-bit data result of non-blocking IPC\n//! functions from the IPCREMOTEREPLY register if the status flag is cleared\n//! indicating the IPC command was successfully interpreted. If the status flag\n//! is not cleared, the command was not recognized, and the function will\n//! return STATUS_FAIL. To determine what data is read from a call to this\n//! function, see the descriptions of the non-blocking IPC functions.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The  \\e ulStatusFlag parameter\n//! accepts any of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//! The function returns \\b STATUS_PASS or \\b STATUS_FAIL.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRGetResult (void *pvData, uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // If Remote System never acknowledged Status Task, indicates command\n    // failure.\n    //\n    if (IpcRegs.IPCFLG.all & ulStatusFlag)\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Read data.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            *(uint16_t *)pvData = IpcRegs.IPCREMOTEREPLY;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            *(uint32_t *)pvData =  IpcRegs.IPCREMOTEREPLY;\n        }\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Reads either a 16- or 32-bit data word from the remote CPU System address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the remote address to read from\n//! \\param usLength designates 16- or 32-bit read (1 = 16-bit, 2 = 32-bit)\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//!  report the status of the command sent back from the remote system.\n//!\n//! This function will allow the Local CPU System to read 16/32-bit data from\n//! the Remote CPU System into the IPCREMOTEREPLY register. After calling this\n//! function, a call to \\e IPCLiteLtoRGetResult() will read the data value in\n//! the IPCREMOTEREPLY register into a 16- or 32-bit variable in the local CPU\n//! application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRDataRead(uint32_t ulFlag, uint32_t ulAddress, uint16_t usLength,\n                    uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up read command, address, and word length.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_READ_16;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_READ_32;\n        }\n        IpcRegs.IPCSENDADDR = ulAddress;\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit data word at the remote CPU system\n//! address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the Remote address to write to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be set at\n//!  remote ulAddress. For 16-bit mask, only the lower 16-bits of ulMask are\n//!  considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//!        report the status of the command sent back from the Remote system.\n//!\n//! This function will allow the Local CPU system to set bits specified by the\n//! \\e usMask variable in a 16/32-bit word on the Remote CPU system. The data\n//! word at /e ulAddress after the set bits command is then read into the\n//! IPCREMOTEREPLY register. After calling this function, a call to \\e\n//! IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local CPU application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRSetBits(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulMask,\n                   uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_16;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_32;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit write-protected data word at\n//! the Remote CPU system address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU write-protected address to write\n//!        to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be set at\n//!  Remote CPU ulAddress.For 16-bit mask, only the lower 16-bits of ulMask are\n//!  considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//!        report the status of the command sent back from the Master system.\n//!\n//! This function will allow the Local CPU system to set bits specified by the\n//! \\e usMask variable in a write-protected 16/32-bit word on the REmote CPU\n//! system.\n//! The data word at /e ulAddress after the set bits command is then read into\n//! the IPCREMOTEREPLY register. After calling this function, a call to\n//! \\e IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRSetBits_Protected (uint32_t ulFlag, uint32_t ulAddress,\n                              uint32_t ulMask, uint16_t usLength,\n                              uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_16_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_32_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit data word at the remote CPU system\n//! address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU address to write to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be set at\n//! the remote CPU ulAddress. (For 16-bit mask, only the lower 16-bits of\n//! ulMask are considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master system.\n//!\n//! This function will allow the Local CPU system to set bits specified by the\n//! \\e usMask variable in a 16/32-bit word on the Remote CPU system. The data\n//! word at /e ulAddress after the set bits command is then read into the\n//! IPCREMOTEREPLY register. After calling this function, a call to \\e\n//! IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local CPU application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRClearBits(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulMask,\n                     uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_16;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_32;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Clears the designated bits in a 16/32-bit write-protected data word at\n//! Remote CPU system address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU write-protected address to write\n//! to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be cleared\n//! at Remote CPU ulAddress.For 16-bit mask, only the lower 16-bits of ulMask\n//! are considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master system.\n//!\n//! This function will allow the Local CPU system to clear bits specified by\n//! the \\e usMask variable in a write-protected 16/32-bit word on the Remote\n//! CPU system.\n//! The data word at /e ulAddress after the clear bits command is then read\n//! into the IPCREMOTEREPLY register. After calling this function, a call to\n//! \\e IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local CPU application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRClearBits_Protected (uint32_t ulFlag, uint32_t ulAddress,\n                                uint32_t ulMask, uint16_t usLength,\n                                uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_16_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_32_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to Remote CPU System address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU address to write to\n//! \\param ulData specifies the 16/32-bit word which will be written.\n//! For 16-bit words, only the lower 16-bits of ulData will be considered by\n//! the master system.\n//! \\param usLength is the length of the word to write (0 = 16-bits, 1 =\n//! 32-bits)\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Remote CPU  system.\n//!\n//! This function will allow the Local CPU System to write a 16/32-bit word\n//! via the \\e ulData variable to an address on the Remote CPU System.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRDataWrite(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulData,\n                     uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up data write command, address, and data. For 16-bit write,\n        // Master system will look at lower 16-bits only.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_16;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_32;\n        }\n        IpcRegs.IPCSENDADDR = ulAddress;\n        IpcRegs.IPCSENDDATA = ulData;\n\n        //\n        // Force IPC event on selected request task and enable status-checking\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to a protected Remote CPU System address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU address to write to\n//! \\param ulData specifies the 16/32-bit word which will be written.\n//! For 16-bit words, only the lower 16-bits of ulData will be considered by\n//! the master system.\n//! \\param usLength is the length of the word to write (0 = 16-bits, 1 =\n//! 32-bits)\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master  system.\n//!\n//! This function will allow the Local CPU System to write a 16/32-bit word\n//! via the \\e ulData variable to a write-protected address on the Remote CPU\n//! System. The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRDataWrite_Protected(uint32_t ulFlag, uint32_t ulAddress,\n                               uint32_t ulData, uint16_t usLength,\n                               uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up data write command, address, and data. For 16-bit write, Master\n        // system will look at lower 16-bits only.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_16_PROTECTED;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_32_PROTECTED;\n        }\n        IpcRegs.IPCSENDADDR = ulAddress;\n        IpcRegs.IPCSENDDATA = ulData;\n\n        //\n        // Force IPC event on selected request task and enable status-checking\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Calls a Remote CPU function with 1 optional parameter and an optional\n//! return value.\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU function address\n//! \\param ulParam specifies the 32-bit optional parameter value\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the control  system.\n//!\n//! This function will allow the Local CPU system to call a function on the\n//! Remote CPU. The \\e ulParam variable is a single optional 32-bit parameter\n//! to pass to the function. The \\e ulFlag parameter accepts any one of the\n//! flag values \\b IPC_FLAG1 - \\b IPC_FLAG32. The \\e ulStatusFlag parameter\n//! accepts any other one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32\n//! and \\b NO_FLAG. The function returns \\b STATUS_PASS if the command is\n//! successful or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRFunctionCall(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulParam,\n                        uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Remote to Local request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up function call command, address, and parameter.\n        //\n        IpcRegs.IPCSENDCOM = IPC_FUNC_CALL;\n        IpcRegs.IPCSENDADDR = ulAddress;\n        IpcRegs.IPCSENDDATA = ulParam;\n\n        //\n        // Force IPC event on selected request task and enable status-checking\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Slave Requests Master R/W/Exe Access to Shared SARAM.\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulMask specifies the 32-bit mask for the GSxMEMSEL RAM control\n//! register to indicate which GSx SARAM blocks the Slave is requesting master\n//! access to.\n//! \\param ulMaster specifies whether CPU1 or CPU2 should be the master of the\n//! GSx RAM.\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master  system.\n//!\n//! This function will allow the slave CPU System to request slave or master\n//! mastership of any of the GSx Shared SARAM blocks.\n//! The \\e ulMaster parameter accepts the following values:\n//! \\b IPC_GSX_CPU2_MASTER or \\b IPC_GSX_CPU1_MASTER. The \\e ulStatusFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32\n//! and \\b NO_FLAG. The function returns \\b STATUS_PASS if the command is\n//! successful or \\b STATUS_FAIL if the request or status flags are unavailable.\n//! \\note This function calls the \\e IPCLiteLtoRSetBits_Protected() or the\n//! \\e IPCLiteLtoRClearBits_Protected function, and therefore in order to\n//! process this function, the above 2 functions should be ready to be called\n//! on the master system to process this command.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteReqMemAccess (uint32_t ulFlag, uint32_t ulMask, uint16_t ulMaster,\n                     uint32_t ulStatusFlag)\n{\n    uint16_t status;\n    uint32_t GSxMSEL_REGaddress = (uint32_t)(&MemCfgRegs.GSxMSEL.all);\n    if (ulMaster == IPC_GSX_CPU2_MASTER)\n    {\n        status =\n            IPCLiteLtoRSetBits_Protected (ulFlag, GSxMSEL_REGaddress, ulMask,\n                                          IPC_LENGTH_32_BITS,\n                                          ulStatusFlag);\n    }\n    else if (ulMaster == IPC_GSX_CPU1_MASTER)\n    {\n        status =\n            IPCLiteLtoRClearBits_Protected (ulFlag, GSxMSEL_REGaddress, ulMask,\n                                            IPC_LENGTH_32_BITS,\n                                            ulStatusFlag);\n    }\n\n    return status;\n}\n\n//*****************************************************************************\n//\n//! Reads either a 16- or 32-bit data word from the Local CPU system address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control  system.\n//!\n//! This function will allow the Remote CPU system to read 16/32-bit data from\n//! the Local CPU system. The \\e ulFlag parameter accepts any one of the\n//! flag values \\b IPC_FLAG1 - \\b IPC_FLAG32, and the \\e ulStatusFlag parameter\n//! accepts any other one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and\n//! \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLDataRead(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n\n    uint32_t* pulRAddress;\n    uint16_t* pusRAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command and data length are correct for this function:\n    // Then read from requested address and write 16/32-bit data\n    // to IPCLOCALREPLY. Acknowledge the status flag\n    // and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_DATA_READ_16)\n    {\n        //\n        // Perform 16-bit read.\n        //\n        pusRAddress = (uint16_t *)IpcRegs.IPCRECVADDR;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)(*pusRAddress);\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_DATA_READ_32)\n    {\n        pulRAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        IpcRegs.IPCLOCALREPLY = *pulRAddress;\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    //(Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit data word at the Local CPU system\n//! address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to set bits specified by a\n//! mask variable in a 16/32-bit word on the Local CPU system, and then read\n//! back the word into the IPCLOCALREPLY register. The \\e ulFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32, and the\n//! \\e ulStatusFlag parameter accepts any other one of the flag values \\b\n//! IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLSetBits(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then set the mask bits at the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_16)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress |= (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_32)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;;\n        *pulAddress |= (uint32_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16-bit data word at the Local CPU system\n//! write-protected address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to set bits specified by a\n//! mask variable in a write-protected 16/32-bit word on the Local CPU system,\n//! and then read back the word into the IPCLOCALREPLY register. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLSetBits_Protected (uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then enable write access with EALLOW and\n    // set the mask bits at the requested address.\n    // Write back the 16-bit data to IPCLOCALREPLY.\n    // Restore write-protection with EDIS.\n    // Acknowledge the status flag and the task flag.\n    //\n\n    EALLOW;\n\n    if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_16_PROTECTED)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;\n        *pusAddress |= (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_32_PROTECTED)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        *pulAddress |= (uint32_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    //(Indicates to the Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n//! Clears the designated bits in a 16/32-bit data word at Local CPU system\n//! address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to clear bits specified by a\n//! mask variable in a 16/32-bit word on the Local CPU system, and then read\n//! back the word into the IPCLOCALREPLY register. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLClearBits(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then clear the mask bits at the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_16)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress &= ~((uint16_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_32)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        *pulAddress &= ~((uint32_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Clears the designated bits in a 16/32-bit data word at the Local CPU system\n//! write-protected address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to clear bits specified by a\n//! mask variable in a 16/32-bit word on the Local CPU system, and then read\n//! back the word into the IPCLOCALREPLY register. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLClearBits_Protected (uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then enable write access with EALLOW and\n    // clear the mask bits at the requested address.\n    // Write back the 16/32-bit data to IPCLOCALREPLY.\n    // Restore the status of the EALLOW register.\n    // Acknowledge the status flag and the task flag.\n    //\n    EALLOW;\n\n    if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_16_PROTECTED)\n    {\n\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress &= ~((uint16_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_32_PROTECTED)\n    {\n\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;;\n        *pulAddress &= ~((uint32_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to Local CPU system address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to write a 16/32-bit word\n//! to an address on the Local CPU system. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLDataWrite(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint32_t* pulAddress;\n    uint16_t* pusAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then write the 16/32-bit data to the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_16)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress = (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_32)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;;\n        *pulAddress = IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to a write-protected Local CPU system address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to write a 16/32-bit word\n//! to an address on the Local CPU system. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLDataWrite_Protected(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint32_t* pulAddress;\n    uint16_t* pusAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then enable write access with EALLOW and\n    // write the 16/32-bit data to the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    EALLOW;\n\n    if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_16_PROTECTED)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress = (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_32_PROTECTED)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        *pulAddress = IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n\n    //\n    // Restore write-protection status.\n    //\n    EDIS;\n}\n\n//*****************************************************************************\n//\n//! Calls a Local CPU function with a single optional parameter and return\n//! value.\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to call a Local CPU function\n//! with a single optional parameter and places an optional return value in the\n//! IPCLOCALREPLY register. The \\e ulFlag parameter accepts any one of the flag\n//! values \\b IPC_FLAG1 - \\b IPC_FLAG32, and  the \\e ulStatusFlag parameter\n//! accepts any other one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and\n//! \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLFunctionCall(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then call function at requested address\n    // and if there is a return value, insert into\n    // IPCLOCALREPLY register.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_FUNC_CALL)\n    {\n        tfIpcFuncCall func_call = (tfIpcFuncCall)IpcRegs.IPCRECVADDR;\n        IpcRegs.IPCLOCALREPLY = func_call(IpcRegs.IPCRECVDATA);\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    //(Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\nvoid DelayLoop (void)\n{\n    __asm(\" nop\");\n    __asm(\" nop\");\n    __asm(\" nop\");\n    __asm(\" nop\");\n    __asm(\" nop\");\n}\n\n//*****************************************************************************\n// Close the Doxygen group.\n//! @}\n//*****************************************************************************\n\n\n"},{"name":"F2837xD_PieCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:\tF2837xD_PieCtrl.c\n//\n// TITLE:\tF2837xD Device PIE Control Register Initialization Functions.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"     // F2837xD Headerfile Include File\n#include \"F2837xD_Examples.h\"   // F2837xD Examples Include File\n\n//\n// InitPieCtrl - This function initializes the PIE control registers to a\n//               known state.\n//\nvoid InitPieCtrl(void)\n{\n    //\n    // Disable Interrupts at the CPU level:\n    //\n    DINT;\n\n    //\n    // Disable the PIE\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 0;\n\n\t//\n    // Clear all PIEIER registers:\n    //\n\tPieCtrlRegs.PIEIER1.all = 0;\n\tPieCtrlRegs.PIEIER2.all = 0;\n\tPieCtrlRegs.PIEIER3.all = 0;\n\tPieCtrlRegs.PIEIER4.all = 0;\n\tPieCtrlRegs.PIEIER5.all = 0;\n\tPieCtrlRegs.PIEIER6.all = 0;\n\tPieCtrlRegs.PIEIER7.all = 0;\n\tPieCtrlRegs.PIEIER8.all = 0;\n\tPieCtrlRegs.PIEIER9.all = 0;\n\tPieCtrlRegs.PIEIER10.all = 0;\n\tPieCtrlRegs.PIEIER11.all = 0;\n\tPieCtrlRegs.PIEIER12.all = 0;\n\n\t//\n    // Clear all PIEIFR registers:\n    //\n\tPieCtrlRegs.PIEIFR1.all = 0;\n\tPieCtrlRegs.PIEIFR2.all = 0;\n\tPieCtrlRegs.PIEIFR3.all = 0;\n\tPieCtrlRegs.PIEIFR4.all = 0;\n\tPieCtrlRegs.PIEIFR5.all = 0;\n\tPieCtrlRegs.PIEIFR6.all = 0;\n\tPieCtrlRegs.PIEIFR7.all = 0;\n\tPieCtrlRegs.PIEIFR8.all = 0;\n\tPieCtrlRegs.PIEIFR9.all = 0;\n\tPieCtrlRegs.PIEIFR10.all = 0;\n\tPieCtrlRegs.PIEIFR11.all = 0;\n\tPieCtrlRegs.PIEIFR12.all = 0;\n}\n\n//\n// EnableInterrupts - This function enables the PIE module and CPU __interrupts\n//\nvoid EnableInterrupts()\n{\n    //\n    // Enable the PIE\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\n\n\t//\n    // Enables PIE to drive a pulse into the CPU\n    //\n\tPieCtrlRegs.PIEACK.all = 0xFFFF;\n\n\t//\n    // Enable Interrupts at the CPU level\n    //\n    EINT;\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_PieVect.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_PieVect.c\n//\n// TITLE:  F2837xD Device PIE Vector Initialization Functions\n//\n//###########################################################################\n//   $\n// $Release Date:   $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// Globals\n//\nconst struct PIE_VECT_TABLE PieVectTableInit = {\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    TIMER1_ISR,                   // CPU Timer 1 Interrupt\n    TIMER2_ISR,                   // CPU Timer 2 Interrupt\n    DATALOG_ISR,                  // Datalogging Interrupt\n    RTOS_ISR,                     // RTOS Interrupt\n    EMU_ISR,                      // Emulation Interrupt\n    NMI_ISR,                      // Non-Maskable Interrupt\n    ILLEGAL_ISR,                  // Illegal Operation Trap\n    USER1_ISR,                    // User Defined Trap 1\n    USER2_ISR,                    // User Defined Trap 2\n    USER3_ISR,                    // User Defined Trap 3\n    USER4_ISR,                    // User Defined Trap 4\n    USER5_ISR,                    // User Defined Trap 5\n    USER6_ISR,                    // User Defined Trap 6\n    USER7_ISR,                    // User Defined Trap 7\n    USER8_ISR,                    // User Defined Trap 8\n    USER9_ISR,                    // User Defined Trap 9\n    USER10_ISR,                   // User Defined Trap 10\n    USER11_ISR,                   // User Defined Trap 11\n    USER12_ISR,                   // User Defined Trap 12\n    ADCA1_ISR,                    // 1.1 - ADCA Interrupt 1\n    ADCB1_ISR,                    // 1.2 - ADCB Interrupt 1\n    ADCC1_ISR,                    // 1.3 - ADCC Interrupt 1\n    XINT1_ISR,                    // 1.4 - XINT1 Interrupt\n    XINT2_ISR,                    // 1.5 - XINT2 Interrupt\n    ADCD1_ISR,                    // 1.6 - ADCD Interrupt 1\n    TIMER0_ISR,                   // 1.7 - Timer 0 Interrupt\n    WAKE_ISR,                     // 1.8 - Standby and Halt Wakeup Interrupt\n    EPWM1_TZ_ISR,                 // 2.1 - ePWM1 Trip Zone Interrupt\n    EPWM2_TZ_ISR,                 // 2.2 - ePWM2 Trip Zone Interrupt\n    EPWM3_TZ_ISR,                 // 2.3 - ePWM3 Trip Zone Interrupt\n    EPWM4_TZ_ISR,                 // 2.4 - ePWM4 Trip Zone Interrupt\n    EPWM5_TZ_ISR,                 // 2.5 - ePWM5 Trip Zone Interrupt\n    EPWM6_TZ_ISR,                 // 2.6 - ePWM6 Trip Zone Interrupt\n    EPWM7_TZ_ISR,                 // 2.7 - ePWM7 Trip Zone Interrupt\n    EPWM8_TZ_ISR,                 // 2.8 - ePWM8 Trip Zone Interrupt\n    EPWM1_ISR,                    // 3.1 - ePWM1 Interrupt\n    EPWM2_ISR,                    // 3.2 - ePWM2 Interrupt\n    EPWM3_ISR,                    // 3.3 - ePWM3 Interrupt\n    EPWM4_ISR,                    // 3.4 - ePWM4 Interrupt\n    EPWM5_ISR,                    // 3.5 - ePWM5 Interrupt\n    EPWM6_ISR,                    // 3.6 - ePWM6 Interrupt\n    EPWM7_ISR,                    // 3.7 - ePWM7 Interrupt\n    EPWM8_ISR,                    // 3.8 - ePWM8 Interrupt\n    ECAP1_ISR,                    // 4.1 - eCAP1 Interrupt\n    ECAP2_ISR,                    // 4.2 - eCAP2 Interrupt\n    ECAP3_ISR,                    // 4.3 - eCAP3 Interrupt\n    ECAP4_ISR,                    // 4.4 - eCAP4 Interrupt\n    ECAP5_ISR,                    // 4.5 - eCAP5 Interrupt\n    ECAP6_ISR,                    // 4.6 - eCAP6 Interrupt\n    PIE_RESERVED_ISR,             // 4.7 - Reserved\n    PIE_RESERVED_ISR,             // 4.8 - Reserved\n    EQEP1_ISR,                    // 5.1 - eQEP1 Interrupt\n    EQEP2_ISR,                    // 5.2 - eQEP2 Interrupt\n    EQEP3_ISR,                    // 5.3 - eQEP3 Interrupt\n    PIE_RESERVED_ISR,             // 5.4 - Reserved\n    PIE_RESERVED_ISR,             // 5.5 - Reserved\n    PIE_RESERVED_ISR,             // 5.6 - Reserved\n    PIE_RESERVED_ISR,             // 5.7 - Reserved\n    PIE_RESERVED_ISR,             // 5.8 - Reserved\n    SPIA_RX_ISR,                  // 6.1 - SPIA Receive Interrupt\n    SPIA_TX_ISR,                  // 6.2 - SPIA Transmit Interrupt\n    SPIB_RX_ISR,                  // 6.3 - SPIB Receive Interrupt\n    SPIB_TX_ISR,                  // 6.4 - SPIB Transmit Interrupt\n    MCBSPA_RX_ISR,                // 6.5 - McBSPA Receive Interrupt\n    MCBSPA_TX_ISR,                // 6.6 - McBSPA Transmit Interrupt\n    MCBSPB_RX_ISR,                // 6.7 - McBSPB Receive Interrupt\n    MCBSPB_TX_ISR,                // 6.8 - McBSPB Transmit Interrupt\n    DMA_CH1_ISR,                  // 7.1 - DMA Channel 1 Interrupt\n    DMA_CH2_ISR,                  // 7.2 - DMA Channel 2 Interrupt\n    DMA_CH3_ISR,                  // 7.3 - DMA Channel 3 Interrupt\n    DMA_CH4_ISR,                  // 7.4 - DMA Channel 4 Interrupt\n    DMA_CH5_ISR,                  // 7.5 - DMA Channel 5 Interrupt\n    DMA_CH6_ISR,                  // 7.6 - DMA Channel 6 Interrupt\n    PIE_RESERVED_ISR,             // 7.7 - Reserved\n    PIE_RESERVED_ISR,             // 7.8 - Reserved\n    I2CA_ISR,                     // 8.1 - I2CA Interrupt 1\n    I2CA_FIFO_ISR,                // 8.2 - I2CA Interrupt 2\n    I2CB_ISR,                     // 8.3 - I2CB Interrupt 1\n    I2CB_FIFO_ISR,                // 8.4 - I2CB Interrupt 2\n    SCIC_RX_ISR,                  // 8.5 - SCIC Receive Interrupt\n    SCIC_TX_ISR,                  // 8.6 - SCIC Transmit Interrupt\n    SCID_RX_ISR,                  // 8.7 - SCID Receive Interrupt\n    SCID_TX_ISR,                  // 8.8 - SCID Transmit Interrupt\n    SCIA_RX_ISR,                  // 9.1 - SCIA Receive Interrupt\n    SCIA_TX_ISR,                  // 9.2 - SCIA Transmit Interrupt\n    SCIB_RX_ISR,                  // 9.3 - SCIB Receive Interrupt\n    SCIB_TX_ISR,                  // 9.4 - SCIB Transmit Interrupt\n    CANA0_ISR,                    // 9.5 - CANA Interrupt 0\n    CANA1_ISR,                    // 9.6 - CANA Interrupt 1\n    CANB0_ISR,                    // 9.7 - CANB Interrupt 0\n    CANB1_ISR,                    // 9.8 - CANB Interrupt 1\n    ADCA_EVT_ISR,                 // 10.1 - ADCA Event Interrupt\n    ADCA2_ISR,                    // 10.2 - ADCA Interrupt 2\n    ADCA3_ISR,                    // 10.3 - ADCA Interrupt 3\n    ADCA4_ISR,                    // 10.4 - ADCA Interrupt 4\n    ADCB_EVT_ISR,                 // 10.5 - ADCB Event Interrupt\n    ADCB2_ISR,                    // 10.6 - ADCB Interrupt 2\n    ADCB3_ISR,                    // 10.7 - ADCB Interrupt 3\n    ADCB4_ISR,                    // 10.8 - ADCB Interrupt 4\n    CLA1_1_ISR,                   // 11.1 - CLA1 Interrupt 1\n    CLA1_2_ISR,                   // 11.2 - CLA1 Interrupt 2\n    CLA1_3_ISR,                   // 11.3 - CLA1 Interrupt 3\n    CLA1_4_ISR,                   // 11.4 - CLA1 Interrupt 4\n    CLA1_5_ISR,                   // 11.5 - CLA1 Interrupt 5\n    CLA1_6_ISR,                   // 11.6 - CLA1 Interrupt 6\n    CLA1_7_ISR,                   // 11.7 - CLA1 Interrupt 7\n    CLA1_8_ISR,                   // 11.8 - CLA1 Interrupt 8\n    XINT3_ISR,                    // 12.1 - XINT3 Interrupt\n    XINT4_ISR,                    // 12.2 - XINT4 Interrupt\n    XINT5_ISR,                    // 12.3 - XINT5 Interrupt\n    PIE_RESERVED_ISR,             // 12.4 - Reserved\n    PIE_RESERVED_ISR,             // 12.5 - Reserved\n    VCU_ISR,                      // 12.6 - VCU Interrupt\n    FPU_OVERFLOW_ISR,             // 12.7 - FPU Overflow Interrupt\n    FPU_UNDERFLOW_ISR,            // 12.8 - FPU Underflow Interrupt\n    PIE_RESERVED_ISR,             // 1.9 - Reserved\n    PIE_RESERVED_ISR,             // 1.10 - Reserved\n    PIE_RESERVED_ISR,             // 1.11 - Reserved\n    PIE_RESERVED_ISR,             // 1.12 - Reserved\n    IPC0_ISR,                     // 1.13 - IPC Interrupt 0\n    IPC1_ISR,                     // 1.14 - IPC Interrupt 1\n    IPC2_ISR,                     // 1.15 - IPC Interrupt 2\n    IPC3_ISR,                     // 1.16 - IPC Interrupt 3\n    EPWM9_TZ_ISR,                 // 2.9 - ePWM9 Trip Zone Interrupt\n    EPWM10_TZ_ISR,                // 2.10 - ePWM10 Trip Zone Interrupt\n    EPWM11_TZ_ISR,                // 2.11 - ePWM11 Trip Zone Interrupt\n    EPWM12_TZ_ISR,                // 2.12 - ePWM12 Trip Zone Interrupt\n    PIE_RESERVED_ISR,             // 2.13 - Reserved\n    PIE_RESERVED_ISR,             // 2.14 - Reserved\n    PIE_RESERVED_ISR,             // 2.15 - Reserved\n    PIE_RESERVED_ISR,             // 2.16 - Reserved\n    EPWM9_ISR,                    // 3.9 - ePWM9 Interrupt\n    EPWM10_ISR,                   // 3.10 - ePWM10 Interrupt\n    EPWM11_ISR,                   // 3.11 - ePWM11 Interrupt\n    EPWM12_ISR,                   // 3.12 - ePWM12 Interrupt\n    PIE_RESERVED_ISR,             // 3.13 - Reserved\n    PIE_RESERVED_ISR,             // 3.14 - Reserved\n    PIE_RESERVED_ISR,             // 3.15 - Reserved\n    PIE_RESERVED_ISR,             // 3.16 - Reserved\n    PIE_RESERVED_ISR,             // 4.9 - Reserved\n    PIE_RESERVED_ISR,             // 4.10 - Reserved\n    PIE_RESERVED_ISR,             // 4.11 - Reserved\n    PIE_RESERVED_ISR,             // 4.12 - Reserved\n    PIE_RESERVED_ISR,             // 4.13 - Reserved\n    PIE_RESERVED_ISR,             // 4.14 - Reserved\n    PIE_RESERVED_ISR,             // 4.15 - Reserved\n    PIE_RESERVED_ISR,             // 4.16 - Reserved\n    SD1_ISR,                      // 5.9 - SD1 Interrupt\n    SD2_ISR,                      // 5.10 - SD2 Interrupt\n    PIE_RESERVED_ISR,             // 5.11 - Reserved\n    PIE_RESERVED_ISR,             // 5.12 - Reserved\n    PIE_RESERVED_ISR,             // 5.13 - Reserved\n    PIE_RESERVED_ISR,             // 5.14 - Reserved\n    PIE_RESERVED_ISR,             // 5.15 - Reserved\n    PIE_RESERVED_ISR,             // 5.16 - Reserved\n    SPIC_RX_ISR,                  // 6.9 - SPIC Receive Interrupt\n    SPIC_TX_ISR,                  // 6.10 - SPIC Transmit Interrupt\n    PIE_RESERVED_ISR,             // 6.11 - Reserved\n    PIE_RESERVED_ISR,             // 6.12 - Reserved\n    PIE_RESERVED_ISR,             // 6.13 - Reserved\n    PIE_RESERVED_ISR,             // 6.14 - Reserved\n    PIE_RESERVED_ISR,             // 6.15 - Reserved\n    PIE_RESERVED_ISR,             // 6.16 - Reserved\n    PIE_RESERVED_ISR,             // 7.9 - Reserved\n    PIE_RESERVED_ISR,             // 7.10 - Reserved\n    PIE_RESERVED_ISR,             // 7.11 - Reserved\n    PIE_RESERVED_ISR,             // 7.12 - Reserved\n    PIE_RESERVED_ISR,             // 7.13 - Reserved\n    PIE_RESERVED_ISR,             // 7.14 - Reserved\n    PIE_RESERVED_ISR,             // 7.15 - Reserved\n    PIE_RESERVED_ISR,             // 7.16 - Reserved\n    PIE_RESERVED_ISR,             // 8.9 - Reserved\n    PIE_RESERVED_ISR,             // 8.10 - Reserved\n    PIE_RESERVED_ISR,             // 8.11 - Reserved\n    PIE_RESERVED_ISR,             // 8.12 - Reserved\n    PIE_RESERVED_ISR,             // 8.13 - Reserved\n    PIE_RESERVED_ISR,             // 8.14 - Reserved\n#ifdef CPU1    \n    UPPA_ISR,                     // 8.15 - uPPA Interrupt\n    PIE_RESERVED_ISR,             // 8.16 - Reserved\n#elif defined(CPU2)\n    PIE_RESERVED_ISR,             // 8.15 - Reserved\n    PIE_RESERVED_ISR,             // 8.16 - Reserved\n#endif    \n    PIE_RESERVED_ISR,             // 9.9 - Reserved\n    PIE_RESERVED_ISR,             // 9.10 - Reserved\n    PIE_RESERVED_ISR,             // 9.11 - Reserved\n    PIE_RESERVED_ISR,             // 9.12 - Reserved\n    PIE_RESERVED_ISR,             // 9.13 - Reserved\n    PIE_RESERVED_ISR,             // 9.14 - Reserved\n#ifdef CPU1    \n    USBA_ISR,                     // 9.15 - USBA Interrupt\n#elif defined(CPU2)\n    PIE_RESERVED_ISR,             // 9.15 - Reserved\n#endif    \n    PIE_RESERVED_ISR,             // 9.16 - Reserved\n    ADCC_EVT_ISR,                 // 10.9 - ADCC Event Interrupt\n    ADCC2_ISR,                    // 10.10 - ADCC Interrupt 2\n    ADCC3_ISR,                    // 10.11 - ADCC Interrupt 3\n    ADCC4_ISR,                    // 10.12 - ADCC Interrupt 4\n    ADCD_EVT_ISR,                 // 10.13 - ADCD Event Interrupt\n    ADCD2_ISR,                    // 10.14 - ADCD Interrupt 2\n    ADCD3_ISR,                    // 10.15 - ADCD Interrupt 3\n    ADCD4_ISR,                    // 10.16 - ADCD Interrupt 4\n    PIE_RESERVED_ISR,             // 11.9 - Reserved\n    PIE_RESERVED_ISR,             // 11.10 - Reserved\n    PIE_RESERVED_ISR,             // 11.11 - Reserved\n    PIE_RESERVED_ISR,             // 11.12 - Reserved\n    PIE_RESERVED_ISR,             // 11.13 - Reserved\n    PIE_RESERVED_ISR,             // 11.14 - Reserved\n    PIE_RESERVED_ISR,             // 11.15 - Reserved\n    PIE_RESERVED_ISR,             // 11.16 - Reserved\n    EMIF_ERROR_ISR,               // 12.9 - EMIF Error Interrupt\n    RAM_CORRECTABLE_ERROR_ISR,    // 12.10 - RAM Correctable Error Interrupt\n    FLASH_CORRECTABLE_ERROR_ISR,  // 12.11 - Flash Correctable Error Interrupt\n    RAM_ACCESS_VIOLATION_ISR,     // 12.12 - RAM Access Violation Interrupt\n    SYS_PLL_SLIP_ISR,             // 12.13 - System PLL Slip Interrupt\n    AUX_PLL_SLIP_ISR,             // 12.14 - Auxiliary PLL Slip Interrupt\n    CLA_OVERFLOW_ISR,             // 12.15 - CLA Overflow Interrupt\n    CLA_UNDERFLOW_ISR             // 12.16 - CLA Underflow Interrupt\n};\n\n//\n// InitPieVectTable - This function initializes the PIE vector table to a\n//                    known state and must be executed after boot time.\n//\nvoid InitPieVectTable(void)\n{\n    Uint16 i;\n    Uint32 *Source = (void *) &PieVectTableInit;\n    Uint32 *Dest = (void *) &PieVectTable;\n\n    //\n    // Do not write over first 3 32-bit locations (these locations are\n    // initialized by Boot ROM with boot variables)\n    //\n    Source = Source + 3;\n    Dest = Dest + 3;\n\n    EALLOW;\n    for(i = 0; i < 221; i++)\n    {\n    \t*Dest++ = *Source++;\n    }\n    EDIS;\n\n    //\n    // Enable the PIE Vector Table\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_SysCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_SysCtrl.c\n//\n// TITLE:  F2837xD Device System Control Initialization & Support Functions.\n//\n// DESCRIPTION:\n//\n//         Example initialization of system resources.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n#ifdef __cplusplus\nusing std::memcpy;\n#endif\n\n#define STATUS_FAIL          0\n#define STATUS_SUCCESS       1\n#define TMR1SYSCLKCTR        0xF0000000\n#define TMR2INPCLKCTR        0x800\n\n//\n// Functions that will be run from RAM need to be assigned to a different\n// section.  This section will then be mapped to a load and run address using\n// the linker cmd file.\n//\n//      *IMPORTANT*\n//\n//  IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION \".TI.ramfunc\" FROM\n//  FLASH TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM\n//  THROWING AN EXCEPTION WHEN A CALL TO DELAY_US() IS MADE.\n//\n#ifndef __cplusplus\n    #ifdef __TI_COMPILER_VERSION__\n        #if __TI_COMPILER_VERSION__ >= 15009000\n            #pragma CODE_SECTION(InitFlash, \".TI.ramfunc\");\n            #pragma CODE_SECTION(FlashOff, \".TI.ramfunc\");\n        #else\n            #pragma CODE_SECTION(InitFlash, \"ramfuncs\");\n            #pragma CODE_SECTION(FlashOff, \"ramfuncs\");\n        #endif\n    #endif\n#endif\n\n//\n// Macro used for adding delay between 2 consecutive writes to CLKSRCCTL1\n// register.\n// Delay = 300 NOPs\n//\n#define SYSCTRL_CLKSRCCTL1_DELAY  asm(\" RPT #250 || NOP \\n RPT #50 || NOP\")\n\n//\n// InitSysCtrl - Initialization of system resources.\n//\nvoid InitSysCtrl(void)\n{\n    //\n    // Disable the watchdog\n    //\n    DisableDog();\n\n#ifdef _FLASH\n    //\n    // Copy time critical code and Flash setup code to RAM. This includes the\n    // following functions: InitFlash()\n    //\n    // The  RamfuncsLoadStart, RamfuncsLoadSize, and RamfuncsRunStart\n    // symbols are created by the linker. Refer to the device .cmd file.\n    //\n    memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (size_t)&RamfuncsLoadSize);\n\n    //\n    // Call Flash Initialization to setup flash waitstates. This function must\n    // reside in RAM.\n    //\n    InitFlash();\n#endif\n\n    //\n    //      *IMPORTANT*\n    //\n    // The Device_cal function, which copies the ADC & oscillator calibration\n    // values from TI reserved OTP into the appropriate trim registers, occurs\n    // automatically in the Boot ROM. If the boot ROM code is bypassed during\n    // the debug process, the following function MUST be called for the ADC and\n    // oscillators to function according to specification. The clocks to the\n    // ADC MUST be enabled before calling this function.\n    //\n    // See the device data manual and/or the ADC Reference Manual for more\n    // information.\n    //\n#ifdef CPU1\n    EALLOW;\n\n    //\n    // Enable pull-ups on unbonded IOs as soon as possible to reduce power\n    // consumption.\n    //\n    GPIO_EnableUnbondedIOPullups();\n\n    //\n    // Check if the device is trimmed\n    //\n    if((DevCfgRegs.PARTIDL.bit.QUAL == 0x0) &&\n       (AnalogSubsysRegs.ANAREFTRIMA.all == 0x0))\n    {\n        ConfigureTMXAnalogTrim();\n    }\n\n    EDIS;\n\n    //\n    // Initialize the PLL control: SYSPLLMULT and SYSCLKDIVSEL.\n    //\n    // Defined options to be passed as arguments to this function are defined\n    // in F2837xD_Examples.h.\n    //\n    // Note: The internal oscillator CANNOT be used as the PLL source if the\n    // PLLSYSCLK is configured to frequencies above 194 MHz.\n    //\n    //  PLLSYSCLK = (XTAL_OSC) * (IMULT + FMULT) / (PLLSYSCLKDIV)\n    //\n#ifdef _LAUNCHXL_F28379D\n    InitSysPll(XTAL_OSC,IMULT_40,FMULT_0,PLLCLK_BY_2);\n#else\n    InitSysPll(XTAL_OSC, IMULT_20, FMULT_0, PLLCLK_BY_2);\n#endif // _LAUNCHXL_F28379D\n\n#ifndef _FLASH\n    //\n    // Call Device_cal function when run using debugger\n    // This function is called as part of the Boot code. The function is called\n    // in the InitSysCtrl function since during debug time resets, the boot code\n    // will not be executed and the gel script will reinitialize all the\n    // registers and the calibrated values will be lost.\n    //\n    Device_cal();\n#endif\n#endif // CPU1\n\n    //\n    // Turn on all peripherals\n    //\n    InitPeripheralClocks();\n}\n\n//\n// InitPeripheralClocks - Initializes the clocks for the peripherals.\n//\n// Note: In order to reduce power consumption, turn off the clocks to any\n// peripheral that is not specified for your part-number or is not used in the\n// application\n//\nvoid InitPeripheralClocks(void)\n{\n    EALLOW;\n\n    CpuSysRegs.PCLKCR0.bit.CLA1 = 1;\n    CpuSysRegs.PCLKCR0.bit.DMA = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1;\n\n#ifdef CPU1\n    CpuSysRegs.PCLKCR0.bit.HRPWM = 1;\n#endif\n\n    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;\n\n#ifdef CPU1\n    CpuSysRegs.PCLKCR1.bit.EMIF1 = 1;\n    CpuSysRegs.PCLKCR1.bit.EMIF2 = 1;\n#endif\n\n    CpuSysRegs.PCLKCR2.bit.EPWM1 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM2 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM3 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM4 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM5 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM6 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM7 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM8 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM9 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM10 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM11 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM12 = 1;\n\n    CpuSysRegs.PCLKCR3.bit.ECAP1 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP2 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP3 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP4 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP5 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP6 = 1;\n\n    CpuSysRegs.PCLKCR4.bit.EQEP1 = 1;\n    CpuSysRegs.PCLKCR4.bit.EQEP2 = 1;\n    CpuSysRegs.PCLKCR4.bit.EQEP3 = 1;\n\n    CpuSysRegs.PCLKCR6.bit.SD1 = 1;\n    CpuSysRegs.PCLKCR6.bit.SD2 = 1;\n\n    CpuSysRegs.PCLKCR7.bit.SCI_A = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_B = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_C = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_D = 1;\n\n    CpuSysRegs.PCLKCR8.bit.SPI_A = 1;\n    CpuSysRegs.PCLKCR8.bit.SPI_B = 1;\n    CpuSysRegs.PCLKCR8.bit.SPI_C = 1;\n\n    CpuSysRegs.PCLKCR9.bit.I2C_A = 1;\n    CpuSysRegs.PCLKCR9.bit.I2C_B = 1;\n\n    CpuSysRegs.PCLKCR10.bit.CAN_A = 1;\n    CpuSysRegs.PCLKCR10.bit.CAN_B = 1;\n\n    CpuSysRegs.PCLKCR11.bit.McBSP_A = 1;\n    CpuSysRegs.PCLKCR11.bit.McBSP_B = 1;\n\n#ifdef CPU1\n    CpuSysRegs.PCLKCR11.bit.USB_A = 1;\n\n    CpuSysRegs.PCLKCR12.bit.uPP_A = 1;\n#endif\n\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_D = 1;\n\n    CpuSysRegs.PCLKCR14.bit.CMPSS1 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS2 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS3 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS4 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS5 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS6 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS7 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS8 = 1;\n\n    CpuSysRegs.PCLKCR16.bit.DAC_A = 1;\n    CpuSysRegs.PCLKCR16.bit.DAC_B = 1;\n    CpuSysRegs.PCLKCR16.bit.DAC_C = 1;\n\n    EDIS;\n}\n\n//\n// DisablePeripheralClocks - Gates-off all peripheral clocks.\n//\nvoid DisablePeripheralClocks(void)\n{\n    EALLOW;\n\n    CpuSysRegs.PCLKCR0.all = 0;\n    CpuSysRegs.PCLKCR1.all = 0;\n    CpuSysRegs.PCLKCR2.all = 0;\n    CpuSysRegs.PCLKCR3.all = 0;\n    CpuSysRegs.PCLKCR4.all = 0;\n    CpuSysRegs.PCLKCR6.all = 0;\n    CpuSysRegs.PCLKCR7.all = 0;\n    CpuSysRegs.PCLKCR8.all = 0;\n    CpuSysRegs.PCLKCR9.all = 0;\n    CpuSysRegs.PCLKCR10.all = 0;\n    CpuSysRegs.PCLKCR11.all = 0;\n    CpuSysRegs.PCLKCR12.all = 0;\n    CpuSysRegs.PCLKCR13.all = 0;\n    CpuSysRegs.PCLKCR14.all = 0;\n    CpuSysRegs.PCLKCR16.all = 0;\n\n    EDIS;\n}\n\n//\n// InitFlash - This function initializes the Flash Control registers.\n//\n//      *CAUTION*\n// This function MUST be executed out of RAM. Executing it out of OTP/Flash\n// will yield unpredictable results.\n//\n#ifdef __cplusplus\n    #ifdef __TI_COMPILER_VERSION__\n        #if __TI_COMPILER_VERSION__ >= 15009000\n            #pragma CODE_SECTION(\".TI.ramfunc\");\n        #else\n            #pragma CODE_SECTION(\"ramfuncs\");\n        #endif\n    #endif\n#endif\nvoid InitFlash(void)\n{\n    EALLOW;\n\n    //\n    // The default value of VREADST is good enough for the flash to power up\n    // properly at the INTOSC frequency. Below VREADST configuration covers up\n    // to the max frequency possible for this device. This is required for\n    // proper flash wake up at the higher frequencies if users put it to sleep\n    // for power saving reason.\n    //\n    Flash0CtrlRegs.FBAC.bit.VREADST = 0x14;\n\n    //\n    // At reset bank and pump are in sleep. A Flash access will power up the\n    // bank and pump automatically.\n    //\n    // Power up Flash bank and pump. This also sets the fall back mode of\n    // flash and pump as active.\n    //\n    Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0x1;\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0x3;\n\n    //\n    // Disable Cache and prefetch mechanism before changing wait states\n    //\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 0;\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 0;\n\n    //\n    // Set waitstates according to frequency\n    //\n    //      *CAUTION*\n    // Minimum waitstates required for the flash operating at a given CPU rate\n    // must be characterized by TI. Refer to the datasheet for the latest\n    // information.\n    //\n    #if CPU_FRQ_200MHZ\n    Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x3;\n    #endif\n\n    #if CPU_FRQ_150MHZ\n    Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x2;\n    #endif\n\n    #if CPU_FRQ_120MHZ\n    Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x2;\n    #endif\n\n    //\n    // Enable Cache and prefetch mechanism to improve performance of code\n    // executed from Flash.\n    //\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 1;\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 1;\n\n    //\n    // At reset, ECC is enabled. If it is disabled by application software and\n    // if application again wants to enable ECC.\n    //\n    Flash0EccRegs.ECC_ENABLE.bit.ENABLE = 0xA;\n\n    EDIS;\n\n    //\n    // Force a pipeline flush to ensure that the write to the last register\n    // configured occurs before returning.\n    //\n    __asm(\" RPT #7 || NOP\");\n}\n\n//\n// FlashOff - This function powers down the flash\n//\n//      *CAUTION*\n// This function MUST be executed out of RAM. Executing it out of OTP/Flash\n// will yield unpredictable results. Also you must seize the flash pump in\n// order to power it down.\n//\n#ifdef __cplusplus\n    #ifdef __TI_COMPILER_VERSION__\n        #if __TI_COMPILER_VERSION__ >= 15009000\n            #pragma CODE_SECTION(\".TI.ramfunc\");\n        #else\n            #pragma CODE_SECTION(\"ramfuncs\");\n        #endif\n    #endif\n#endif\nvoid FlashOff(void)\n{\n    EALLOW;\n\n    //\n    // Set VREADST to the proper value for the flash banks to power up properly\n    //\n    Flash0CtrlRegs.FBAC.bit.VREADST = 0x14;\n\n    //\n    // Power down bank\n    //\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0;\n\n    //\n    // Power down pump\n    //\n    Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0;\n\n    EDIS;\n}\n\n//\n// SeizeFlashPump - Wait until the flash pump is available. Then take control\n//                  of it using the flash pump Semaphore.\n//\nvoid SeizeFlashPump(void)\n{\n    EALLOW;\n    #ifdef CPU1\n        while (FlashPumpSemaphoreRegs.PUMPREQUEST.bit.PUMP_OWNERSHIP != 0x2)\n        {\n            FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x2;\n        }\n    #elif defined(CPU2)\n        while (FlashPumpSemaphoreRegs.PUMPREQUEST.bit.PUMP_OWNERSHIP != 0x1)\n        {\n            FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x1;\n        }\n    #endif\n    EDIS;\n}\n\n//\n// ReleaseFlashPump - Release control of the flash pump using the flash pump\n//                    semaphore.\n//\nvoid ReleaseFlashPump(void)\n{\n    EALLOW;\n    FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x0;\n    EDIS;\n}\n\n//\n// ServiceDog - This function resets the watchdog timer.\n//\n// Enable this function for using ServiceDog in the application.\n//\nvoid ServiceDog(void)\n{\n    EALLOW;\n    WdRegs.WDKEY.bit.WDKEY = 0x0055;\n    WdRegs.WDKEY.bit.WDKEY = 0x00AA;\n    EDIS;\n}\n\n//\n// DisableDog - This function disables the watchdog timer.\n//\nvoid DisableDog(void)\n{\n    volatile Uint16 temp;\n\n    //\n    // Grab the clock config first so we don't clobber it\n    //\n    EALLOW;\n    temp = WdRegs.WDCR.all & 0x0007;\n    WdRegs.WDCR.all = 0x0068 | temp;\n    EDIS;\n}\n\n#ifdef CPU1\n//\n// InitSysPll()\n// This function initializes the PLL registers.\n// Note:\n//  - The internal oscillator CANNOT be used as the PLL source if the\n//    PLLSYSCLK is configured to frequencies above 194 MHz.\n//\n//  - This function uses the Watchdog as a monitor for the PLL. The user\n//  watchdog settings will be modified and restored upon completion.  Function\n//  allows for a minimum re lock attempt for 5 tries.  Re lock attempt is carried\n//  out if either SLIP condition occurs or SYSCLK to Input Clock ratio is off by 10%\n//\n//  - This function uses the following resources to support PLL initialization:\n//          o Watchdog\n//          o CPU Timer 1\n//          o CPU Timer 2\n//\nvoid InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\n{\n    Uint16 SCSR, WDCR, WDWCR, intStatus,  t1TCR, t1TPR, t1TPRH;\n    Uint16 t2TCR, t2TPR, t2TPRH, t2SRC, t2Prescale;\n    Uint32 t1PRD, t2PRD, ctr1;\n    float sysclkToInClkError, mult, div;\n    bool sysclkInvalidFreq=true;\n\n    if((clock_source == ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)    &&\n       (imult        == ClkCfgRegs.SYSPLLMULT.bit.IMULT)           &&\n       (fmult        == ClkCfgRegs.SYSPLLMULT.bit.FMULT)           &&\n       (divsel       == ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV))\n    {\n        //\n        // Everything is set as required, so just return\n        //\n        return;\n    }\n\n    if(clock_source != ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)\n    {\n        switch (clock_source)\n        {\n            case INT_OSC1:\n                SysIntOsc1Sel();\n                break;\n\n            case INT_OSC2:\n                SysIntOsc2Sel();\n                break;\n\n            case XTAL_OSC:\n                SysXtalOscSel();\n                break;\n        }\n    }\n\n    EALLOW;\n    if(imult != ClkCfgRegs.SYSPLLMULT.bit.IMULT ||\n       fmult != ClkCfgRegs.SYSPLLMULT.bit.FMULT)\n    {\n        Uint16 i;\n\n        //\n        // This bit is reset only by POR\n        //\n        if(DevCfgRegs.SYSDBGCTL.bit.BIT_0 == 1)\n        {\n            //\n            // The user can optionally insert handler code here. This will only\n            // be executed if a watchdog reset occurred after a failed system\n            // PLL initialization. See your device user's guide for more\n            // information.\n            //\n            // If the application has a watchdog reset handler, this bit should\n            // be checked to determine if the watchdog reset occurred because\n            // of the PLL.\n            //\n            // No action here will continue with retrying the PLL as normal.\n            //\n            // Failed PLL initialization is due to any of the following:\n            //      - No PLL clock\n            //      - SLIP condition\n            //      - Wrong Frequency\n            //\n        }\n\n        //\n        // Bypass PLL and set dividers to /1\n        //\n        ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        asm(\" RPT #120 || NOP\");\n        ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = 0;\n\n        //\n        // Lock the PLL five times. This helps ensure a successful start.\n        // Five is the minimum recommended number. The user can increase this\n        // number according to allotted system initialization time.\n        //\n        for(i = 0; i < 5; i++)\n        {\n            //\n            // Turn off PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n            asm(\" RPT #20 || NOP\");\n\n            //\n            // Write multiplier, which automatically turns on the PLL\n            //\n            ClkCfgRegs.SYSPLLMULT.all = ((fmult << 8U) | imult);\n\n            //\n            // Wait for the SYSPLL lock counter\n            //\n            while(ClkCfgRegs.SYSPLLSTS.bit.LOCKS != 1)\n            {\n                //\n                // Uncomment to service the watchdog\n                //\n                // ServiceDog();\n            }\n        }\n    }\n\n    //\n    // Set divider to produce slower output frequency to limit current increase\n    //\n    if(divsel != PLLCLK_BY_126)\n    {\n         ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel + 1;\n    }\n    else\n    {\n         ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n    }\n\n    //\n    //      *CAUTION*\n    // It is recommended to use the following watchdog code to monitor the PLL\n    // startup sequence. If your application has already cleared the watchdog\n    // SCRS[WDOVERRIDE] bit this cannot be done. It is recommended not to clear\n    // this bit until after the PLL has been initiated.\n    //\n\n    //\n    // Backup User Watchdog\n    //\n    SCSR = WdRegs.SCSR.all;\n    WDCR = WdRegs.WDCR.all;\n    WDWCR = WdRegs.WDWCR.all;\n\n    //\n    // Disable windowed functionality, reset counter\n    //\n    EALLOW;\n    WdRegs.WDWCR.all = 0x0;\n    WdRegs.WDKEY.bit.WDKEY = 0x55;\n    WdRegs.WDKEY.bit.WDKEY = 0xAA;\n\n    //\n    // Disable global interrupts\n    //\n    intStatus = __disable_interrupts();\n\n    //\n    // Configure for watchdog reset and to run at max frequency\n    //\n    WdRegs.SCSR.all = 0x0;\n    WdRegs.WDCR.all = 0x28;\n\n    //\n    // This bit is reset only by power-on-reset (POR) and will not be cleared\n    // by a WD reset\n    //\n    DevCfgRegs.SYSDBGCTL.bit.BIT_0 = 1;\n\n    //\n    // Enable PLLSYSCLK is fed from system PLL clock\n    //\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\n\n    //\n    // Delay to ensure system is clocking from PLL prior to clearing status bit\n    //\n    asm(\" RPT #20 || NOP\");\n\n    //\n    // Service watchdog\n    //\n    ServiceDog();\n\n    //\n    // Slip Bit Monitor and SYSCLK Frequency Check using timers\n    // Re-lock routine for SLIP condition or if SYSCLK and CLKSRC timer counts\n    // are off by +/- 10%.\n    // At a minimum, SYSCLK check is performed.  Re lock attempt is carried out\n    // if SLIPS bit is set. This while loop is monitored by watchdog.\n    // In the event that the PLL does not successfully lock, the loop will be\n    // aborted by watchdog reset.\n    //\n    EALLOW;\n    while(sysclkInvalidFreq == true)\n    {\n        if(ClkCfgRegs.SYSPLLSTS.bit.SLIPS == 1)\n        {\n            //\n            // Bypass PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n\n            //\n            // Delay of at least 120 OSCCLK cycles required post PLL bypass\n            //\n            asm(\" RPT #120 || NOP\");\n\n            //\n            // Turn off PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n            asm(\" RPT #20 || NOP\");\n\n            //\n            // Write multipliers, which automatically turns on the PLL\n            //\n            ClkCfgRegs.SYSPLLMULT.all = ((fmult << 8U) | imult);\n\n            //\n            // Wait for the SYSPLL lock counter to expire\n            //\n            while(ClkCfgRegs.SYSPLLSTS.bit.LOCKS != 1);\n\n            //\n            // Enable PLLSYSCLK is fed from system PLL clock\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\n\n            //\n            // Delay to ensure system is clocking from PLL\n            //\n            asm(\" RPT #20 || NOP\");\n        }\n\n        //\n        // Backup timer1 and timer2 settings\n        //\n        t1TCR = CpuTimer1Regs.TCR.all;\n        t1PRD = CpuTimer1Regs.PRD.all;\n        t1TPR = CpuTimer1Regs.TPR.all;\n        t1TPRH = CpuTimer1Regs.TPRH.all;\n        t2SRC = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL;\n        t2Prescale = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE;\n        t2TCR = CpuTimer2Regs.TCR.all;\n        t2PRD = CpuTimer2Regs.PRD.all;\n        t2TPR = CpuTimer2Regs.TPR.all;\n        t2TPRH = CpuTimer2Regs.TPRH.all;\n\n        //\n        // Set up timers 1 and 2\n        // Configure timer1 to count SYSCLK cycles\n        //\n        CpuTimer1Regs.TCR.bit.TSS = 1;                                    // stop timer1\n        CpuTimer1Regs.PRD.all = TMR1SYSCLKCTR;                            // seed timer1 counter\n        CpuTimer1Regs.TPR.bit.TDDR = 0x0;                                 // sysclock divider\n        CpuTimer1Regs.TCR.bit.TRB = 1;                                    // reload timer with value in PRD\n        CpuTimer1Regs.TCR.bit.TIF = 1;                                    // clear interrupt flag\n        CpuTimer1Regs.TCR.bit.TIE = 1;                                    // enable interrupt\n\n        //\n        // Configure timer2 to count Input clock cycles\n        //\n        switch(clock_source)\n        {\n            case INT_OSC1:\n                // Clk Src = INT_OSC1\n                CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x1;\n                break;\n            case INT_OSC2:\n                // Clk Src = INT_OSC2\n                CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x2;\n                break;\n            case XTAL_OSC:\n                // Clk Src = XTAL\n                CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x3;\n                break;\n\n        }\n        CpuTimer2Regs.TCR.bit.TIF = 1;                                    // clear interrupt flag\n        CpuTimer2Regs.TCR.bit.TIE = 1;                                    // enable interrupt\n        CpuTimer2Regs.TCR.bit.TSS = 1;                                    // stop timer2\n        CpuTimer2Regs.PRD.all = TMR2INPCLKCTR;                            // seed timer2 counter\n        CpuTimer2Regs.TPR.bit.TDDR = 0x0;                                 // sysclock divider\n        CpuTimer2Regs.TCR.bit.TRB = 1;                                    // reload timer with value in PRD\n\n        //\n        // Stop/Start timer counters\n        //\n        CpuTimer1Regs.TCR.bit.TSS = 1;                                    // stop timer1\n        CpuTimer2Regs.TCR.bit.TSS = 1;                                    // stop timer2\n        CpuTimer1Regs.TCR.bit.TRB = 1;                                    // reload timer1 with value in PRD\n        CpuTimer2Regs.TCR.bit.TRB = 1;                                    // reload timer2 with value in PRD\n        CpuTimer2Regs.TCR.bit.TIF = 1;                                    // clear timer2 interrupt flag\n        CpuTimer2Regs.TCR.bit.TSS = 0;                                    // start timer2\n        CpuTimer1Regs.TCR.bit.TSS = 0;                                    // start timer1\n\n        //\n        // Stop timers if either timer1 or timer2 counters overflow\n        //\n        while((CpuTimer2Regs.TCR.bit.TIF == 0) && (CpuTimer1Regs.TCR.bit.TIF == 0));\n\n        CpuTimer1Regs.TCR.bit.TSS = 1;                                    // stop timer1\n        CpuTimer2Regs.TCR.bit.TSS = 1;                                    // stop timer2\n\n        //\n        // Calculate elapsed counts on timer1\n        //\n        ctr1 = TMR1SYSCLKCTR - CpuTimer1Regs.TIM.all;\n\n        //\n        // Restore timer settings\n        //\n        CpuTimer1Regs.TCR.all = t1TCR;\n        CpuTimer1Regs.PRD.all = t1PRD;\n        CpuTimer1Regs.TPR.all = t1TPR;\n        CpuTimer1Regs.TPRH.all = t1TPRH;\n        CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = t2SRC;\n        CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = t2Prescale;\n        CpuTimer2Regs.TCR.all = t2TCR;\n        CpuTimer2Regs.PRD.all = t2PRD;\n        CpuTimer2Regs.TPR.all = t2TPR;\n        CpuTimer2Regs.TPRH.all = t2TPRH;\n\n        //\n        // Calculate Clock Error:\n        // Error = (mult/div) - (timer1 count/timer2 count)\n        //\n        mult = (float)(imult) + (float)(fmult)/4;\n        div = (float)((!ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV) ? 1 : (ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV << 1));\n\n        sysclkToInClkError = (mult/div) - ((float)ctr1/(float)TMR2INPCLKCTR);\n\n        //\n        // sysclkInvalidFreq will be set to true if sysclkToInClkError is off by 10%\n        //\n        sysclkInvalidFreq = ((sysclkToInClkError > 0.10) || (sysclkToInClkError < -0.10));\n    }\n\n    //\n    // Clear bit\n    //\n    DevCfgRegs.SYSDBGCTL.bit.BIT_0 = 0;\n\n    //\n    // Restore user watchdog, first resetting counter\n    //\n    WdRegs.WDKEY.bit.WDKEY = 0x55;\n    WdRegs.WDKEY.bit.WDKEY = 0xAA;\n\n    WDCR |= 0x28;                     // Setup WD key--KEY bits always read 0\n    WdRegs.WDCR.all = WDCR;\n    WdRegs.WDWCR.all = WDWCR;\n    WdRegs.SCSR.all = SCSR & 0xFFFE;  // Mask write to bit 0 (W1toClr)\n\n    //\n    // Restore state of ST1[INTM]. This was set by the __disable_interrupts()\n    // intrinsic previously.\n    //\n    if(!(intStatus & 0x1))\n    {\n        EINT;\n    }\n\n    //\n    // Restore state of ST1[DBGM]. This was set by the __disable_interrupts()\n    // intrinsic previously.\n    //\n    if(!(intStatus & 0x2))\n    {\n        asm(\" CLRC DBGM\");\n    }\n\n    //\n    // 200 PLLSYSCLK delay to allow voltage regulator to stabilize prior\n    // to increasing entire system clock frequency.\n    //\n    asm(\" RPT #200 || NOP\");\n\n    //\n    // Set the divider to user value\n    //\n    ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n\n    EDIS;\n}\n#endif // CPU1\n\n//\n// InitAuxPll - This function initializes the AUXPLL registers.\n//\n// Note: For this function to properly detect PLL startup,\n// SYSCLK >= 2*AUXPLLCLK after the AUXPLL is selected as the clocking source.\n//\n// This function will use CPU Timer 2 to monitor a successful lock of the\n// AUXPLL.\n//\nvoid InitAuxPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\n{\n    Uint16 i;\n    Uint16 counter = 0;\n    Uint16 started = 0;\n    Uint16 t2TCR, t2TPR, t2TPRH, t2SRC, t2Prescale, attempts;\n    Uint32 t2PRD;\n\n    if((clock_source == ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL) &&\n       (imult        == ClkCfgRegs.AUXPLLMULT.bit.IMULT)           &&\n       (fmult        == ClkCfgRegs.AUXPLLMULT.bit.FMULT)           &&\n       (divsel       == ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV))\n    {\n        //\n        // Everything is set as required, so just return\n        //\n        return;\n    }\n\n    switch (clock_source)\n    {\n        case INT_OSC2:\n            AuxIntOsc2Sel();\n            break;\n\n        case XTAL_OSC:\n            AuxXtalOscSel();\n            break;\n\n        case AUXCLKIN:\n            AuxAuxClkSel();\n            break;\n    }\n\n    EALLOW;\n    ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 0;    // Bypass AUXPLL\n    EDIS;\n\n    //\n    // Delay of at least 120 OSCCLK cycles required post PLL bypass\n    //\n    asm(\" RPT #120 || NOP\");\n\n    //\n    // Backup Timer 2 settings\n    //\n    t2SRC = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL;\n    t2Prescale = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE;\n    t2TCR = CpuTimer2Regs.TCR.all;\n    t2PRD = CpuTimer2Regs.PRD.all;\n    t2TPR = CpuTimer2Regs.TPR.all;\n    t2TPRH = CpuTimer2Regs.TPRH.all;\n\n    //\n    // Configure Timer 2 for AUXPLL as source in known configuration\n    //\n    EALLOW;\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x6;\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = 0x0;    // Divide by 1\n\n    CpuTimer2Regs.TCR.bit.TSS = 1;      // Stop timer\n    CpuTimer2Regs.PRD.all = 10;         // Small PRD value to detect overflow\n    CpuTimer2Regs.TPR.all = 0;\n    CpuTimer2Regs.TPRH.all = 0;\n    CpuTimer2Regs.TCR.bit.TIE = 0;      // Disable timer interrupts\n\n    //\n    // Set AUX Divide by 8 to ensure that AUXPLLCLK <= SYSCLK/2 while using\n    // Timer 2\n    //\n    ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV = 0x3;\n    EDIS;\n\n    while((counter < 5) && (started == 0))\n    {\n        EALLOW;\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 0;    // Turn off AUXPLL\n        asm(\" RPT #20 || NOP\");                 // Small delay for power down\n\n        //\n        // Set integer and fractional multiplier, which automatically turns on\n        // the PLL\n        //\n        ClkCfgRegs.AUXPLLMULT.all = ((fmult << 8U) | imult);\n\n        //\n        // Enable AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 1;\n        EDIS;\n\n        //\n        // Wait for the AUXPLL lock counter\n        //\n        while(ClkCfgRegs.AUXPLLSTS.bit.LOCKS != 1)\n        {\n            //\n            // Uncomment to service the watchdog\n            //\n            // ServiceDog();\n        }\n\n        //\n        // Enable AUXPLLCLK to be fed from AUX PLL\n        //\n        EALLOW;\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 1;\n        asm(\" RPT #20 || NOP\");\n\n        //\n        // CPU Timer 2 will now be setup to be clocked from AUXPLLCLK. This is\n        // used to test that the PLL has successfully started.\n        //\n        CpuTimer2Regs.TCR.bit.TRB = 1;      // Reload period value\n        CpuTimer2Regs.TCR.bit.TSS = 0;      // Start Timer\n\n        //\n        // Check to see timer is counting properly\n        //\n        for(i = 0; i < 1000; i++)\n        {\n            //\n            // Check overflow flag\n            //\n            if(CpuTimer2Regs.TCR.bit.TIF)\n            {\n                //\n                // Clear overflow flag\n                //\n                CpuTimer2Regs.TCR.bit.TIF = 1;\n\n                //\n                // Set flag to indicate PLL started and break out of for-loop\n                //\n                started = 1;\n                break;\n            }\n        }\n\n        //\n        // Stop timer\n        //\n        CpuTimer2Regs.TCR.bit.TSS = 1;\n        counter++;\n        EDIS;\n    }\n\n    if(started == 0)\n    {\n        //\n        // AUX PLL may not have started. Reset multiplier to 0 (bypass PLL).\n        //\n        EALLOW;\n        ClkCfgRegs.AUXPLLMULT.all = 0;\n        EDIS;\n\n        //\n        // The user should put some handler code here based on how this\n        // condition should be handled in their application.\n        //\n        asm(\" ESTOP0\");\n    }\n\n    //\n    // Slip Bit Monitor\n    // Re-lock routine for SLIP condition\n    //\n    attempts = 0;\n    while(ClkCfgRegs.AUXPLLSTS.bit.SLIPS && (attempts < 10))\n    {\n        EALLOW;\n        //\n        // Bypass AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 0;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        asm(\" RPT #120 || NOP\");\n\n        //\n        // Turn off AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 0;\n        asm(\" RPT #20 || NOP\");\n\n        //\n        // Set integer and fractional multiplier, which automatically turns\n        // on the PLL\n        //\n        ClkCfgRegs.AUXPLLMULT.all = ((fmult << 8U) | imult);\n\n        //\n        // Wait for the AUXPLL lock counter\n        //\n        while(ClkCfgRegs.AUXPLLSTS.bit.LOCKS != 1);\n\n        //\n        // Enable AUXPLLCLK to be fed from AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 1;\n        asm(\" RPT #20 || NOP\");\n\n        attempts++;\n        EDIS;\n    }\n\n    //\n    // Set divider to desired value\n    //\n    EALLOW;\n    ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV = divsel;\n\n    //\n    // Restore Timer 2 configuration\n    //\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = t2SRC;\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = t2Prescale;\n    CpuTimer2Regs.TCR.all = t2TCR;\n    CpuTimer2Regs.PRD.all = t2PRD;\n    CpuTimer2Regs.TPR.all = t2TPR;\n    CpuTimer2Regs.TPRH.all = t2TPRH;\n\n    //\n    // Reload period value\n    //\n    CpuTimer2Regs.TCR.bit.TRB = 1;\n    EDIS;\n}\n\n//\n// CsmUnlock - This function unlocks the CSM. User must replace 0xFFFF's with\n//             current password for the DSP. Returns 1 if unlock is successful.\n//\nUint16 CsmUnlock(void)\n{\n    volatile Uint16 temp;\n\n    //\n    // Load the key registers with the current password. The 0xFFFF's are dummy\n    // passwords.  User should replace them with the correct password for the\n    // DSP.\n    //\n    EALLOW;\n    DcsmZ1Regs.Z1_CSMKEY0 = 0xFFFFFFFF;\n    DcsmZ1Regs.Z1_CSMKEY1 = 0xFFFFFFFF;\n    DcsmZ1Regs.Z1_CSMKEY2 = 0xFFFFFFFF;\n    DcsmZ1Regs.Z1_CSMKEY3 = 0xFFFFFFFF;\n\n    DcsmZ2Regs.Z2_CSMKEY0 = 0xFFFFFFFF;\n    DcsmZ2Regs.Z2_CSMKEY1 = 0xFFFFFFFF;\n    DcsmZ2Regs.Z2_CSMKEY2 = 0xFFFFFFFF;\n    DcsmZ2Regs.Z2_CSMKEY3 = 0xFFFFFFFF;\n    EDIS;\n\n    return(0);\n}\n\n//\n// SysIntOsc1Sel - This function switches to Internal Oscillator 1.\n//\nvoid SysIntOsc1Sel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 2;     // Clk Src = INTOSC1\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=1;            // Turn off XTALOSC\n    EDIS;\n}\n\n//\n// SysIntOsc2Sel - This function switches to Internal oscillator 2.\n//\nvoid SysIntOsc2Sel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         // Turn on INTOSC2\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 0;     // Clk Src = INTOSC2\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=1;            // Turn off XTALOSC\n    EDIS;\n}\n\n//\n// SysXtalOscSel - This function switches to External CRYSTAL oscillator.\n//\nvoid SysXtalOscSel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=0;            // Turn on XTALOSC\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 1;     // Clk Src = XTAL\n    EDIS;\n}\n\n//\n// AuxIntOsc2Sel - This function switches to Internal oscillator 2.\n//\nvoid AuxIntOsc2Sel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         // Turn on INTOSC2\n    ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 0;  // Clk Src = INTOSC2\n    EDIS;\n}\n\n//\n// AuxXtalOscSel - This function switches to External CRYSTAL oscillator.\n//\nvoid AuxXtalOscSel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=0;            // Turn on XTALOSC\n    ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 1;  // Clk Src = XTAL\n    EDIS;\n}\n\n//\n// AuxAUXCLKOscSel - This function switches to AUXCLKIN (from a GPIO).\n//\nvoid AuxAuxClkSel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 2; // Clk Src = XTAL\n    EDIS;\n}\n\n//\n// IDLE - Enter IDLE mode (single CPU).\n//\nvoid IDLE(void)\n{\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_IDLE;\n    EDIS;\n    asm(\" IDLE\");\n}\n\n//\n// STANDBY - Enter STANDBY mode (single CPU).\n//\nvoid STANDBY(void)\n{\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_STANDBY;\n    EDIS;\n    asm(\" IDLE\");\n}\n\n//\n// HALT - Enter HALT mode (dual CPU). Puts CPU2 in IDLE mode first.\n//\nvoid HALT(void)\n{\n#if defined(CPU2)\n    IDLE();\n#elif defined(CPU1)\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_HALT;\n    EDIS;\n\n    while(DevCfgRegs.LPMSTAT.bit.CPU2LPMSTAT != 0x1);\n\n    EALLOW;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n    EDIS;\n    asm(\" IDLE\");\n#endif\n}\n\n//\n// HIB - Enter HIB mode (dual CPU). Puts CPU2 in STANDBY first. Alternately,\n//       CPU2 may be in reset.\nvoid HIB(void)\n{\n#if defined(CPU2)\n    STANDBY();\n#elif defined(CPU1)\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_HIB;\n    EDIS;\n\n    while((DevCfgRegs.LPMSTAT.bit.CPU2LPMSTAT == 0x0) &&\n          (DevCfgRegs.RSTSTAT.bit.CPU2RES == 1));\n\n    DisablePeripheralClocks();\n    EALLOW;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n    EDIS;\n    asm(\" IDLE\");\n#endif\n}\n\n#ifdef CPU1\n//\n// Function to implement Analog trim of TMX devices. This function should be\n// called post enabling the EALLOW protected writes.\n//\nvoid ConfigureTMXAnalogTrim(void)\n{\n    //\n    // Enable ADC clock\n    //\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_D = 1;\n\n\n    //\n    // Device is not trimmed--apply static calibration values\n    //\n    AnalogSubsysRegs.ANAREFTRIMA.all = 0x7BDD;\n    AnalogSubsysRegs.ANAREFTRIMB.all = 0x7BDD;\n    AnalogSubsysRegs.ANAREFTRIMC.all = 0x7BDD;\n    AnalogSubsysRegs.ANAREFTRIMD.all = 0x7BDD;\n\n    //\n    // Configure ADC offset trim. The user should generate the trim values\n    // by following the instructions in the \"ADC Zero Offset Calibration\"\n    // section in device TRM. The below lines needs to be uncommented and\n    // updated with the correct trim values.\n    //\n//    AdcaRegs.ADCOFFTRIM.all = 0x0;\n//    AdcbRegs.ADCOFFTRIM.all = 0x0;\n//    AdccRegs.ADCOFFTRIM.all = 0x0;\n//    AdcdRegs.ADCOFFTRIM.all = 0x0;\n\n    //\n    // Configure internal oscillator trim. If the internal oscillator trim\n    // contains all zeros, the user can adjust the lowest 10 bits of the\n    // oscillator trim register between 1 (minimum) and 1023 (maximum)\n    // while observing the system clock on the XCLOCKOUT pin. The below\n    // lines needs to be uncommented and updated with the correct trim values.\n    //\n//    if(AnalogSubsysRegs.INTOSC1TRIM.all == 0x0)\n//    {\n//        AnalogSubsysRegs.INTOSC1TRIM.all = 0x0;\n//    }\n//\n//    if(AnalogSubsysRegs.INTOSC2TRIM.all == 0x0)\n//    {\n//        AnalogSubsysRegs.INTOSC2TRIM.all = 0x0;\n//    }\n\n    //\n    // Disable ADC clock\n    //\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 0;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 0;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 0;\n    CpuSysRegs.PCLKCR13.bit.ADC_D = 0;\n}\n#endif\n"},{"name":"F2837xD_usDelay.asm","type":"other","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\n;//\n;// FILE: F2837xD_usDelay.asm\n;//\n;// TITLE: Simple delay function\n;//\n;// DESCRIPTION:\n;// This is a simple delay function that can be used to insert a specified\n;// delay into code.\n;// This function is only accurate if executed from internal zero-waitstate\n;// SARAM. If it is executed from waitstate memory then the delay will be\n;// longer then specified.\n;// To use this function:\n;//  1 - update the CPU clock speed in the F2837xD_Examples.h\n;//    file. For example:\n;//    #define CPU_RATE 6.667L // for a 150MHz CPU clock speed\n;//  2 - Call this function by using the DELAY_US(A) macro\n;//    that is defined in the F2837xD_Device.h file.  This macro\n;//    will convert the number of microseconds specified\n;//    into a loop count for use with this function.\n;//    This count will be based on the CPU frequency you specify.\n;//  3 - For the most accurate delay\n;//    - Execute this function in 0 waitstate RAM.\n;//    - Disable interrupts before calling the function\n;//      If you do not disable interrupts, then think of\n;//      this as an \"at least\" delay function as the actual\n;//      delay may be longer.\n;//  The C assembly call from the DELAY_US(time) macro will\n;//  look as follows:\n;//  extern void Delay(long LoopCount);\n;//        MOV   AL,#LowLoopCount\n;//        MOV   AH,#HighLoopCount\n;//        LCR   _Delay\n;//  Or as follows (if count is less then 16-bits):\n;//        MOV   ACC,#LoopCount\n;//        LCR   _Delay\n;//\n;//###########################################################################\n;//\n;// $Release Date: $\n;// $Copyright:\n;// Copyright (C) 2013-2023 Texas Instruments Incorporated - http://www.ti.com/\n;//\n;// Redistribution and use in source and binary forms, with or without \n;// modification, are permitted provided that the following conditions \n;// are met:\n;// \n;//   Redistributions of source code must retain the above copyright \n;//   notice, this list of conditions and the following disclaimer.\n;// \n;//   Redistributions in binary form must reproduce the above copyright\n;//   notice, this list of conditions and the following disclaimer in the \n;//   documentation and/or other materials provided with the   \n;//   distribution.\n;// \n;//   Neither the name of Texas Instruments Incorporated nor the names of\n;//   its contributors may be used to endorse or promote products derived\n;//   from this software without specific prior written permission.\n;// \n;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n;// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n;// $\n;//###########################################################################\n\n\t   .if __TI_EABI__\n\t   .asg F28x_usDelay, _F28x_usDelay\n\t   .endif\n\n       .def _F28x_usDelay\n\n       .cdecls LIST ;;Used to populate __TI_COMPILER_VERSION__ macro\n       %{\n       %}\n\n       .if __TI_COMPILER_VERSION__\n       .if __TI_COMPILER_VERSION__ >= 15009000\n       .sect \".TI.ramfunc\"      ;;Used with compiler v15.9.0 and newer\n       .else\n       .sect \"ramfuncs\"         ;;Used with compilers older than v15.9.0\n       .endif\n       .endif\n\n        .global  __F28x_usDelay\n_F28x_usDelay:\n        SUB    ACC,#1\n        BF     _F28x_usDelay,GEQ    ;; Loop if ACC >= 0\n        LRETR\n\n;There is a 9/10 cycle overhead and each loop\n;takes five cycles. The LoopCount is given by\n;the following formula:\n;  DELAY_CPU_CYCLES = 9 + 5*LoopCount\n; LoopCount = (DELAY_CPU_CYCLES - 9) / 5\n; The macro DELAY_US(A) performs this calculation for you\n;\n;\n\n;//\n;// End of file\n;//\n"},{"name":"MW_c28xGPIO.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGPIO.c\n * TITLE: GPIO functions to access the GPIO specific registers for C2000 target\n * Copyright 2017-2023 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n\n#include \"MW_c28xGPIO.h\"\n#ifdef CPU2\n#ifdef MW_F2837XD\n#include \"MW_f2837xD_includes.h\"\n#endif //MW_F2837XD\n#ifdef MW_F2838X\n#include \"MW_f2838x_includes.h\"\n#endif //MW_F2838X\n#ifdef MW_F28P65X\n#include \"MW_f28p65x_includes.h\"\n#endif //MW_F28P65X\n#endif //CPU2\n\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\nUint16 GPIO_oneTimeInit = 0;\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* One time initialization of all GPIOs */\nvoid OneTimeGpioInit(void)\n{    \n    if(GPIO_oneTimeInit == 0U)\n    {\n#ifdef CPU1\n        InitGpio();\n#endif //End of CPU1\n        GPIO_oneTimeInit = 1U;\n    }\n}\n\n#ifndef MW_F281X /*GPIO implementation not supported for C281x */\n#ifndef F2837X_REG_FORMAT /*GPIO functions are provided by TI*/\n#ifndef MW_F2804X /*GPIO initialization is provided by TI for F2804x*/\n\n/*Sets all pins to be muxed to GPIO in input mode with pull-ups enabled.\n * Also sets the qualification to synchronous.*/\nvoid InitGpio(void)\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n    EALLOW;\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n    \n    /* For concerto additional registers needs to be initialized*/\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioG1CtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioG1CtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioG1DataRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioG1DataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n    #endif //End of MW_PIL_TIC2000_CONCERTO\n    EDIS;\n}\n#endif // End of MW_F2804X\n\n/*Set the peripheral muxing for the specified pin.\n * The appropriate parameters can be found in the GPIO Muxed Pins table.\n * Use the GPIO index row (0 to 4) to select a muxing option for the GPIO.*/\nvoid GPIO_SetupPinMux(Uint16 pin, Uint16 cpu, Uint16 peripheral)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux;\n    Uint16 pin32, pin16;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Sanity check for valid peripheral values*/\n    if (peripheral > 0x4)\n    {\n        return;\n    }\n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    \n    //Now for the actual function\n    EALLOW;\n    \n    /* Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some tricky\n     * bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *mux |= (Uint32)(peripheral & 0x3UL) << (2*pin16);\n    \n    //WARNING: This code does not touch the analog mode select registers,\n    //which are needed to give the USB module control of its IOs.\n    EDIS;\n}\n\n/*Setup up the GPIO input/output options for the specified pin.\n * The flags are a 16-bit mask produced by ORing together options.\n * For input pins, the valid flags are:\n * GPIO_PULLUP    Enable pull-up\n * GPIO_SYNC        Synchronize the input latch to PLLSYSCLK (default -- you don't need to specify this)\n * GPIO_QUAL3    Use 3-sample qualification\n * GPIO_QUAL6    Use 6-sample qualification\n * GPIO_ASYNC    Do not use synchronization or qualification\n * (Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n * For output pins, the valid flags are:\n * GPIO_PULLUP        If open drain enabled, also enable the pull-up\n * and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n * With no flags, the default input state is synchronous with no pull-up or polarity inversion.\n * The default output state is the standard digital output.*/\nvoid GPIO_SetupPinOptions(Uint16 pin, Uint16 output, Uint16 flags)\n{\n    {\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    pinMask = 1UL << pin32;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-2. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n    \n    EALLOW;\n    \n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1U)\n    {\n        /*Output, with optional open drain mode and pull-up*/\n        *dir |= pinMask;\n        \n        /*Enable pull-up if necessary. Open drain mode must be active.*/\n        if (flags & GPIO_PULLUP){\n            *pud &= ~pinMask;\n        }\n        else{\n            *pud |= pinMask;\n        }\n    } else\n    {\n        /*Input, with optional pull-up, qualification, and polarity inversion*/\n        *dir &= ~pinMask;\n        \n        /*Enable pull-up if necessary*/\n        if (flags & GPIO_PULLUP){\n            *pud &= ~pinMask;\n        }\n        else{\n            *pud |= pinMask;\n        }\n    }\n    \n    /*Extract the qualification parameter and load it into the register. This is\n     * also needed for open drain outputs, so we might as well do it all the time.*/\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0){\n        *qsel |= qual << (2 * pin16);\n    }\n    \n    EDIS;\n    }\n}\n\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0U){        \n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else{\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    \n    gpioDataReg[GPYTOGGLE] = pinMask;\n\n}\n\n#else // for F2837X_REG_FORMAT\n#if defined(MW_F2838X) \n#if defined(CPU1)\n\nvoid InitGpio(void)\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n\n    /*Disable pin locks*/\n    EALLOW;\n    GpioCtrlRegs.GPALOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPBLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPCLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPDLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPELOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPFLOCK.all = 0x00000000U;\n\n    /* Fill all registers with zeros. Writing to each register separately\n     * for six GPIO modules would make this function *very* long.\n     * Fortunately, we'd be writing them all with zeros anyway, so this\n     * saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /* Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x40/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n\n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n\n    EDIS;\n}\n\nvoid GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux, *gmux, *csel;\n    Uint16 pin32, pin16, pin8;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pin8 = gpioNumber % 8;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /*Sanity check for valid cpu and peripheral values*/\n    if (cpu > GPIO_MUX_CM || muxPosition > 0xF)\n        return;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n    csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n    /* Now for the actual function */\n    EALLOW;\n\n    /* To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n     * glitches, then change the group mux, then set the peripheral mux to\n     * its target value. Finally, set the CPU select. This procedure is\n     * described in the TRM. Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some\n     * tricky bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *gmux &= ~(0x3UL << (2*pin16));\n    *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n    *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n    *csel &= ~(0x7L << (4*pin8));\n    *csel |= (Uint32)(cpu & 0x7L) << (4*pin8);\n\n    /* WARNING: This code does not touch the analog mode select registers,\n     * which are needed to give the USB module control of its IOs.*/\n    EDIS;\n}\n\nvoid GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pinMask = 1UL << pin32;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    inv = gpioBaseAddr + GPYINV;\n    odr = gpioBaseAddr + GPYODR;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n    EALLOW;\n\n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {        \n        /* Output, with optional open drain mode and pull-up */        \n        *dir |= pinMask;\n\n        /* Enable open drain if necessary */\n        if (flags & GPIO_OPENDRAIN)\n        {\n            *odr |= pinMask;\n        }\n        else\n        {\n            *odr &= ~pinMask;\n        }\n\n        /* Enable pull-up if necessary. Open drain mode must be active. */\n        if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n    }\n    else\n    {\n        /* Input, with optional pull-up, qualification, and polarity\n         * inversion */\n        *dir &= ~pinMask;\n\n        /* Enable pull-up if necessary */\n        if (flags & GPIO_PULLUP)\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n\n        /* Invert polarity if necessary */\n        if (flags & GPIO_INVERT)\n        {\n            *inv |= pinMask;\n        }\n        else\n        {\n            *inv &= ~pinMask;\n        }\n    }\n\n    /* Extract the qualification parameter and load it into the register.\n     * This is also needed for open drain outputs, so we might as well do it\n     * all the time. */\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n    {\n        *qsel |= qual << (2 * pin16);\n    }\n\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor176Pin(void)\n{\n\tEALLOW;\n\tGpioCtrlRegs.GPCPUD.all = ~0x80000000U;  /* GPIO 95 */\n\tGpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7U;  /* GPIOs 96-127 */\n\tGpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDFU;  /* GPIOs 128-159 except for 133 */\n\tGpioCtrlRegs.GPFPUD.all = ~0x000001FFU;  /* GPIOs 160-168 */\n\tEDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor100Pin(void)\n{\n    EALLOW;\n    GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3U;  //GPIOs 0-1, 5-9, 22-31\n    GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FFU;  //GPIOs 32-40, 44-57\n    GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18U;  //GPIOs 67-68, 74-77, 79-83, 93-95\n    GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7U;  //GPIOs 96-127\n    GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFFU;  //GPIOs 128-159\n    GpioCtrlRegs.GPFPUD.all = ~0x000001FFU;  //GPIOs 160-168\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullups(void)\n{\n\t/* bits 8-10 have pin count */\n    unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700U) >> 8U) ;\n\n\t/* 5 = 100 pin\n\t * 6 = 176 pin\n\t * 7 = 337 pin */\n    if(pin_count == 5)\n    {\n        GPIO_EnableUnbondedIOPullupsFor100Pin();\n    }\n    else if (pin_count == 6)\n\t{\n\t\tGPIO_EnableUnbondedIOPullupsFor176Pin();\n\t}\n\telse\n\t{\n\t\t/* do nothing - this is 337 pin package */\n\t}\n}\n#endif // defined(CPU1)\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1U;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0U)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n#endif // end of defined(MW_F2838X)\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + ((pin/32)*GPY_DATA_OFFSET);\n    Uint32 temp = (1UL << (pin % 32U));\n    pinMask = (Uint32)temp;\n    gpioDataReg[GPYTOGGLE] = pinMask;\n}\n#endif // end of F2837X_REG_FORMAT\n\n/*Set the GPIO pin. Set the mux values and pin options for the specified pin.\n  This function can be used for all processors except C281x. The implementation is dependant on CPU1 and CPU2*/ \nvoid Set_GPIOPin(Uint16 pin, Uint16 cpu, Uint16 peripheral, Uint16 output, Uint16 flags)\n{\n#if defined(F2837X_REG_FORMAT) && defined(CPU2)\n    Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n    Uint32 gpioData = 0x00000000;\n    //Sanity check for valid cpu and peripheral values\n    #ifdef MW_F28P65X\n        if (peripheral > 0xFU)\n            return;\n    #else\n        if (cpu > GPIO_MUX_CPU2CLA || peripheral > 0xFU)\n            return;\n    #endif\n    gpioData = gpioData | pin;\n    gpioData = gpioData | ((Uint32)peripheral << 8U);\n    gpioData = gpioData | ((Uint32)output << 16U);\n    gpioData = gpioData | ((Uint32)flags << 24U);\n    #ifdef MW_F2837XD\n    Uint32 ulRWord32 = 0;\n    IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n    while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n            IPC_FLAG31) != STATUS_PASS)\n    {\n    }\n    #else\n     MW_IPC_sendCommand(IPC_CPU2_L_CPU1_R, (IPC_FLAG0 | IPC_FLAG31), IPC_ADDR_CORRECTION_DISABLE, IPC_FUNC_CALL, pulMsgRam[0], gpioData);\n    IPC_waitForAck(IPC_CPU2_L_CPU1_R, IPC_FLAG31);\n    IPC_getResponse(IPC_CPU2_L_CPU1_R);\n    #endif //MW_F2837XD\n#else\n    GPIO_SetupPinMux(pin, cpu, peripheral);\n    GPIO_SetupPinOptions(pin, output, flags);\n#endif // end of defined(F2837X_REG_FORMAT) && defined(CPU2)\n}\n#endif //end of MW_F281X\n    \n"},{"name":"MW_c28xGlobalInterrupts.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGlobalInterrupts.c\n * TITLE: Common board support functions specific for C2000 targets\n * Copyright 2020-2022 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n#include \"MW_target_hardware_resources.h\"\n\n/* ***************************************************************************/\n/* the globals */\nvolatile int16_T MW_InterruptDisableLock = 0;\n\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* Global interrupt enable function */\nvoid globalInterruptEnable(void)\n{\n    if (0 == MW_InterruptDisableLock)\n    {\n        /* Enabled the interrupts only if it was enabled before */\n        __enable_interrupts(); /* Enable Global Interrupt INTM and realtime interrupt DBGM */\n    }\n    --MW_InterruptDisableLock;\n    if (0 > MW_InterruptDisableLock)\n    {\n        MW_InterruptDisableLock = 0;\n    }\n}\n\n/* Global interrupt disable function */\nvoid globalInterruptDisable(void)\n{\n    /* Disable Global Interrupt INTM using __disable_interrupts()\n     The function will return 0 if interrupt was enabled previously\n     otherwise it will return 1 if the interrupt was previously disabled*/\n    MW_InterruptDisableLock += ((__disable_interrupts()) & 0x01);\n}\n"},{"name":"MW_c28xx_adc.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"pwm.h\"\r\n#include \"pwm_private.h\"\r\n\r\nvoid config_ADCB_SOC3(void)\r\n{\r\n  EALLOW;\r\n  AdcbRegs.ADCSOC3CTL.bit.CHSEL = 3U;  /* Set SOC3 channel select to ADCIN3*/\r\n  AdcbRegs.ADCSOC3CTL.bit.TRIGSEL = 0U;\r\n  AdcbRegs.ADCSOC3CTL.bit.ACQPS = (uint16_T)14.0;\r\n                               /* Set SOC3 S/H Window to 15.0 ADC Clock Cycles*/\r\n  AdcbRegs.ADCINTSOCSEL1.bit.SOC3 = 0U;\r\n                                   /* SOCx No ADCINT Interrupt Trigger Select.*/\r\n  AdcbRegs.ADCOFFTRIM.bit.OFFTRIM = (uint16_T)AdcbRegs.ADCOFFTRIM.bit.OFFTRIM;/* Set Offset Error Correctino Value*/\r\n  AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1U;\r\n                                /* Late interrupt pulse trips AdcResults latch*/\r\n  AdcbRegs.ADCSOCPRICTL.bit.SOCPRIORITY = 0U;/* All in round robin mode SOC Priority*/\r\n  EDIS;\r\n}\r\n\r\nvoid InitAdcB(void)\r\n{\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_B = 1U;\r\n  AdcbRegs.ADCCTL2.bit.PRESCALE = 8U;\r\n  AdcSetMode((uint16_T)ADC_ADCB, (uint16_T)ADC_RESOLUTION_12BIT,(uint16_T)\r\n             ADC_SIGNALMODE_SINGLE);\r\n\r\n  //power up the ADC\r\n  AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1U;\r\n\r\n  //delay for 1ms to allow ADC time to power up\r\n  DELAY_US(1000);\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_board.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"pwm.h\"\r\n#include \"pwm_private.h\"\r\n\r\nvoid init_board (void)\r\n{\r\n  DisableDog();\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR0.bit.DMA = 1U;\r\n  CpuSysRegs.PCLKCR6.bit.SD1 = 1U;\r\n  CpuSysRegs.PCLKCR6.bit.SD2 = 1U;\r\n  EDIS;\r\n\r\n#ifdef CPU1\r\n\r\n  EALLOW;\r\n\r\n  //enable pull-ups on unbonded IOs as soon as possible to reduce power consumption.\r\n  GPIO_EnableUnbondedIOPullups();\r\n  CpuSysRegs.PCLKCR13.bit.ADC_A = 1U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_B = 1U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_C = 1U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_D = 1U;\r\n\r\n  //check if device is trimmed\r\n  if (*((Uint16 *)0x5D1B6) == 0x0000U) {\r\n    //device is not trimmed, apply static calibration values\r\n    AnalogSubsysRegs.ANAREFTRIMA.all = 31709U;\r\n    AnalogSubsysRegs.ANAREFTRIMB.all = 31709U;\r\n    AnalogSubsysRegs.ANAREFTRIMC.all = 31709U;\r\n    AnalogSubsysRegs.ANAREFTRIMD.all = 31709U;\r\n  }\r\n\r\n  CpuSysRegs.PCLKCR13.bit.ADC_A = 0U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_B = 0U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_C = 0U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_D = 0U;\r\n  EDIS;\r\n  InitSysPll(XTAL_OSC,40,0,1);\r\n\r\n  //Turn on all peripherals\r\n  //InitPeripheralClocks();\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1U;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1U;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1U;\r\n  CpuSysRegs.PCLKCR0.bit.HRPWM = 1U;\r\n  CpuSysRegs.PCLKCR1.bit.EMIF1 = 1U;\r\n  CpuSysRegs.PCLKCR1.bit.EMIF2 = 1U;\r\n\r\n  /* Assign all Peripherals to CPU2 */\r\n  DevCfgRegs.CPUSEL11.all = 0x0000000FU;\r\n  DevCfgRegs.CPUSEL5.all = 0x0000000FU;\r\n  DevCfgRegs.CPUSEL8.all = 0x00000003U;\r\n  DevCfgRegs.CPUSEL14.all = 0x00070000U;\r\n  DevCfgRegs.CPUSEL7.all = 0x00000003U;\r\n  DevCfgRegs.CPUSEL0.all = 0x00000FFFU;\r\n  DevCfgRegs.CPUSEL1.all = 0x0000003FU;\r\n  DevCfgRegs.CPUSEL2.all = 0x00000007U;\r\n  DevCfgRegs.CPUSEL4.all = 0x00000003U;\r\n  DevCfgRegs.CPUSEL6.all = 0x00000007U;\r\n  DevCfgRegs.CPUSEL12.all = 0x000000FFU;\r\n  EDIS;\r\n\r\n#endif                                 // #ifdef CPU1\r\n\r\n  EALLOW;\r\n\r\n  /* Configure low speed peripheral clocks */\r\n  ClkCfgRegs.LOSPCP.bit.LSPCLKDIV = 0U;\r\n  EDIS;\r\n\r\n  /* Disable and clear all CPU interrupts */\r\n  DINT;\r\n  IER = 0x0000U;\r\n  IFR = 0x0000U;\r\n  InitPieCtrl();\r\n  InitPieVectTable();\r\n  initSetGPIOIPC();\r\n  InitCpuTimers();\r\n\r\n#ifdef CPU1\r\n\r\n  EALLOW;\r\n\r\n  /* Assign used ADC modules to CPU1 */\r\n  DevCfgRegs.CPUSEL11.bit.ADC_B = 0U;\r\n\r\n#ifdef MW_DAC_CHANNEL_A\r\n\r\n  DevCfgRegs.CPUSEL14.bit.DAC_A = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_DAC_CHANNEL_B\r\n\r\n  DevCfgRegs.CPUSEL14.bit.DAC_B = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_DAC_CHANNEL_C\r\n\r\n  DevCfgRegs.CPUSEL14.bit.DAC_C = 0U;\r\n\r\n#endif\r\n\r\n  /* Assign SDFM modules to CPU1 */\r\n#ifdef MW_SDFM_1\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD1 = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SDFM_2\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD2 = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SDFM_3\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD3 = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SDFM_4\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD4 = 0U;\r\n\r\n#endif\r\n\r\n  /* Assign used PWM modules to CPU1 */\r\n  DevCfgRegs.CPUSEL0.bit.EPWM1 = 0U;\r\n  DevCfgRegs.CPUSEL0.bit.EPWM2 = 0U;\r\n\r\n  /* Assign used SPI modules to CPU1 */\r\n#ifdef MW_SPI_A\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_A = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SPI_B\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_B = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SPI_C\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_C = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SPI_D\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_D = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS1_COMPH || defined MW_CMPSS1_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS1 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS2_COMPH || defined MW_CMPSS2_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS2 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS3_COMPH || defined MW_CMPSS3_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS3 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS4_COMPH || defined MW_CMPSS4_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS4 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS5_COMPH || defined MW_CMPSS5_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS5 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS6_COMPH || defined MW_CMPSS6_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS6 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS7_COMPH || defined MW_CMPSS7_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS7 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS8_COMPH || defined MW_CMPSS8_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS8 = 0U;\r\n\r\n#endif\r\n\r\n  EDIS;\r\n\r\n#endif                                 // #ifdef CPU1\r\n\r\n  /* initial ePWM GPIO assignment... */\r\n  config_ePWM_GPIO();\r\n  EALLOW;\r\n\r\n  /* Enable clock to ePWM */\r\n  CpuSysRegs.PCLKCR2.bit.EPWM1 = 1U;\r\n  CpuSysRegs.PCLKCR2.bit.EPWM2 = 1U;\r\n\r\n  /* Disable TBCLK within ePWM before module configuration */\r\n  CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0U;\r\n  EDIS;\r\n  config_ePWMSyncSource();\r\n  configureIXbar();\r\n\r\n#ifdef CPU1\r\n\r\n  /* initial GPIO qualification settings.... */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPAQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPBQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPBQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPCQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPCQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPDQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPDQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPEQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPEQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPFQSEL1.all = 0x0U;\r\n  EDIS;\r\n\r\n#endif                                 // #ifdef CPU1\r\n\r\n}\r\n"},{"name":"MW_c28xx_csl.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"pwm.h\"\r\n#include \"pwm_private.h\"\r\n\r\nvoid enableExtInterrupt (void);\r\nvoid configureGPIOExtInterrupt(void);\r\n\r\n#include <stdint.h>\r\n\r\nvoid disableWatchdog(void)\r\n{\r\n  int *WatchdogWDCR = (int *)(uintptr_t)0x7029;\r\n  asm(\" EALLOW \");\r\n  *WatchdogWDCR = 0x0068;\r\n  asm(\" EDIS \");\r\n}\r\n"},{"name":"MW_c28xx_pie.h","type":"header","group":"other","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __MW_C28XX_PIE_H__\r\n#define __MW_C28XX_PIE_H__\r\n#define PIEMASK0                       64\r\n#define IFRMASK                        1\r\n#endif                                 /* MW_C28XX_PIE_H */\r\n"},{"name":"MW_c28xx_pwm.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"pwm.h\"\r\n#include \"pwm_private.h\"\r\n\r\nvoid config_ePWM_GPIO (void)\r\n{\r\n  EALLOW;\r\n  ClkCfgRegs.PERCLKDIVSEL.bit.EPWMCLKDIV = 1U;\r\n\r\n  /*-- Configure pin assignments for ePWM1 --*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO0 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1U; /* Configure GPIOGPIO0 as EPWM1A*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO1 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1U; /* Configure GPIOGPIO1 as EPWM1B*/\r\n\r\n  /*-- Configure pin assignments for ePWM2 --*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO2 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1U; /* Configure GPIOGPIO2 as EPWM2A*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO3 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1U; /* Configure GPIOGPIO3 as EPWM2B*/\r\n  EDIS;\r\n}\r\n\r\nvoid config_ePWM_TBSync (void)\r\n{\r\n  /* Enable TBCLK within the EPWM*/\r\n  EALLOW;\r\n\r\n  /* Enable TBCLK after the ePWM configurations */\r\n  CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1U;\r\n  EDIS;\r\n}\r\n\r\nvoid config_ePWMSyncSource (void)\r\n{\r\n  /* Configuring EXTSYNCOUT source selection */\r\n  EALLOW;\r\n  SyncSocRegs.SYNCSELECT.bit.SYNCOUT = 0U;\r\n\r\n  /* Configuring ePWM Sync in source selection */\r\n  SyncSocRegs.SYNCSELECT.bit.EPWM4SYNCIN = 0U;\r\n  SyncSocRegs.SYNCSELECT.bit.EPWM7SYNCIN = 0U;\r\n  SyncSocRegs.SYNCSELECT.bit.EPWM10SYNCIN = 0U;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_xbar.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"pwm.h\"\r\n#include \"pwm_private.h\"\r\n#include \"MW_c28xGPIO.h\"\r\n\r\nvoid configureIXbar(void)\r\n{\r\n  /*--- Configuring GPIO set in Input Xbar---*/\r\n  EALLOW;\r\n  InputXbarRegs.INPUT5SELECT = 0;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"c2000BoardSupport.h\"\n#include \"MW_f2837xD_includes.h\"\n#include \"c2000SchedulerTimer.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE TI Delfino F28379D LaunchPad\n#define MW_CONNECTIONINFO_SERIAL_IPADDRESS codertarget.registry.getLoopbackIP;\n#define MW_CONNECTIONINFO_SERIAL_PORT 17725\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_CAN_MEXARGS  \n#define MW_CONNECTIONINFO_XCPONCAN_MEXARGS  \n#define MW_CONNECTIONINFO_XCPONCAN_BUSSPEED codertarget.registry.getExtModeCANBusSpeed(hCS)\n#define MW_CONNECTIONINFO_XCPONCAN_CANCHANNEL \n#define MW_CONNECTIONINFO_XCPONCAN_CANDEVICE \n#define MW_CONNECTIONINFO_XCPONCAN_CANIDCOMMAND 2\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDRESPONSE 3\n#define MW_CONNECTIONINFO_XCPONCAN_CANVENDOR \n#define MW_CONNECTIONINFO_XCPONCAN_ISCANIDEXTENDED 0\n#define MW_CONNECTIONINFO_XCPONCAN_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.registry.getExtModeHostBaud(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.registry.serialPortValueCallback(hCS, 'ExtModeCOMPort');\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_HOSTINTERFACE Simulink\n#define MW_EXTMODE_CANMODULE 0\n#define MW_EXTMODE_CANIDTYPE Standard (11-bit)\n#define MW_EXTMODE_CANMASTERID 0x02\n#define MW_EXTMODE_CANSLAVEID 0x03\n#define MW_EXTMODE_CANRXMAILBOXNUMBER 0\n#define MW_EXTMODE_CANTXMAILBOXNUMBER 1\n#define MW_EXTMODE_SCIMODULE 0\n#define MW_EXTMODE_SIGNALBUFFERSIZE 1000000.000000\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DEVICEID 0\n#define MW_RUNTIME_FLASHLOAD 1\n#define MW_RUNTIME_CPU CPU1\n#define MW_RUNTIME_LOADCOMMANDARG $(TARGET_ROOT)/CCS_Config/f28379D.ccxml\n#define MW_RUNTIME_CPU2MODELENABLE 102 97108115101\n#define MW_RUNTIME_CPU2MODEL \n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_ENABLETMU 1\n#define MW_RUNTIME_PF1DMAACCESS 0\n#define MW_RUNTIME_PF2DMAACCESS 0\n#define MW_TARGETLINKOBJ_USECUSTOMLINKER 0\n#define MW_TARGETLINKOBJ_NAME $(TARGET_ROOT)/src/c28377D.cmd\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 200\n#define MW_CLOCKING_USEINTERNALOSC 0\n#define MW_CLOCKING_OSCCLK 10\n#define MW_CLOCKING_AUTOSETPLLSETTINGS 1\n#define MW_CLOCKING_PLLCR 40\n#define MW_CLOCKING_DIVSEL 2\n#define MW_CLOCKING_CLOSESTCPUCLOCK 200\n#define MW_CLOCKING_LSPCLKDIV 0\n#define MW_CLOCKING_LSPCLK 200\n#define MW_CLOCKING_CLOSESTCPUCLOCK1 200\n#define MW_CLOCKING_LSPCLKDIV1 0\n#define MW_ADCA_CPUCORE 0\n#define MW_ADCA_CLOCKDIV 7\n#define MW_ADCA_CLOCKFREQUENCY 40.000000\n#define MW_ADCA_OFFSETCORRECTIONVALUE AdcaRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCA_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCA_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCA_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCA_INTPULSEGENERATION 0\n#define MW_ADCA_SOCPRIORITY 0\n#define MW_ADCA_XINT2GPIO GPIO0\n#define MW_ADCA_XINT2GPIO_IXBAR 0\n#define MW_ADCB_CPUCORE 0\n#define MW_ADCB_CLOCKDIV 7\n#define MW_ADCB_CLOCKFREQUENCY 40.000000\n#define MW_ADCB_OFFSETCORRECTIONVALUE AdcbRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCB_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCB_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCB_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCB_INTPULSEGENERATION 0\n#define MW_ADCB_SOCPRIORITY 0\n#define MW_ADCB_XINT2GPIO GPIO0\n#define MW_ADCB_XINT2GPIO_IXBAR 0\n#define MW_ADCC_CPUCORE 0\n#define MW_ADCC_CLOCKDIV 7\n#define MW_ADCC_CLOCKFREQUENCY 40.000000\n#define MW_ADCC_OFFSETCORRECTIONVALUE AdccRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCC_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCC_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCC_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCC_INTPULSEGENERATION 0\n#define MW_ADCC_SOCPRIORITY 0\n#define MW_ADCC_XINT2GPIO GPIO0\n#define MW_ADCC_XINT2GPIO_IXBAR 0\n#define MW_ADCD_CPUCORE 0\n#define MW_ADCD_CLOCKDIV 7\n#define MW_ADCD_CLOCKFREQUENCY 40.000000\n#define MW_ADCD_OFFSETCORRECTIONVALUE AdcdRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCD_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCD_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCD_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCD_INTPULSEGENERATION 0\n#define MW_ADCD_SOCPRIORITY 0\n#define MW_ADCD_XINT2GPIO GPIO0\n#define MW_ADCD_XINT2GPIO_IXBAR 0\n#define MW_DACA_VOLTAGE 0\n#define MW_DACA_LOADMODE 0\n#define MW_DACB_VOLTAGE 0\n#define MW_DACB_LOADMODE 0\n#define MW_DACC_VOLTAGE 0\n#define MW_DACC_LOADMODE 0\n#define MW_EPWM_CLOCKDIV 1\n#define MW_EPWM_PINASSIGNMENT_TZ1 None\n#define MW_EPWM_PINASSIGNMENT_TZ2 None\n#define MW_EPWM_PINASSIGNMENT_TZ3 None\n#define MW_EPWM_PINASSIGNMENT_SYNCI GPIO0\n#define MW_EPWM_PINASSIGNMENT_SYNCO None\n#define MW_EPWM_PINASSIGNMENT_PWM1A 1\n#define MW_EPWM_PINASSIGNMENT_PWM1B 1\n#define MW_EPWM_PINASSIGNMENT_PWM2A 1\n#define MW_EPWM_PINASSIGNMENT_PWM2B 1\n#define MW_EPWM_PINASSIGNMENT_PWM3A 1\n#define MW_EPWM_PINASSIGNMENT_PWM3B 1\n#define MW_EPWM_PINASSIGNMENT_PWM4A 1\n#define MW_EPWM_PINASSIGNMENT_PWM4B 1\n#define MW_EPWM_PINASSIGNMENT_PWM5A 1\n#define MW_EPWM_PINASSIGNMENT_PWM5B 1\n#define MW_EPWM_PINASSIGNMENT_PWM6A 1\n#define MW_EPWM_PINASSIGNMENT_PWM6B 1\n#define MW_EPWM_PINASSIGNMENT_PWM7A 2\n#define MW_EPWM_PINASSIGNMENT_PWM7B 2\n#define MW_EPWM_PINASSIGNMENT_PWM8A 2\n#define MW_EPWM_PINASSIGNMENT_PWM8B 2\n#define MW_EPWM_PINASSIGNMENT_PWM9A 1\n#define MW_EPWM_PINASSIGNMENT_PWM9B 1\n#define MW_EPWM_PINASSIGNMENT_PWM10A 1\n#define MW_EPWM_PINASSIGNMENT_PWM10B 1\n#define MW_EPWM_PINASSIGNMENT_PWM11A 1\n#define MW_EPWM_PINASSIGNMENT_PWM11B 1\n#define MW_EPWM_PINASSIGNMENT_PWM12A 1\n#define MW_EPWM_PINASSIGNMENT_PWM12B 1\n#define MW_EPWM_CLOCKDIV1 1\n#define MW_EPWM_PINASSIGNMENT_TZ1_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ2_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ3_IXBAR 0\n#define MW_EPWM_EXBAR_TRIP4 0\n#define MW_EPWM_EXBAR_MUX_TRIP4 -1\n#define MW_EPWM_EXBAR_TRIP4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP4_INVERT 0\n#define MW_EPWM_EXBAR_TRIP5 0\n#define MW_EPWM_EXBAR_MUX_TRIP5 -1\n#define MW_EPWM_EXBAR_TRIP5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP5_INVERT 0\n#define MW_EPWM_EXBAR_TRIP7 0\n#define MW_EPWM_EXBAR_MUX_TRIP7 -1\n#define MW_EPWM_EXBAR_TRIP7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP7_INVERT 0\n#define MW_EPWM_EXBAR_TRIP8 0\n#define MW_EPWM_EXBAR_MUX_TRIP8 -1\n#define MW_EPWM_EXBAR_TRIP8_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP8_INVERT 0\n#define MW_EPWM_EXBAR_TRIP9 0\n#define MW_EPWM_EXBAR_MUX_TRIP9 -1\n#define MW_EPWM_EXBAR_TRIP9_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP9_INVERT 0\n#define MW_EPWM_EXBAR_TRIP10 0\n#define MW_EPWM_EXBAR_MUX_TRIP10 -1\n#define MW_EPWM_EXBAR_TRIP10_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP10_INVERT 0\n#define MW_EPWM_EXBAR_TRIP11 0\n#define MW_EPWM_EXBAR_MUX_TRIP11 -1\n#define MW_EPWM_EXBAR_TRIP11_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP11_INVERT 0\n#define MW_EPWM_EXBAR_TRIP12 0\n#define MW_EPWM_EXBAR_MUX_TRIP12 -1\n#define MW_EPWM_EXBAR_TRIP12_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP12_INVERT 0\n#define MW_EPWM_PINASSIGNMENT_SYNCI_IXBAR 0\n#define MW_EPWM_SYNCSEL_SYNCOUT 0\n#define MW_EPWM_SYNCSEL_EPWM4SYNCIN 0\n#define MW_EPWM_SYNCSEL_EPWM7SYNCIN 0\n#define MW_EPWM_SYNCSEL_EPWM10SYNCIN 0\n#define MW_ECAP_PINASSIGNMENT_ECAP1 GPIO20\n#define MW_ECAP_PINASSIGNMENT_ECAP2 GPIO21\n#define MW_ECAP_PINASSIGNMENT_ECAP3 GPIO99\n#define MW_ECAP_PINASSIGNMENT_ECAP4 GPIO54\n#define MW_ECAP_PINASSIGNMENT_ECAP5 GPIO55\n#define MW_ECAP_PINASSIGNMENT_ECAP6 GPIO57\n#define MW_ECAP_PINASSIGNMENT_APWM1 13\n#define MW_ECAP_PINASSIGNMENT_APWM2 14\n#define MW_ECAP_PINASSIGNMENT_APWM3 15\n#define MW_ECAP_PINASSIGNMENT_APWM4 16\n#define MW_ECAP_PINASSIGNMENT_APWM5 17\n#define MW_ECAP_PINASSIGNMENT_APWM6 18\n#define MW_ECAP_PINASSIGNMENT_ECAP1_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP2_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP3_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP4_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP5_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP6_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_APWM1_OXBAR 1.000000\n#define MW_ECAP_PINASSIGNMENT_APWM2_OXBAR 2.000000\n#define MW_ECAP_PINASSIGNMENT_APWM3_OXBAR 3.000000\n#define MW_ECAP_PINASSIGNMENT_APWM4_OXBAR 4.000000\n#define MW_ECAP_PINASSIGNMENT_APWM5_OXBAR 5.000000\n#define MW_ECAP_PINASSIGNMENT_APWM6_OXBAR 6.000000\n#define MW_ECAP_SYNCSEL_ECAP1SYNCIN 0\n#define MW_ECAP_SYNCSEL_ECAP4SYNCIN 0\n#define MW_EQEP_PINASSIGNMENT_EQEP1A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP1B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP1S 0\n#define MW_EQEP_PINASSIGNMENT_EQEP1I 4\n#define MW_EQEP_PINASSIGNMENT_EQEP2A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2S 0\n#define MW_EQEP_PINASSIGNMENT_EQEP2I 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3S 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3I 2\n#define MW_I2C_MODE 0\n#define MW_I2C_ADDRDATAFORMAT 0\n#define MW_I2C_OWNADDRESS 1\n#define MW_I2C_BITCOUNT 0\n#define MW_I2C_MODULECLOCKPRESCALER 9\n#define MW_I2C_MODULECLOCKFREQUENCY 20000000\n#define MW_I2C_MASTERCLKLOWTIME 20\n#define MW_I2C_MASTERCLKHIGHTIME 20\n#define MW_I2C_MASTERCLOCKFREQUENCY 400000\n#define MW_I2C_MASTERCLOCKFREQUENCY_1 400000\n#define MW_I2C_MASTERCLOCKFREQUENCY_2 400000\n#define MW_I2C_ENABLELOOPBACK 0\n#define MW_I2C_PINASSIGNMENT_SDAA 4\n#define MW_I2C_PINASSIGNMENT_SCLA 4\n#define MW_I2C_ENABLETXINT 0\n#define MW_I2C_TXFIFOLEVEL 16\n#define MW_I2C_ENABLERXINT 0\n#define MW_I2C_RXFIFOLEVEL 16\n#define MW_I2C_ENABLESYSINT 0\n#define MW_I2C_AAS 0\n#define MW_I2C_SCD 0\n#define MW_I2C_ARDY 0\n#define MW_I2C_NACK 0\n#define MW_I2C_AL 0\n#define MW_I2C_PINVALUE_SDA 104\n#define MW_I2C_PINVALUE_SCL 105\n#define MW_I2C_PINMUX_SDA 1\n#define MW_I2C_PINMUX_SCL 1\n#define MW_I2C_B_MODE 0\n#define MW_I2C_B_ADDRDATAFORMAT 0\n#define MW_I2C_B_OWNADDRESS 1\n#define MW_I2C_B_BITCOUNT 0\n#define MW_I2C_B_MODULECLOCKPRESCALER 9\n#define MW_I2C_B_MODULECLOCKFREQUENCY 20000000\n#define MW_I2C_B_MASTERCLKLOWTIME 20\n#define MW_I2C_B_MASTERCLKHIGHTIME 20\n#define MW_I2C_B_MASTERCLOCKFREQUENCY 400000\n#define MW_I2C_B_MASTERCLOCKFREQUENCY_1 400000\n#define MW_I2C_B_MASTERCLOCKFREQUENCY_2 400000\n#define MW_I2C_B_ENABLELOOPBACK 0\n#define MW_I2C_B_PINASSIGNMENT_SDAA 2\n#define MW_I2C_B_PINASSIGNMENT_SCLA 2\n#define MW_I2C_B_ENABLETXINT 0\n#define MW_I2C_B_TXFIFOLEVEL 16\n#define MW_I2C_B_ENABLERXINT 0\n#define MW_I2C_B_RXFIFOLEVEL 16\n#define MW_I2C_B_ENABLESYSINT 0\n#define MW_I2C_B_AAS 0\n#define MW_I2C_B_SCD 0\n#define MW_I2C_B_ARDY 0\n#define MW_I2C_B_NACK 0\n#define MW_I2C_B_AL 0\n#define MW_I2C_B_PINVALUE_SDA 40\n#define MW_I2C_B_PINVALUE_SCL 41\n#define MW_I2C_B_PINMUX_SDA 6\n#define MW_I2C_B_PINMUX_SCL 6\n#define MW_SCI_A_ENABLELOOPBACK 0\n#define MW_SCI_A_SUSPENSIONMODE 2\n#define MW_SCI_A_NUMBEROFSTOPBITS 0\n#define MW_SCI_A_PARITYMODE 0\n#define MW_SCI_A_CHARACTERLENGTHBITS 0\n#define MW_SCI_A_USERBAUDRATE 5e6\n#define MW_SCI_A_BAUDRATEPRESCALER 4.000000\n#define MW_SCI_A_BAUDRATE 5000000.000000\n#define MW_SCI_A_COMMUNICATIONMODE 0\n#define MW_SCI_A_BLOCKINGMODE 0\n#define MW_SCI_A_DATABYTEORDER 0\n#define MW_SCI_A_DATASWAPWIDTH 0\n#define MW_SCI_A_PINASSIGNMENT_TX 4\n#define MW_SCI_A_PINASSIGNMENT_RX 4\n#define MW_SCI_A_ENABLEINTERRUPTTX 0\n#define MW_SCI_A_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_A_ENABLEINTERRUPTRX 0\n#define MW_SCI_A_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_B_ENABLELOOPBACK 0\n#define MW_SCI_B_SUSPENSIONMODE 2\n#define MW_SCI_B_NUMBEROFSTOPBITS 0\n#define MW_SCI_B_PARITYMODE 0\n#define MW_SCI_B_CHARACTERLENGTHBITS 0\n#define MW_SCI_B_USERBAUDRATE 115200\n#define MW_SCI_B_BAUDRATEPRESCALER 216.000000\n#define MW_SCI_B_BAUDRATE 115207.000000\n#define MW_SCI_B_COMMUNICATIONMODE 0\n#define MW_SCI_B_BLOCKINGMODE 0\n#define MW_SCI_B_DATABYTEORDER 0\n#define MW_SCI_B_DATASWAPWIDTH 0\n#define MW_SCI_B_PINASSIGNMENT_TX 4\n#define MW_SCI_B_PINASSIGNMENT_RX 3\n#define MW_SCI_B_ENABLEINTERRUPTTX 0\n#define MW_SCI_B_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_B_ENABLEINTERRUPTRX 0\n#define MW_SCI_B_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_C_ENABLELOOPBACK 0\n#define MW_SCI_C_SUSPENSIONMODE 2\n#define MW_SCI_C_NUMBEROFSTOPBITS 0\n#define MW_SCI_C_PARITYMODE 0\n#define MW_SCI_C_CHARACTERLENGTHBITS 0\n#define MW_SCI_C_USERBAUDRATE 115200\n#define MW_SCI_C_BAUDRATEPRESCALER 216.000000\n#define MW_SCI_C_BAUDRATE 115207.000000\n#define MW_SCI_C_COMMUNICATIONMODE 0\n#define MW_SCI_C_BLOCKINGMODE 0\n#define MW_SCI_C_DATABYTEORDER 0\n#define MW_SCI_C_DATASWAPWIDTH 0\n#define MW_SCI_C_PINASSIGNMENT_TX 3\n#define MW_SCI_C_PINASSIGNMENT_RX 8\n#define MW_SCI_C_ENABLEINTERRUPTTX 0\n#define MW_SCI_C_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_C_ENABLEINTERRUPTRX 0\n#define MW_SCI_C_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_D_ENABLELOOPBACK 0\n#define MW_SCI_D_SUSPENSIONMODE 2\n#define MW_SCI_D_NUMBEROFSTOPBITS 0\n#define MW_SCI_D_PARITYMODE 0\n#define MW_SCI_D_CHARACTERLENGTHBITS 0\n#define MW_SCI_D_USERBAUDRATE 115200\n#define MW_SCI_D_BAUDRATEPRESCALER 216.000000\n#define MW_SCI_D_BAUDRATE 115207.000000\n#define MW_SCI_D_COMMUNICATIONMODE 0\n#define MW_SCI_D_BLOCKINGMODE 0\n#define MW_SCI_D_DATABYTEORDER 0\n#define MW_SCI_D_DATASWAPWIDTH 0\n#define MW_SCI_D_PINASSIGNMENT_TX 1\n#define MW_SCI_D_PINASSIGNMENT_RX 1\n#define MW_SCI_D_ENABLEINTERRUPTTX 0\n#define MW_SCI_D_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_D_ENABLEINTERRUPTRX 0\n#define MW_SCI_D_FIFOINTERRUPTLEVELRX 1\n#define MW_SPI_A_MODE 0\n#define MW_SPI_A_USERBAUDRATE 1843200\n#define MW_SPI_A_BAUDRATEFACTOR 108.000000\n#define MW_SPI_A_BAUDRATE 1834862.000000\n#define MW_SPI_A_DATABITS 15\n#define MW_SPI_A_CLOCKPOLARITY 0\n#define MW_SPI_A_CLOCKPHASE 0\n#define MW_SPI_A_SUSPENSIONMODE 2\n#define MW_SPI_A_ENABLELOOPBACK 0\n#define MW_SPI_A_ENABLETHREEWIRE 0\n#define MW_SPI_A_TXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_A_RXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_A_FIFOENABLE 1\n#define MW_SPI_A_FIFOTRANSMITDELAY 0\n#define MW_SPI_A_PINASSIGNMENT_SIMO 3\n#define MW_SPI_A_PINASSIGNMENT_SOMI 3\n#define MW_SPI_A_PINASSIGNMENT_CLK 3\n#define MW_SPI_A_PINASSIGNMENT_STE 3\n#define MW_SPI_A_PINVALUE_SIMO 58\n#define MW_SPI_A_PINVALUE_SOMI 59\n#define MW_SPI_A_PINVALUE_CLK 60\n#define MW_SPI_A_PINVALUE_STE 61\n#define MW_SPI_A_PINMUX_SIMO 15\n#define MW_SPI_A_PINMUX_SOMI 15\n#define MW_SPI_A_PINMUX_CLK 15\n#define MW_SPI_A_PINMUX_STE 15\n#define MW_SPI_A_FIFO_LEVEL 16.000000\n#define MW_SPI_A_ENABLEHIGHSPEEDMODE 1\n#define MW_SPI_B_MODE 0\n#define MW_SPI_B_USERBAUDRATE 1843200\n#define MW_SPI_B_BAUDRATEFACTOR 108.000000\n#define MW_SPI_B_BAUDRATE 1834862.000000\n#define MW_SPI_B_DATABITS 15\n#define MW_SPI_B_CLOCKPOLARITY 0\n#define MW_SPI_B_CLOCKPHASE 0\n#define MW_SPI_B_SUSPENSIONMODE 2\n#define MW_SPI_B_ENABLELOOPBACK 0\n#define MW_SPI_B_ENABLETHREEWIRE 0\n#define MW_SPI_B_TXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_B_RXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_B_FIFOENABLE 1\n#define MW_SPI_B_FIFOTRANSMITDELAY 0\n#define MW_SPI_B_PINASSIGNMENT_SIMO 3\n#define MW_SPI_B_PINASSIGNMENT_SOMI 3\n#define MW_SPI_B_PINASSIGNMENT_CLK 4\n#define MW_SPI_B_PINASSIGNMENT_STE 4\n#define MW_SPI_B_PINVALUE_SIMO 63\n#define MW_SPI_B_PINVALUE_SOMI 64\n#define MW_SPI_B_PINVALUE_CLK 65\n#define MW_SPI_B_PINVALUE_STE 66\n#define MW_SPI_B_PINMUX_SIMO 15\n#define MW_SPI_B_PINMUX_SOMI 15\n#define MW_SPI_B_PINMUX_CLK 15\n#define MW_SPI_B_PINMUX_STE 15\n#define MW_SPI_B_FIFO_LEVEL 16.000000\n#define MW_SPI_B_ENABLEHIGHSPEEDMODE 1\n#define MW_SPI_C_MODE 0\n#define MW_SPI_C_USERBAUDRATE 1843200\n#define MW_SPI_C_BAUDRATEFACTOR 108.000000\n#define MW_SPI_C_BAUDRATE 1834862.000000\n#define MW_SPI_C_DATABITS 15\n#define MW_SPI_C_CLOCKPOLARITY 0\n#define MW_SPI_C_CLOCKPHASE 0\n#define MW_SPI_C_SUSPENSIONMODE 2\n#define MW_SPI_C_ENABLELOOPBACK 0\n#define MW_SPI_C_ENABLETHREEWIRE 0\n#define MW_SPI_C_TXINTERRUPTENABLE 0\n#define MW_SPI_C_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_C_RXINTERRUPTENABLE 0\n#define MW_SPI_C_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_C_FIFOENABLE 1\n#define MW_SPI_C_FIFOTRANSMITDELAY 0\n#define MW_SPI_C_PINASSIGNMENT_SIMO 3\n#define MW_SPI_C_PINASSIGNMENT_SOMI 3\n#define MW_SPI_C_PINASSIGNMENT_CLK 3\n#define MW_SPI_C_PINASSIGNMENT_STE 3\n#define MW_SPI_C_PINVALUE_SIMO 100\n#define MW_SPI_C_PINVALUE_SOMI 101\n#define MW_SPI_C_PINVALUE_CLK 102\n#define MW_SPI_C_PINVALUE_STE 103\n#define MW_SPI_C_PINMUX_SIMO 6\n#define MW_SPI_C_PINMUX_SOMI 6\n#define MW_SPI_C_PINMUX_CLK 6\n#define MW_SPI_C_PINMUX_STE 6\n#define MW_SPI_C_FIFO_LEVEL 16.000000\n#define MW_SPI_C_ENABLEHIGHSPEEDMODE 1\n#define MW_ECAN_A_MODULECLOCKFREQUENCY 200\n#define MW_ECAN_A_BAUDRATEPRESCALER 20.000000\n#define MW_ECAN_A_TSEG1 4\n#define MW_ECAN_A_TSEG2 3\n#define MW_ECAN_A_BAUDRATE 1000000\n#define MW_ECAN_A_SBG 0\n#define MW_ECAN_A_SJW 1\n#define MW_ECAN_A_SAM 0\n#define MW_ECAN_A_ENHANCEDCANMODE 1\n#define MW_ECAN_A_SELFTESTMODE 0\n#define MW_ECAN_A_PINASSIGNMENT_TX 3\n#define MW_ECAN_A_PINASSIGNMENT_RX 3\n#define MW_ECAN_B_MODULECLOCKFREQUENCY 200\n#define MW_ECAN_B_BAUDRATEPRESCALER 20.000000\n#define MW_ECAN_B_TSEG1 4\n#define MW_ECAN_B_TSEG2 3\n#define MW_ECAN_B_BAUDRATE 1000000\n#define MW_ECAN_B_SBG 0\n#define MW_ECAN_B_SJW 1\n#define MW_ECAN_B_SAM 0\n#define MW_ECAN_B_ENHANCEDCANMODE 1\n#define MW_ECAN_B_SELFTESTMODE 0\n#define MW_ECAN_B_PINASSIGNMENT_TX 3\n#define MW_ECAN_B_PINASSIGNMENT_RX 4\n#define MW_WATCHDOG_ENABLE_WATCHDOG 0\n#define MW_WATCHDOG_WATCHDOGCLOCK 0\n#define MW_WATCHDOG_TIME_PERIOD 0.013107\n#define MW_WATCHDOG_WATCHDOGEVENT 0\n#define MW_GPIO0_7_GPIOQUALSEL0 0\n#define MW_GPIO0_7_GPIOQUALSEL1 0\n#define MW_GPIO0_7_GPIOQUALSEL2 0\n#define MW_GPIO0_7_GPIOQUALSEL3 0\n#define MW_GPIO0_7_GPIOQUALSEL4 0\n#define MW_GPIO0_7_GPIOQUALSEL5 0\n#define MW_GPIO0_7_GPIOQUALSEL6 0\n#define MW_GPIO0_7_GPIOQUALSEL7 0\n#define MW_GPIO0_7_QUALPRD 0\n#define MW_GPIO8_15_GPIOQUALSEL8 0\n#define MW_GPIO8_15_GPIOQUALSEL9 0\n#define MW_GPIO8_15_GPIOQUALSEL10 0\n#define MW_GPIO8_15_GPIOQUALSEL11 0\n#define MW_GPIO8_15_GPIOQUALSEL12 0\n#define MW_GPIO8_15_GPIOQUALSEL13 0\n#define MW_GPIO8_15_GPIOQUALSEL14 0\n#define MW_GPIO8_15_GPIOQUALSEL15 0\n#define MW_GPIO8_15_QUALPRD 0\n#define MW_GPIO16_23_GPIOQUALSEL16 0\n#define MW_GPIO16_23_GPIOQUALSEL17 0\n#define MW_GPIO16_23_GPIOQUALSEL18 0\n#define MW_GPIO16_23_GPIOQUALSEL19 0\n#define MW_GPIO16_23_GPIOQUALSEL20 0\n#define MW_GPIO16_23_GPIOQUALSEL21 0\n#define MW_GPIO16_23_GPIOQUALSEL22 0\n#define MW_GPIO16_23_GPIOQUALSEL23 0\n#define MW_GPIO16_23_QUALPRD 0\n#define MW_GPIO24_31_GPIOQUALSEL24 0\n#define MW_GPIO24_31_GPIOQUALSEL25 0\n#define MW_GPIO24_31_GPIOQUALSEL26 0\n#define MW_GPIO24_31_GPIOQUALSEL27 0\n#define MW_GPIO24_31_GPIOQUALSEL28 0\n#define MW_GPIO24_31_GPIOQUALSEL29 0\n#define MW_GPIO24_31_GPIOQUALSEL30 0\n#define MW_GPIO24_31_GPIOQUALSEL31 0\n#define MW_GPIO24_31_QUALPRD 0\n#define MW_GPIO32_39_GPIOQUALSEL32 0\n#define MW_GPIO32_39_GPIOQUALSEL33 0\n#define MW_GPIO32_39_GPIOQUALSEL34 0\n#define MW_GPIO32_39_GPIOQUALSEL35 0\n#define MW_GPIO32_39_GPIOQUALSEL36 0\n#define MW_GPIO32_39_GPIOQUALSEL37 0\n#define MW_GPIO32_39_GPIOQUALSEL38 0\n#define MW_GPIO32_39_GPIOQUALSEL39 0\n#define MW_GPIO32_39_QUALPRD 0\n#define MW_GPIO40_47_GPIOQUALSEL40 0\n#define MW_GPIO40_47_GPIOQUALSEL41 0\n#define MW_GPIO40_47_GPIOQUALSEL42 0\n#define MW_GPIO40_47_GPIOQUALSEL43 0\n#define MW_GPIO40_47_GPIOQUALSEL44 0\n#define MW_GPIO40_47_GPIOQUALSEL45 0\n#define MW_GPIO40_47_GPIOQUALSEL46 0\n#define MW_GPIO40_47_GPIOQUALSEL47 0\n#define MW_GPIO40_47_QUALPRD 0\n#define MW_GPIO48_55_GPIOQUALSEL48 0\n#define MW_GPIO48_55_GPIOQUALSEL49 0\n#define MW_GPIO48_55_GPIOQUALSEL50 0\n#define MW_GPIO48_55_GPIOQUALSEL51 0\n#define MW_GPIO48_55_GPIOQUALSEL52 0\n#define MW_GPIO48_55_GPIOQUALSEL53 0\n#define MW_GPIO48_55_GPIOQUALSEL54 0\n#define MW_GPIO48_55_GPIOQUALSEL55 0\n#define MW_GPIO48_55_QUALPRD 0\n#define MW_GPIO56_63_GPIOQUALSEL56 0\n#define MW_GPIO56_63_GPIOQUALSEL57 0\n#define MW_GPIO56_63_GPIOQUALSEL58 0\n#define MW_GPIO56_63_GPIOQUALSEL59 0\n#define MW_GPIO56_63_GPIOQUALSEL60 0\n#define MW_GPIO56_63_GPIOQUALSEL61 0\n#define MW_GPIO56_63_GPIOQUALSEL62 0\n#define MW_GPIO56_63_GPIOQUALSEL63 0\n#define MW_GPIO56_63_QUALPRD 0\n#define MW_GPIO64_71_GPIOQUALSEL64 0\n#define MW_GPIO64_71_GPIOQUALSEL65 0\n#define MW_GPIO64_71_GPIOQUALSEL66 0\n#define MW_GPIO64_71_GPIOQUALSEL67 0\n#define MW_GPIO64_71_GPIOQUALSEL68 0\n#define MW_GPIO64_71_GPIOQUALSEL69 0\n#define MW_GPIO64_71_GPIOQUALSEL70 0\n#define MW_GPIO64_71_GPIOQUALSEL71 0\n#define MW_GPIO64_71_QUALPRD 0\n#define MW_GPIO72_79_GPIOQUALSEL72 0\n#define MW_GPIO72_79_GPIOQUALSEL73 0\n#define MW_GPIO72_79_GPIOQUALSEL74 0\n#define MW_GPIO72_79_GPIOQUALSEL75 0\n#define MW_GPIO72_79_GPIOQUALSEL76 0\n#define MW_GPIO72_79_GPIOQUALSEL77 0\n#define MW_GPIO72_79_GPIOQUALSEL78 0\n#define MW_GPIO72_79_GPIOQUALSEL79 0\n#define MW_GPIO72_79_QUALPRD 0\n#define MW_GPIO80_87_GPIOQUALSEL80 0\n#define MW_GPIO80_87_GPIOQUALSEL81 0\n#define MW_GPIO80_87_GPIOQUALSEL82 0\n#define MW_GPIO80_87_GPIOQUALSEL83 0\n#define MW_GPIO80_87_GPIOQUALSEL84 0\n#define MW_GPIO80_87_GPIOQUALSEL85 0\n#define MW_GPIO80_87_GPIOQUALSEL86 0\n#define MW_GPIO80_87_GPIOQUALSEL87 0\n#define MW_GPIO80_87_QUALPRD 0\n#define MW_GPIO88_95_GPIOQUALSEL88 0\n#define MW_GPIO88_95_GPIOQUALSEL89 0\n#define MW_GPIO88_95_GPIOQUALSEL90 0\n#define MW_GPIO88_95_GPIOQUALSEL91 0\n#define MW_GPIO88_95_GPIOQUALSEL92 0\n#define MW_GPIO88_95_GPIOQUALSEL93 0\n#define MW_GPIO88_95_GPIOQUALSEL94 0\n#define MW_GPIO88_95_GPIOQUALSEL95 0\n#define MW_GPIO88_95_QUALPRD 0\n#define MW_GPIO96_103_GPIOQUALSEL96 0\n#define MW_GPIO96_103_GPIOQUALSEL97 0\n#define MW_GPIO96_103_GPIOQUALSEL98 0\n#define MW_GPIO96_103_GPIOQUALSEL99 0\n#define MW_GPIO96_103_GPIOQUALSEL100 0\n#define MW_GPIO96_103_GPIOQUALSEL101 0\n#define MW_GPIO96_103_GPIOQUALSEL102 0\n#define MW_GPIO96_103_GPIOQUALSEL103 0\n#define MW_GPIO96_103_QUALPRD 0\n#define MW_GPIO104_111_GPIOQUALSEL104 0\n#define MW_GPIO104_111_GPIOQUALSEL105 0\n#define MW_GPIO104_111_GPIOQUALSEL106 0\n#define MW_GPIO104_111_GPIOQUALSEL107 0\n#define MW_GPIO104_111_GPIOQUALSEL108 0\n#define MW_GPIO104_111_GPIOQUALSEL109 0\n#define MW_GPIO104_111_GPIOQUALSEL110 0\n#define MW_GPIO104_111_GPIOQUALSEL111 0\n#define MW_GPIO104_111_QUALPRD 0\n#define MW_GPIO112_119_GPIOQUALSEL112 0\n#define MW_GPIO112_119_GPIOQUALSEL113 0\n#define MW_GPIO112_119_GPIOQUALSEL114 0\n#define MW_GPIO112_119_GPIOQUALSEL115 0\n#define MW_GPIO112_119_GPIOQUALSEL116 0\n#define MW_GPIO112_119_GPIOQUALSEL117 0\n#define MW_GPIO112_119_GPIOQUALSEL118 0\n#define MW_GPIO112_119_GPIOQUALSEL119 0\n#define MW_GPIO112_119_QUALPRD 0\n#define MW_GPIO120_127_GPIOQUALSEL120 0\n#define MW_GPIO120_127_GPIOQUALSEL121 0\n#define MW_GPIO120_127_GPIOQUALSEL122 0\n#define MW_GPIO120_127_GPIOQUALSEL123 0\n#define MW_GPIO120_127_GPIOQUALSEL124 0\n#define MW_GPIO120_127_GPIOQUALSEL125 0\n#define MW_GPIO120_127_GPIOQUALSEL126 0\n#define MW_GPIO120_127_GPIOQUALSEL127 0\n#define MW_GPIO120_127_QUALPRD 0\n#define MW_GPIO128_135_GPIOQUALSEL128 0\n#define MW_GPIO128_135_GPIOQUALSEL129 0\n#define MW_GPIO128_135_GPIOQUALSEL130 0\n#define MW_GPIO128_135_GPIOQUALSEL131 0\n#define MW_GPIO128_135_GPIOQUALSEL132 0\n#define MW_GPIO128_135_GPIOQUALSEL133 0\n#define MW_GPIO128_135_GPIOQUALSEL134 0\n#define MW_GPIO128_135_GPIOQUALSEL135 0\n#define MW_GPIO128_135_QUALPRD 0\n#define MW_GPIO136_143_GPIOQUALSEL136 0\n#define MW_GPIO136_143_GPIOQUALSEL137 0\n#define MW_GPIO136_143_GPIOQUALSEL138 0\n#define MW_GPIO136_143_GPIOQUALSEL139 0\n#define MW_GPIO136_143_GPIOQUALSEL140 0\n#define MW_GPIO136_143_GPIOQUALSEL141 0\n#define MW_GPIO136_143_GPIOQUALSEL142 0\n#define MW_GPIO136_143_GPIOQUALSEL143 0\n#define MW_GPIO136_143_QUALPRD 0\n#define MW_GPIO144_151_GPIOQUALSEL144 0\n#define MW_GPIO144_151_GPIOQUALSEL145 0\n#define MW_GPIO144_151_GPIOQUALSEL146 0\n#define MW_GPIO144_151_GPIOQUALSEL147 0\n#define MW_GPIO144_151_GPIOQUALSEL148 0\n#define MW_GPIO144_151_GPIOQUALSEL149 0\n#define MW_GPIO144_151_GPIOQUALSEL150 0\n#define MW_GPIO144_151_GPIOQUALSEL151 0\n#define MW_GPIO144_151_QUALPRD 0\n#define MW_GPIO152_159_GPIOQUALSEL152 0\n#define MW_GPIO152_159_GPIOQUALSEL153 0\n#define MW_GPIO152_159_GPIOQUALSEL154 0\n#define MW_GPIO152_159_GPIOQUALSEL155 0\n#define MW_GPIO152_159_GPIOQUALSEL156 0\n#define MW_GPIO152_159_GPIOQUALSEL157 0\n#define MW_GPIO152_159_GPIOQUALSEL158 0\n#define MW_GPIO152_159_GPIOQUALSEL159 0\n#define MW_GPIO152_159_QUALPRD 0\n#define MW_GPIO160_167_GPIOQUALSEL160 0\n#define MW_GPIO160_167_GPIOQUALSEL161 0\n#define MW_GPIO160_167_GPIOQUALSEL162 0\n#define MW_GPIO160_167_GPIOQUALSEL163 0\n#define MW_GPIO160_167_GPIOQUALSEL164 0\n#define MW_GPIO160_167_GPIOQUALSEL165 0\n#define MW_GPIO160_167_GPIOQUALSEL166 0\n#define MW_GPIO160_167_GPIOQUALSEL167 0\n#define MW_GPIO160_167_QUALPRD 0\n#define MW_GPIO168_175_GPIOQUALSEL168 0\n#define MW_GPIO168_175_GPIOQUALSEL169 0\n#define MW_GPIO168_175_GPIOQUALSEL170 0\n#define MW_GPIO168_175_GPIOQUALSEL171 0\n#define MW_GPIO168_175_GPIOQUALSEL172 0\n#define MW_GPIO168_175_GPIOQUALSEL173 0\n#define MW_GPIO168_175_GPIOQUALSEL174 0\n#define MW_GPIO168_175_GPIOQUALSEL175 0\n#define MW_GPIO168_175_QUALPRD 0\n#define MW_XINT_GPIOXINT1SEL 0\n#define MW_XINT_GPIOXINT2SEL 0\n#define MW_XINT_GPIOXINT3SEL 0\n#define MW_XINT_GPIOXINT4SEL 0\n#define MW_XINT_GPIOXINT5SEL 0\n#define MW_XINT_POLARITY1 0\n#define MW_XINT_POLARITY2 0\n#define MW_XINT_POLARITY3 0\n#define MW_XINT_POLARITY4 0\n#define MW_XINT_POLARITY5 0\n#define MW_XINT_GPIOXINT1SEL_IXBAR 0\n#define MW_XINT_GPIOXINT2SEL_IXBAR 0\n#define MW_XINT_GPIOXINT3SEL_IXBAR 0\n#define MW_XINT_GPIOXINT4SEL_IXBAR 0\n#define MW_XINT_GPIOXINT5SEL_IXBAR 0\n#define MW_EXTMODECOMPORT -1\n#define MW_EXECUTIONPROFILEBUFFERLEN 50.000000\n#define MW_DATAVERSION 2016.02\n#define MW_IXBAR_FLAG 49\n#define MW_IXBAR_I1 None\n#define MW_IXBAR_I2 None\n#define MW_IXBAR_I3 None\n#define MW_IXBAR_I4 0\n#define MW_IXBAR_I5 0\n#define MW_IXBAR_I6 0\n#define MW_IXBAR_I7 20\n#define MW_IXBAR_I8 21\n#define MW_IXBAR_I9 99\n#define MW_IXBAR_I10 54\n#define MW_IXBAR_I11 55\n#define MW_IXBAR_I12 57\n#define MW_IXBAR_I13 0\n#define MW_IXBAR_I14 0\n#define MW_IXBAR_ONE_TIME 0.000000\n#define MW_OUTPUTXBAR_OXBAR1 0\n#define MW_OUTPUTXBAR_OXBAR_MUX1 -1\n#define MW_OUTPUTXBAR_OXBAR1_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR1_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR1_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR1_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR2 0\n#define MW_OUTPUTXBAR_OXBAR_MUX2 -1\n#define MW_OUTPUTXBAR_OXBAR2_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR2_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR2_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR2_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR3 0\n#define MW_OUTPUTXBAR_OXBAR_MUX3 -1\n#define MW_OUTPUTXBAR_OXBAR3_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR3_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR3_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR3_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR4 0\n#define MW_OUTPUTXBAR_OXBAR_MUX4 -1\n#define MW_OUTPUTXBAR_OXBAR4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR4_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR4_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR4_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR5 0\n#define MW_OUTPUTXBAR_OXBAR_MUX5 -1\n#define MW_OUTPUTXBAR_OXBAR5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR5_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR5_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR5_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR6 0\n#define MW_OUTPUTXBAR_OXBAR_MUX6 -1\n#define MW_OUTPUTXBAR_OXBAR6_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR6_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR6_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR6_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR7 0\n#define MW_OUTPUTXBAR_OXBAR_MUX7 -1\n#define MW_OUTPUTXBAR_OXBAR7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR7_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR7_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR7_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR8 0\n#define MW_OUTPUTXBAR_OXBAR_MUX8 -1\n#define MW_OUTPUTXBAR_OXBAR8_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR8_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR8_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR8_INVERT 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS1 0\n#define MW_CMPSS_CMPSS1_COMPH 0\n#define MW_CMPSS_CMPSS1_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS1_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS1_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS1_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS1_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS1_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS1_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS1_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS1_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS1_COMPL 0\n#define MW_CMPSS_CMPSS1_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS1_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS1_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS1_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS1_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS1_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS1_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS1_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS1_COMP_SELREF 0\n#define MW_CMPSS_CMPSS1_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS1_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS1_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS2 0\n#define MW_CMPSS_CMPSS2_COMPH 0\n#define MW_CMPSS_CMPSS2_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS2_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS2_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS2_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS2_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS2_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS2_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS2_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS2_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS2_COMPL 0\n#define MW_CMPSS_CMPSS2_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS2_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS2_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS2_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS2_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS2_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS2_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS2_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS2_COMP_SELREF 0\n#define MW_CMPSS_CMPSS2_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS2_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS2_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS3 0\n#define MW_CMPSS_CMPSS3_COMPH 0\n#define MW_CMPSS_CMPSS3_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS3_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS3_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS3_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS3_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS3_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS3_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS3_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS3_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS3_COMPL 0\n#define MW_CMPSS_CMPSS3_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS3_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS3_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS3_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS3_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS3_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS3_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS3_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS3_COMP_SELREF 0\n#define MW_CMPSS_CMPSS3_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS3_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS3_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS4 0\n#define MW_CMPSS_CMPSS4_COMPH 0\n#define MW_CMPSS_CMPSS4_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS4_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS4_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS4_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS4_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS4_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS4_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS4_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS4_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS4_COMPL 0\n#define MW_CMPSS_CMPSS4_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS4_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS4_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS4_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS4_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS4_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS4_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS4_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS4_COMP_SELREF 0\n#define MW_CMPSS_CMPSS4_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS4_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS4_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS5 0\n#define MW_CMPSS_CMPSS5_COMPH 0\n#define MW_CMPSS_CMPSS5_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS5_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS5_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS5_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS5_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS5_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS5_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS5_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS5_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS5_COMPL 0\n#define MW_CMPSS_CMPSS5_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS5_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS5_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS5_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS5_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS5_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS5_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS5_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS5_COMP_SELREF 0\n#define MW_CMPSS_CMPSS5_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS5_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS5_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS6 0\n#define MW_CMPSS_CMPSS6_COMPH 0\n#define MW_CMPSS_CMPSS6_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS6_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS6_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS6_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS6_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS6_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS6_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS6_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS6_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS6_COMPL 0\n#define MW_CMPSS_CMPSS6_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS6_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS6_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS6_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS6_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS6_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS6_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS6_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS6_COMP_SELREF 0\n#define MW_CMPSS_CMPSS6_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS6_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS6_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS7 0\n#define MW_CMPSS_CMPSS7_COMPH 0\n#define MW_CMPSS_CMPSS7_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS7_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS7_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS7_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS7_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS7_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS7_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS7_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS7_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS7_COMPL 0\n#define MW_CMPSS_CMPSS7_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS7_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS7_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS7_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS7_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS7_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS7_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS7_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS7_COMP_SELREF 0\n#define MW_CMPSS_CMPSS7_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS7_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS7_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS8 0\n#define MW_CMPSS_CMPSS8_COMPH 0\n#define MW_CMPSS_CMPSS8_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS8_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS8_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS8_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS8_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS8_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS8_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS8_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS8_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS8_COMPL 0\n#define MW_CMPSS_CMPSS8_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS8_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS8_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS8_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS8_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS8_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS8_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS8_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS8_COMP_SELREF 0\n#define MW_CMPSS_CMPSS8_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS8_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS8_COMP_COMPHYS 0\n#define MW_SDFM1_F1 0\n#define MW_SDFM1_D1 0\n#define MW_SDFM1_C1 0\n#define MW_SDFM1_F1_MODE 0\n#define MW_SDFM1_F1_C_FILTERTYPE 1\n#define MW_SDFM1_F1_COSR 0\n#define MW_SDFM1_F1_HLT 0\n#define MW_SDFM1_F1_LLT 0\n#define MW_SDFM1_F1_D_FILTERTYPE 1\n#define MW_SDFM1_F1_DOSR 0\n#define MW_SDFM1_F1_EXTPWM 0\n#define MW_SDFM1_F1_IEL 0\n#define MW_SDFM1_F1_IEH 0\n#define MW_SDFM1_F1_MFIE 0\n#define MW_SDFM1_F1_AE 0\n#define MW_SDFM1_F2 0\n#define MW_SDFM1_D2 0\n#define MW_SDFM1_C2 0\n#define MW_SDFM1_F2_MODE 0\n#define MW_SDFM1_F2_C_FILTERTYPE 1\n#define MW_SDFM1_F2_COSR 0\n#define MW_SDFM1_F2_HLT 0\n#define MW_SDFM1_F2_LLT 0\n#define MW_SDFM1_F2_D_FILTERTYPE 1\n#define MW_SDFM1_F2_DOSR 0\n#define MW_SDFM1_F2_EXTPWM 0\n#define MW_SDFM1_F2_IEL 0\n#define MW_SDFM1_F2_IEH 0\n#define MW_SDFM1_F2_MFIE 0\n#define MW_SDFM1_F2_AE 0\n#define MW_SDFM1_F3 0\n#define MW_SDFM1_D3 0\n#define MW_SDFM1_C3 0\n#define MW_SDFM1_F3_MODE 0\n#define MW_SDFM1_F3_C_FILTERTYPE 1\n#define MW_SDFM1_F3_COSR 0\n#define MW_SDFM1_F3_HLT 0\n#define MW_SDFM1_F3_LLT 0\n#define MW_SDFM1_F3_D_FILTERTYPE 1\n#define MW_SDFM1_F3_DOSR 0\n#define MW_SDFM1_F3_EXTPWM 0\n#define MW_SDFM1_F3_IEL 0\n#define MW_SDFM1_F3_IEH 0\n#define MW_SDFM1_F3_MFIE 0\n#define MW_SDFM1_F3_AE 0\n#define MW_SDFM1_F4 0\n#define MW_SDFM1_D4 0\n#define MW_SDFM1_C4 0\n#define MW_SDFM1_F4_MODE 0\n#define MW_SDFM1_F4_C_FILTERTYPE 1\n#define MW_SDFM1_F4_COSR 0\n#define MW_SDFM1_F4_HLT 0\n#define MW_SDFM1_F4_LLT 0\n#define MW_SDFM1_F4_D_FILTERTYPE 1\n#define MW_SDFM1_F4_DOSR 0\n#define MW_SDFM1_F4_EXTPWM 0\n#define MW_SDFM1_F4_IEL 0\n#define MW_SDFM1_F4_IEH 0\n#define MW_SDFM1_F4_MFIE 0\n#define MW_SDFM1_F4_AE 0\n#define MW_SDFM1_PINVALUE_D1 16\n#define MW_SDFM1_PINVALUE_C1 17\n#define MW_SDFM1_PINVALUE_D2 18\n#define MW_SDFM1_PINVALUE_C2 19\n#define MW_SDFM1_PINVALUE_D3 20\n#define MW_SDFM1_PINVALUE_C3 21\n#define MW_SDFM1_PINVALUE_D4 22\n#define MW_SDFM1_PINVALUE_C4 23\n#define MW_SDFM1_PINMUX_D1 7\n#define MW_SDFM1_PINMUX_C1 7\n#define MW_SDFM1_PINMUX_D2 7\n#define MW_SDFM1_PINMUX_C2 7\n#define MW_SDFM1_PINMUX_D3 7\n#define MW_SDFM1_PINMUX_C3 7\n#define MW_SDFM1_PINMUX_D4 7\n#define MW_SDFM1_PINMUX_C4 7\n#define MW_SDFM2_F1 0\n#define MW_SDFM2_D1 0\n#define MW_SDFM2_C1 0\n#define MW_SDFM2_F1_MODE 0\n#define MW_SDFM2_F1_C_FILTERTYPE 1\n#define MW_SDFM2_F1_COSR 0\n#define MW_SDFM2_F1_HLT 0\n#define MW_SDFM2_F1_LLT 0\n#define MW_SDFM2_F1_D_FILTERTYPE 1\n#define MW_SDFM2_F1_DOSR 0\n#define MW_SDFM2_F1_EXTPWM 0\n#define MW_SDFM2_F1_IEL 0\n#define MW_SDFM2_F1_IEH 0\n#define MW_SDFM2_F1_MFIE 0\n#define MW_SDFM2_F1_AE 0\n#define MW_SDFM2_F2 0\n#define MW_SDFM2_D2 0\n#define MW_SDFM2_C2 0\n#define MW_SDFM2_F2_MODE 0\n#define MW_SDFM2_F2_C_FILTERTYPE 1\n#define MW_SDFM2_F2_COSR 0\n#define MW_SDFM2_F2_HLT 0\n#define MW_SDFM2_F2_LLT 0\n#define MW_SDFM2_F2_D_FILTERTYPE 1\n#define MW_SDFM2_F2_DOSR 0\n#define MW_SDFM2_F2_EXTPWM 0\n#define MW_SDFM2_F2_IEL 0\n#define MW_SDFM2_F2_IEH 0\n#define MW_SDFM2_F2_MFIE 0\n#define MW_SDFM2_F2_AE 0\n#define MW_SDFM2_F3 0\n#define MW_SDFM2_D3 0\n#define MW_SDFM2_C3 0\n#define MW_SDFM2_F3_MODE 0\n#define MW_SDFM2_F3_C_FILTERTYPE 1\n#define MW_SDFM2_F3_COSR 0\n#define MW_SDFM2_F3_HLT 0\n#define MW_SDFM2_F3_LLT 0\n#define MW_SDFM2_F3_D_FILTERTYPE 1\n#define MW_SDFM2_F3_DOSR 0\n#define MW_SDFM2_F3_EXTPWM 0\n#define MW_SDFM2_F3_IEL 0\n#define MW_SDFM2_F3_IEH 0\n#define MW_SDFM2_F3_MFIE 0\n#define MW_SDFM2_F3_AE 0\n#define MW_SDFM2_F4 0\n#define MW_SDFM2_D4 0\n#define MW_SDFM2_C4 0\n#define MW_SDFM2_F4_MODE 0\n#define MW_SDFM2_F4_C_FILTERTYPE 1\n#define MW_SDFM2_F4_COSR 0\n#define MW_SDFM2_F4_HLT 0\n#define MW_SDFM2_F4_LLT 0\n#define MW_SDFM2_F4_D_FILTERTYPE 1\n#define MW_SDFM2_F4_DOSR 0\n#define MW_SDFM2_F4_EXTPWM 0\n#define MW_SDFM2_F4_IEL 0\n#define MW_SDFM2_F4_IEH 0\n#define MW_SDFM2_F4_MFIE 0\n#define MW_SDFM2_F4_AE 0\n#define MW_SDFM2_PINVALUE_D1 24\n#define MW_SDFM2_PINVALUE_C1 25\n#define MW_SDFM2_PINVALUE_D2 26\n#define MW_SDFM2_PINVALUE_C2 27\n#define MW_SDFM2_PINVALUE_D3 28\n#define MW_SDFM2_PINVALUE_C3 29\n#define MW_SDFM2_PINVALUE_D4 30\n#define MW_SDFM2_PINVALUE_C4 31\n#define MW_SDFM2_PINMUX_D1 7\n#define MW_SDFM2_PINMUX_C1 7\n#define MW_SDFM2_PINMUX_D2 7\n#define MW_SDFM2_PINMUX_C2 7\n#define MW_SDFM2_PINMUX_D3 7\n#define MW_SDFM2_PINMUX_C3 7\n#define MW_SDFM2_PINMUX_D4 7\n#define MW_SDFM2_PINMUX_C4 7\n#define MW_DMA_CH1_ENABLEDMACHANNEL 0\n#define MW_DMA_CH1_DATASIZE 0\n#define MW_DMA_CH1_INTERRUPTSRC 0\n#define MW_DMA_CH1_BURSTSIZE 0\n#define MW_DMA_CH1_TRANSFERSIZE 1\n#define MW_DMA_CH1_SRCBEGINADD 0xC000\n#define MW_DMA_CH1_DSTBEGINADD 0xD000\n#define MW_DMA_CH1_SRCBURSTSTEP 0\n#define MW_DMA_CH1_DSTBURSTSTEP 0\n#define MW_DMA_CH1_SRCTRANSSTEP 0\n#define MW_DMA_CH1_DSTTRANSSTEP 0\n#define MW_DMA_CH1_WRAPSRCSIZE 65536\n#define MW_DMA_CH1_WRAPDSTSIZE 65536\n#define MW_DMA_CH1_SRCWRAPSTEP 0\n#define MW_DMA_CH1_DSTWRAPSTEP 0\n#define MW_DMA_CH1_SETCH1TOHIGH 0\n#define MW_DMA_CH1_ENABLEONESHOT 0\n#define MW_DMA_CH1_ENABLECONTINUOUS 1\n#define MW_DMA_CH1_GENINTERRUPT 0\n#define MW_DMA_CH1_ENABLEOVERFLOW 0\n#define MW_DMA_CH2_ENABLEDMACHANNEL 0\n#define MW_DMA_CH2_DATASIZE 0\n#define MW_DMA_CH2_INTERRUPTSRC 0\n#define MW_DMA_CH2_BURSTSIZE 0\n#define MW_DMA_CH2_TRANSFERSIZE 1\n#define MW_DMA_CH2_SRCBEGINADD 0xC000\n#define MW_DMA_CH2_DSTBEGINADD 0xD000\n#define MW_DMA_CH2_SRCBURSTSTEP 0\n#define MW_DMA_CH2_DSTBURSTSTEP 0\n#define MW_DMA_CH2_SRCTRANSSTEP 0\n#define MW_DMA_CH2_DSTTRANSSTEP 0\n#define MW_DMA_CH2_WRAPSRCSIZE 65536\n#define MW_DMA_CH2_WRAPDSTSIZE 65536\n#define MW_DMA_CH2_SRCWRAPSTEP 0\n#define MW_DMA_CH2_DSTWRAPSTEP 0\n#define MW_DMA_CH2_ENABLEONESHOT 0\n#define MW_DMA_CH2_ENABLECONTINUOUS 1\n#define MW_DMA_CH2_GENINTERRUPT 0\n#define MW_DMA_CH2_ENABLEOVERFLOW 0\n#define MW_DMA_CH3_ENABLEDMACHANNEL 0\n#define MW_DMA_CH3_DATASIZE 0\n#define MW_DMA_CH3_INTERRUPTSRC 0\n#define MW_DMA_CH3_BURSTSIZE 0\n#define MW_DMA_CH3_TRANSFERSIZE 1\n#define MW_DMA_CH3_SRCBEGINADD 0xC000\n#define MW_DMA_CH3_DSTBEGINADD 0xD000\n#define MW_DMA_CH3_SRCBURSTSTEP 0\n#define MW_DMA_CH3_DSTBURSTSTEP 0\n#define MW_DMA_CH3_SRCTRANSSTEP 0\n#define MW_DMA_CH3_DSTTRANSSTEP 0\n#define MW_DMA_CH3_WRAPSRCSIZE 65536\n#define MW_DMA_CH3_WRAPDSTSIZE 65536\n#define MW_DMA_CH3_SRCWRAPSTEP 0\n#define MW_DMA_CH3_DSTWRAPSTEP 0\n#define MW_DMA_CH3_ENABLEONESHOT 0\n#define MW_DMA_CH3_ENABLECONTINUOUS 1\n#define MW_DMA_CH3_GENINTERRUPT 0\n#define MW_DMA_CH3_ENABLEOVERFLOW 0\n#define MW_DMA_CH4_ENABLEDMACHANNEL 0\n#define MW_DMA_CH4_DATASIZE 0\n#define MW_DMA_CH4_INTERRUPTSRC 0\n#define MW_DMA_CH4_BURSTSIZE 0\n#define MW_DMA_CH4_TRANSFERSIZE 1\n#define MW_DMA_CH4_SRCBEGINADD 0xC000\n#define MW_DMA_CH4_DSTBEGINADD 0xD000\n#define MW_DMA_CH4_SRCBURSTSTEP 0\n#define MW_DMA_CH4_DSTBURSTSTEP 0\n#define MW_DMA_CH4_SRCTRANSSTEP 0\n#define MW_DMA_CH4_DSTTRANSSTEP 0\n#define MW_DMA_CH4_WRAPSRCSIZE 65536\n#define MW_DMA_CH4_WRAPDSTSIZE 65536\n#define MW_DMA_CH4_SRCWRAPSTEP 0\n#define MW_DMA_CH4_DSTWRAPSTEP 0\n#define MW_DMA_CH4_ENABLEONESHOT 0\n#define MW_DMA_CH4_ENABLECONTINUOUS 1\n#define MW_DMA_CH4_GENINTERRUPT 0\n#define MW_DMA_CH4_ENABLEOVERFLOW 0\n#define MW_DMA_CH5_ENABLEDMACHANNEL 0\n#define MW_DMA_CH5_DATASIZE 0\n#define MW_DMA_CH5_INTERRUPTSRC 0\n#define MW_DMA_CH5_BURSTSIZE 0\n#define MW_DMA_CH5_TRANSFERSIZE 1\n#define MW_DMA_CH5_SRCBEGINADD 0xC000\n#define MW_DMA_CH5_DSTBEGINADD 0xD000\n#define MW_DMA_CH5_SRCBURSTSTEP 0\n#define MW_DMA_CH5_DSTBURSTSTEP 0\n#define MW_DMA_CH5_SRCTRANSSTEP 0\n#define MW_DMA_CH5_DSTTRANSSTEP 0\n#define MW_DMA_CH5_WRAPSRCSIZE 65536\n#define MW_DMA_CH5_WRAPDSTSIZE 65536\n#define MW_DMA_CH5_SRCWRAPSTEP 0\n#define MW_DMA_CH5_DSTWRAPSTEP 0\n#define MW_DMA_CH5_ENABLEONESHOT 0\n#define MW_DMA_CH5_ENABLECONTINUOUS 1\n#define MW_DMA_CH5_GENINTERRUPT 0\n#define MW_DMA_CH5_ENABLEOVERFLOW 0\n#define MW_DMA_CH6_ENABLEDMACHANNEL 0\n#define MW_DMA_CH6_DATASIZE 0\n#define MW_DMA_CH6_INTERRUPTSRC 0\n#define MW_DMA_CH6_BURSTSIZE 0\n#define MW_DMA_CH6_TRANSFERSIZE 1\n#define MW_DMA_CH6_SRCBEGINADD 0xC000\n#define MW_DMA_CH6_DSTBEGINADD 0xD000\n#define MW_DMA_CH6_SRCBURSTSTEP 0\n#define MW_DMA_CH6_DSTBURSTSTEP 0\n#define MW_DMA_CH6_SRCTRANSSTEP 0\n#define MW_DMA_CH6_DSTTRANSSTEP 0\n#define MW_DMA_CH6_WRAPSRCSIZE 65536\n#define MW_DMA_CH6_WRAPDSTSIZE 65536\n#define MW_DMA_CH6_SRCWRAPSTEP 0\n#define MW_DMA_CH6_DSTWRAPSTEP 0\n#define MW_DMA_CH6_ENABLEONESHOT 0\n#define MW_DMA_CH6_ENABLECONTINUOUS 1\n#define MW_DMA_CH6_GENINTERRUPT 0\n#define MW_DMA_CH6_ENABLEOVERFLOW 0\n#define MW_EMIF1_CLOCKDIV 1\n#define MW_EMIF1_CLOCKFREQUENCY 100\n#define MW_EMIF1_CS0 0\n#define MW_EMIF1_COLUMNADDRESS 0\n#define MW_EMIF1_PAGESIZE 256\n#define MW_EMIF1_BANKS 0\n#define MW_EMIF1_BUSWIDTH 0\n#define MW_EMIF1_T_RFC 3\n#define MW_EMIF1_T_RFC_NS 40\n#define MW_EMIF1_T_RP 1\n#define MW_EMIF1_T_RP_NS 20\n#define MW_EMIF1_T_RCD 2\n#define MW_EMIF1_T_RCD_NS 30\n#define MW_EMIF1_T_WR 1\n#define MW_EMIF1_T_WR_NS 20\n#define MW_EMIF1_T_RAS 4\n#define MW_EMIF1_T_RAS_NS 50\n#define MW_EMIF1_T_RC 6\n#define MW_EMIF1_T_RC_NS 70\n#define MW_EMIF1_T_RRD 1\n#define MW_EMIF1_T_RRD_NS 20\n#define MW_EMIF1_T_XSR 7\n#define MW_EMIF1_T_XSR_NS 80\n#define MW_EMIF1_REFRESHPERIOD 64\n#define MW_EMIF1_REFRESHCYCLE 4096\n#define MW_EMIF1_REFRESHRATE 1562\n#define MW_EMIF1_CASLATENCY 1\n#define MW_EMIF1_CS2 0\n#define MW_EMIF1_CS2_ASYNCHRONOUSMODE 0\n#define MW_EMIF1_CS2_ASYNCDATAWIDTH 1\n#define MW_EMIF1_CS2_R_SETUP 15\n#define MW_EMIF1_CS2_R_SETUP_NS 160\n#define MW_EMIF1_CS2_R_STROBE 63\n#define MW_EMIF1_CS2_R_STROBE_NS 640\n#define MW_EMIF1_CS2_R_HOLD 7\n#define MW_EMIF1_CS2_R_HOLD_NS 80\n#define MW_EMIF1_CS2_W_SETUP 15\n#define MW_EMIF1_CS2_W_SETUP_NS 160\n#define MW_EMIF1_CS2_W_STROBE 63\n#define MW_EMIF1_CS2_W_STROBE_NS 640\n#define MW_EMIF1_CS2_W_HOLD 7\n#define MW_EMIF1_CS2_W_HOLD_NS 80\n#define MW_EMIF1_CS2_TA_CYCLES 3\n#define MW_EMIF1_CS2_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF1_CS3 0\n#define MW_EMIF1_CS3_ASYNCHRONOUSMODE 0\n#define MW_EMIF1_CS3_ASYNCDATAWIDTH 1\n#define MW_EMIF1_CS3_R_SETUP 15\n#define MW_EMIF1_CS3_R_SETUP_NS 160\n#define MW_EMIF1_CS3_R_STROBE 63\n#define MW_EMIF1_CS3_R_STROBE_NS 640\n#define MW_EMIF1_CS3_R_HOLD 7\n#define MW_EMIF1_CS3_R_HOLD_NS 80\n#define MW_EMIF1_CS3_W_SETUP 15\n#define MW_EMIF1_CS3_W_SETUP_NS 160\n#define MW_EMIF1_CS3_W_STROBE 63\n#define MW_EMIF1_CS3_W_STROBE_NS 640\n#define MW_EMIF1_CS3_W_HOLD 7\n#define MW_EMIF1_CS3_W_HOLD_NS 80\n#define MW_EMIF1_CS3_TA_CYCLES 3\n#define MW_EMIF1_CS3_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF1_CS4 0\n#define MW_EMIF1_CS4_ASYNCHRONOUSMODE 0\n#define MW_EMIF1_CS4_ASYNCDATAWIDTH 1\n#define MW_EMIF1_CS4_R_SETUP 15\n#define MW_EMIF1_CS4_R_SETUP_NS 160\n#define MW_EMIF1_CS4_R_STROBE 63\n#define MW_EMIF1_CS4_R_STROBE_NS 640\n#define MW_EMIF1_CS4_R_HOLD 7\n#define MW_EMIF1_CS4_R_HOLD_NS 80\n#define MW_EMIF1_CS4_W_SETUP 15\n#define MW_EMIF1_CS4_W_SETUP_NS 160\n#define MW_EMIF1_CS4_W_STROBE 63\n#define MW_EMIF1_CS4_W_STROBE_NS 640\n#define MW_EMIF1_CS4_W_HOLD 7\n#define MW_EMIF1_CS4_W_HOLD_NS 80\n#define MW_EMIF1_CS4_TA_CYCLES 3\n#define MW_EMIF1_CS4_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF1_EXTENDED_WAIT_CYCLE 128\n#define MW_EMIF1_EXTENDED_WAIT_POLARITY 0\n#define MW_EMIF1_WAITRISE 0\n#define MW_EMIF1_TIMEOUT 0\n#define MW_EMIF1_LINETRAP 0\n#define MW_EMIF2_CLOCKDIV 1\n#define MW_EMIF2_CLOCKFREQUENCY 100\n#define MW_EMIF2_CS0 0\n#define MW_EMIF2_COLUMNADDRESS 0\n#define MW_EMIF2_PAGESIZE 256\n#define MW_EMIF2_BANKS 0\n#define MW_EMIF2_BUSWIDTH 0\n#define MW_EMIF2_T_RFC 3\n#define MW_EMIF2_T_RFC_NS 40\n#define MW_EMIF2_T_RP 1\n#define MW_EMIF2_T_RP_NS 20\n#define MW_EMIF2_T_RCD 2\n#define MW_EMIF2_T_RCD_NS 30\n#define MW_EMIF2_T_WR 1\n#define MW_EMIF2_T_WR_NS 20\n#define MW_EMIF2_T_RAS 4\n#define MW_EMIF2_T_RAS_NS 50\n#define MW_EMIF2_T_RC 6\n#define MW_EMIF2_T_RC_NS 70\n#define MW_EMIF2_T_RRD 1\n#define MW_EMIF2_T_RRD_NS 20\n#define MW_EMIF2_T_XSR 7\n#define MW_EMIF2_T_XSR_NS 80\n#define MW_EMIF2_REFRESHPERIOD 64\n#define MW_EMIF2_REFRESHCYCLE 4096\n#define MW_EMIF2_REFRESHRATE 1562\n#define MW_EMIF2_CASLATENCY 1\n#define MW_EMIF2_CS2 0\n#define MW_EMIF2_CS2_ASYNCHRONOUSMODE 0\n#define MW_EMIF2_CS2_ASYNCDATAWIDTH 1\n#define MW_EMIF2_CS2_R_SETUP 15\n#define MW_EMIF2_CS2_R_SETUP_NS 160\n#define MW_EMIF2_CS2_R_STROBE 63\n#define MW_EMIF2_CS2_R_STROBE_NS 640\n#define MW_EMIF2_CS2_R_HOLD 7\n#define MW_EMIF2_CS2_R_HOLD_NS 80\n#define MW_EMIF2_CS2_W_SETUP 15\n#define MW_EMIF2_CS2_W_SETUP_NS 160\n#define MW_EMIF2_CS2_W_STROBE 63\n#define MW_EMIF2_CS2_W_STROBE_NS 640\n#define MW_EMIF2_CS2_W_HOLD 7\n#define MW_EMIF2_CS2_W_HOLD_NS 80\n#define MW_EMIF2_CS2_TA_CYCLES 3\n#define MW_EMIF2_CS2_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF2_EXTENDED_WAIT_CYCLE 128\n#define MW_EMIF2_EXTENDED_WAIT_POLARITY 0\n#define MW_EMIF2_WAITRISE 0\n#define MW_EMIF2_TIMEOUT 0\n#define MW_EMIF2_LINETRAP 0\n#define MW_PIL_COMMUNICATIONINTERFACE 0\n#define MW_PIL_SCIMODULE 0\n#define MW_PIL_COMPORT COM7\n#define MW_SDCARD_ENABLE 0\n#define MW_SDCARD_SPIMODULE 0\n#define MW_SDCARD_SPIBAUDRATE 1\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_CHECK_GPIO_STATUS 1\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 34\n#define MW_OVERRUNDETECTION_GPIOMODE 0\n#define MW_OVERRUNDETECTION_CUSTOM_LOGIC 0\n#define MW_OVERRUNDETECTION_PIE_NUMBER 0\n#define MW_OVERRUNDETECTION_CPU_NUMBER 0\n#define MW_OVERRUNDETECTION_CUSTOM_FUNCTION c2000_OverrunFunction\n#define MW_ESB_PROCESSINGUNIT c28xCPU1\n#define MW_ESB_SIMDIAGSHOWINSDI 1\n#define MW_ESB_SIMDIAGSAVETOFILE 1\n#define MW_ESB_SIMDIAGOVERWRITEFILE 0\n#define MW_ESB_HWDIAGSHOWINSDI 0\n#define MW_ESB_HWDIAGSAVETOFILE 0\n#define MW_ESB_HWDIAGOVERWRITEFILE 0\n#define MW_ESB_HWDIAGINSTRUMENTATION Code\n#define MW_ESB_HWDIAGRECORDING Continuous\n#define MW_ESB_HWDIAGSTREAMINGMODETYPE Unlimited\n#define MW_ESB_HWDIAGBUFFERSIZE 1024.000000\n#define MW_ESB_HWDIAGNUMBUFFERS 1.000000\n#define MW_ESB_HWDIAGVIEWLEVEL Task manager tasks\n#define MW_ESB_SETRNG 0\n#define MW_ESB_RNGSEED default\n#define MW_ESB_CACHEDATA 0\n#define MW_ESB_SCHEDULEEDITORSCHEDULERESET 0\n#define MW_IOBLOCKSMODE deployed\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 8\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_MAXCONTIGSAMPLES 10\n#define MW_FPGADESIGN_PROJECTFOLDER soc_prj\n#define MW_CLA_LSCONFIGENABLE 0\n#define MW_CLA_PMLENGTH 1\n#define MW_CLA_DMLENGTH 0\n#define MW_CLA_CPULSLENGTH 6\n#define MW_CLBXBAR_AUXSIG0 0\n#define MW_CLBXBAR_AUXSIG_MUX0 -1\n#define MW_CLBXBAR_AUXSIG0_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG0_INVERT 0\n#define MW_CLBXBAR_AUXSIG1 0\n#define MW_CLBXBAR_AUXSIG_MUX1 -1\n#define MW_CLBXBAR_AUXSIG1_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG1_INVERT 0\n#define MW_CLBXBAR_AUXSIG2 0\n#define MW_CLBXBAR_AUXSIG_MUX2 -1\n#define MW_CLBXBAR_AUXSIG2_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG2_INVERT 0\n#define MW_CLBXBAR_AUXSIG3 0\n#define MW_CLBXBAR_AUXSIG_MUX3 -1\n#define MW_CLBXBAR_AUXSIG3_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG3_INVERT 0\n#define MW_CLBXBAR_AUXSIG4 0\n#define MW_CLBXBAR_AUXSIG_MUX4 -1\n#define MW_CLBXBAR_AUXSIG4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG4_INVERT 0\n#define MW_CLBXBAR_AUXSIG5 0\n#define MW_CLBXBAR_AUXSIG_MUX5 -1\n#define MW_CLBXBAR_AUXSIG5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG5_INVERT 0\n#define MW_CLBXBAR_AUXSIG6 0\n#define MW_CLBXBAR_AUXSIG_MUX6 -1\n#define MW_CLBXBAR_AUXSIG6_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG6_INVERT 0\n#define MW_CLBXBAR_AUXSIG7 0\n#define MW_CLBXBAR_AUXSIG_MUX7 -1\n#define MW_CLBXBAR_AUXSIG7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG7_INVERT 0\n#define MW_CLB_TILE1 0\n#define MW_CLB_TILE1_NAME TILE1\n#define MW_CLB_TILE1_IN0_MUX 0\n#define MW_CLB_TILE1_IN0 -1\n#define MW_CLB_TILE1_IN0_FILTER 0\n#define MW_CLB_TILE1_IN0_SYNC 0\n#define MW_CLB_TILE1_IN1_MUX 0\n#define MW_CLB_TILE1_IN1 -1\n#define MW_CLB_TILE1_IN1_FILTER 0\n#define MW_CLB_TILE1_IN1_SYNC 0\n#define MW_CLB_TILE1_IN2_MUX 0\n#define MW_CLB_TILE1_IN2 -1\n#define MW_CLB_TILE1_IN2_FILTER 0\n#define MW_CLB_TILE1_IN2_SYNC 0\n#define MW_CLB_TILE1_IN3_MUX 0\n#define MW_CLB_TILE1_IN3 -1\n#define MW_CLB_TILE1_IN3_FILTER 0\n#define MW_CLB_TILE1_IN3_SYNC 0\n#define MW_CLB_TILE1_IN4_MUX 0\n#define MW_CLB_TILE1_IN4 -1\n#define MW_CLB_TILE1_IN4_FILTER 0\n#define MW_CLB_TILE1_IN4_SYNC 0\n#define MW_CLB_TILE1_IN5_MUX 0\n#define MW_CLB_TILE1_IN5 -1\n#define MW_CLB_TILE1_IN5_FILTER 0\n#define MW_CLB_TILE1_IN5_SYNC 0\n#define MW_CLB_TILE1_IN6_MUX 0\n#define MW_CLB_TILE1_IN6 -1\n#define MW_CLB_TILE1_IN6_FILTER 0\n#define MW_CLB_TILE1_IN6_SYNC 0\n#define MW_CLB_TILE1_IN7_MUX 0\n#define MW_CLB_TILE1_IN7 -1\n#define MW_CLB_TILE1_IN7_FILTER 0\n#define MW_CLB_TILE1_IN7_SYNC 0\n#define MW_CLB_TILE1_OUT0_0 0\n#define MW_CLB_TILE1_OUT0_1 0\n#define MW_CLB_TILE1_OUT1_0 0\n#define MW_CLB_TILE1_OUT1_1 0\n#define MW_CLB_TILE1_OUT2_0 0\n#define MW_CLB_TILE1_OUT2_1 0\n#define MW_CLB_TILE1_OUT3_0 0\n#define MW_CLB_TILE1_OUT3_1 0\n#define MW_CLB_TILE1_OUT4_0 0\n#define MW_CLB_TILE1_OUT4_1 0\n#define MW_CLB_TILE1_OUT5_0 0\n#define MW_CLB_TILE1_OUT5_1 0\n#define MW_CLB_TILE1_OUT6_0 0\n#define MW_CLB_TILE1_OUT6_1 0\n#define MW_CLB_TILE1_OUT7_0 0\n#define MW_CLB_TILE1_OUT7_1 0\n#define MW_CLB_TILE2 0\n#define MW_CLB_TILE2_NAME TILE2\n#define MW_CLB_TILE2_IN0_MUX 0\n#define MW_CLB_TILE2_IN0 -1\n#define MW_CLB_TILE2_IN0_FILTER 0\n#define MW_CLB_TILE2_IN0_SYNC 0\n#define MW_CLB_TILE2_IN1_MUX 0\n#define MW_CLB_TILE2_IN1 -1\n#define MW_CLB_TILE2_IN1_FILTER 0\n#define MW_CLB_TILE2_IN1_SYNC 0\n#define MW_CLB_TILE2_IN2_MUX 0\n#define MW_CLB_TILE2_IN2 -1\n#define MW_CLB_TILE2_IN2_FILTER 0\n#define MW_CLB_TILE2_IN2_SYNC 0\n#define MW_CLB_TILE2_IN3_MUX 0\n#define MW_CLB_TILE2_IN3 -1\n#define MW_CLB_TILE2_IN3_FILTER 0\n#define MW_CLB_TILE2_IN3_SYNC 0\n#define MW_CLB_TILE2_IN4_MUX 0\n#define MW_CLB_TILE2_IN4 -1\n#define MW_CLB_TILE2_IN4_FILTER 0\n#define MW_CLB_TILE2_IN4_SYNC 0\n#define MW_CLB_TILE2_IN5_MUX 0\n#define MW_CLB_TILE2_IN5 -1\n#define MW_CLB_TILE2_IN5_FILTER 0\n#define MW_CLB_TILE2_IN5_SYNC 0\n#define MW_CLB_TILE2_IN6_MUX 0\n#define MW_CLB_TILE2_IN6 -1\n#define MW_CLB_TILE2_IN6_FILTER 0\n#define MW_CLB_TILE2_IN6_SYNC 0\n#define MW_CLB_TILE2_IN7_MUX 0\n#define MW_CLB_TILE2_IN7 -1\n#define MW_CLB_TILE2_IN7_FILTER 0\n#define MW_CLB_TILE2_IN7_SYNC 0\n#define MW_CLB_TILE2_OUT0_0 0\n#define MW_CLB_TILE2_OUT0_1 0\n#define MW_CLB_TILE2_OUT1_0 0\n#define MW_CLB_TILE2_OUT1_1 0\n#define MW_CLB_TILE2_OUT2_0 0\n#define MW_CLB_TILE2_OUT2_1 0\n#define MW_CLB_TILE2_OUT3_0 0\n#define MW_CLB_TILE2_OUT3_1 0\n#define MW_CLB_TILE2_OUT4_0 0\n#define MW_CLB_TILE2_OUT4_1 0\n#define MW_CLB_TILE2_OUT5_0 0\n#define MW_CLB_TILE2_OUT5_1 0\n#define MW_CLB_TILE2_OUT6_0 0\n#define MW_CLB_TILE2_OUT6_1 0\n#define MW_CLB_TILE2_OUT7_0 0\n#define MW_CLB_TILE2_OUT7_1 0\n#define MW_CLB_TILE3 0\n#define MW_CLB_TILE3_NAME TILE3\n#define MW_CLB_TILE3_IN0_MUX 0\n#define MW_CLB_TILE3_IN0 -1\n#define MW_CLB_TILE3_IN0_FILTER 0\n#define MW_CLB_TILE3_IN0_SYNC 0\n#define MW_CLB_TILE3_IN1_MUX 0\n#define MW_CLB_TILE3_IN1 -1\n#define MW_CLB_TILE3_IN1_FILTER 0\n#define MW_CLB_TILE3_IN1_SYNC 0\n#define MW_CLB_TILE3_IN2_MUX 0\n#define MW_CLB_TILE3_IN2 -1\n#define MW_CLB_TILE3_IN2_FILTER 0\n#define MW_CLB_TILE3_IN2_SYNC 0\n#define MW_CLB_TILE3_IN3_MUX 0\n#define MW_CLB_TILE3_IN3 -1\n#define MW_CLB_TILE3_IN3_FILTER 0\n#define MW_CLB_TILE3_IN3_SYNC 0\n#define MW_CLB_TILE3_IN4_MUX 0\n#define MW_CLB_TILE3_IN4 -1\n#define MW_CLB_TILE3_IN4_FILTER 0\n#define MW_CLB_TILE3_IN4_SYNC 0\n#define MW_CLB_TILE3_IN5_MUX 0\n#define MW_CLB_TILE3_IN5 -1\n#define MW_CLB_TILE3_IN5_FILTER 0\n#define MW_CLB_TILE3_IN5_SYNC 0\n#define MW_CLB_TILE3_IN6_MUX 0\n#define MW_CLB_TILE3_IN6 -1\n#define MW_CLB_TILE3_IN6_FILTER 0\n#define MW_CLB_TILE3_IN6_SYNC 0\n#define MW_CLB_TILE3_IN7_MUX 0\n#define MW_CLB_TILE3_IN7 -1\n#define MW_CLB_TILE3_IN7_FILTER 0\n#define MW_CLB_TILE3_IN7_SYNC 0\n#define MW_CLB_TILE3_OUT0_0 0\n#define MW_CLB_TILE3_OUT0_1 0\n#define MW_CLB_TILE3_OUT1_0 0\n#define MW_CLB_TILE3_OUT1_1 0\n#define MW_CLB_TILE3_OUT2_0 0\n#define MW_CLB_TILE3_OUT2_1 0\n#define MW_CLB_TILE3_OUT3_0 0\n#define MW_CLB_TILE3_OUT3_1 0\n#define MW_CLB_TILE3_OUT4_0 0\n#define MW_CLB_TILE3_OUT4_1 0\n#define MW_CLB_TILE3_OUT5_0 0\n#define MW_CLB_TILE3_OUT5_1 0\n#define MW_CLB_TILE3_OUT6_0 0\n#define MW_CLB_TILE3_OUT6_1 0\n#define MW_CLB_TILE3_OUT7_0 0\n#define MW_CLB_TILE3_OUT7_1 0\n#define MW_CLB_TILE4 0\n#define MW_CLB_TILE4_NAME TILE4\n#define MW_CLB_TILE4_IN0_MUX 0\n#define MW_CLB_TILE4_IN0 -1\n#define MW_CLB_TILE4_IN0_FILTER 0\n#define MW_CLB_TILE4_IN0_SYNC 0\n#define MW_CLB_TILE4_IN1_MUX 0\n#define MW_CLB_TILE4_IN1 -1\n#define MW_CLB_TILE4_IN1_FILTER 0\n#define MW_CLB_TILE4_IN1_SYNC 0\n#define MW_CLB_TILE4_IN2_MUX 0\n#define MW_CLB_TILE4_IN2 -1\n#define MW_CLB_TILE4_IN2_FILTER 0\n#define MW_CLB_TILE4_IN2_SYNC 0\n#define MW_CLB_TILE4_IN3_MUX 0\n#define MW_CLB_TILE4_IN3 -1\n#define MW_CLB_TILE4_IN3_FILTER 0\n#define MW_CLB_TILE4_IN3_SYNC 0\n#define MW_CLB_TILE4_IN4_MUX 0\n#define MW_CLB_TILE4_IN4 -1\n#define MW_CLB_TILE4_IN4_FILTER 0\n#define MW_CLB_TILE4_IN4_SYNC 0\n#define MW_CLB_TILE4_IN5_MUX 0\n#define MW_CLB_TILE4_IN5 -1\n#define MW_CLB_TILE4_IN5_FILTER 0\n#define MW_CLB_TILE4_IN5_SYNC 0\n#define MW_CLB_TILE4_IN6_MUX 0\n#define MW_CLB_TILE4_IN6 -1\n#define MW_CLB_TILE4_IN6_FILTER 0\n#define MW_CLB_TILE4_IN6_SYNC 0\n#define MW_CLB_TILE4_IN7_MUX 0\n#define MW_CLB_TILE4_IN7 -1\n#define MW_CLB_TILE4_IN7_FILTER 0\n#define MW_CLB_TILE4_IN7_SYNC 0\n#define MW_CLB_TILE4_OUT0_0 0\n#define MW_CLB_TILE4_OUT1_0 0\n#define MW_CLB_TILE4_OUT2_0 0\n#define MW_CLB_TILE4_OUT3_0 0\n#define MW_CLB_TILE4_OUT4_0 0\n#define MW_CLB_TILE4_OUT4_1 0\n#define MW_CLB_TILE4_OUT5_0 0\n#define MW_CLB_TILE4_OUT5_1 0\n#define MW_CLB_TILE4_OUT6_0 0\n#define MW_CLB_TILE4_OUT6_1 0\n#define MW_CLB_TILE4_OUT7_0 0\n#define MW_CLB_TILE4_OUT7_1 0\n#define MW_CLB_HEADER clb_config.h\n#define MW_CLB_SOURCE clb_config.c\n#define MW_SIMULINKIO_COMMUNICATIONINTERFACE 0\n#define MW_SIMULINKIO_SCIMODULE 0\n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN codertarget.simulinkIO.tic2000.getModelTransportInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN codertarget.simulinkIO.tic2000.updateServer\n#define MW_SIMULINKIO_COMPORT COM7\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"c2000HardwareTimerConfig.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyrights 2016-2021, MathWorks Inc */\n#include \"MW_target_hardware_resources.h\"\n#include \"rtwtypes.h\"\n\nvoid hardwareTimer1Init(void)\n{\n  /* InitCpuTimers() - CPU Timers are initialized in\n   * MW_c28xx_board.c in the generated code.\n   */\n  CpuTimer1Regs.PRD.all = 0xFFFFFFFF;  /* max Period*/\n  CpuTimer1Regs.TIM.all = 0xFFFFFFFF;  /* set Ctr*/\n#if defined(MW_TIMER_PRESCALE_FOR_XCP)\n  CpuTimer1Regs.TPR.all = (0xFF & (MW_TIMER_PRESCALE_FOR_XCP - 1));         /* prescaler defined in make file dynamically based on clock */\n#else\n  CpuTimer1Regs.TPR.all = 0x00;        /* no prescaler    */\n#endif\n  StartCpuTimer1();\n}\n\n/* EOF */\n"},{"name":"c2837xDBoard_Realtime_Support.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*\n *   Copyright 2015-2024 The MathWorks, Inc.\n *\n *\n */\n\n#include \"MW_target_hardware_resources.h\"\n#include \"MW_f2837xD_includes.h\"\n#include \"MW_ipc_helper.h\"\n\nextern Uint16 RamfuncsLoadSize;\nextern Uint16 Cla1funcsRunStart;\nextern Uint16 Cla1funcsLoadStart;\nextern Uint16 Cla1funcsLoadSize;\nextern Uint16 Cla1mathTablesRunStart;\nextern Uint16 Cla1mathTablesLoadStart;\nextern Uint16 Cla1mathTablesLoadSize;\n#ifdef CPU1\nextern interrupt void IPC0_INT_isr(void);\nvoid (*CIPC0_INT_fptr)(void) = NULL;\nuint32_t mwInitStart = 0;\nuint32_t mwInitEnd = 0;\n__interrupt void CPU02toCPU01IPC0IntHandler(void);\nUint32 setGPIOForCPU2(Uint32 gpioData);\nUint32 setInXBARForCPU2(Uint32 inData);\nUint32 setOutXBARForCPU2(Uint32 inData);\nUint32 setEpwmXBARForCPU2(Uint32 inData);\nUint32 setCLBXBARForCPU2(Uint32 inData);\nUint32 setSyncSocRegsForCPU2(Uint32 inData);\nvolatile uint16_t ErrorFlag;\n#else\nvoid configureCPU2Peripherals(Uint32 gpioNumber, Uint32 gpGRegValA, Uint32 gpRegValA);\nvoid configureInputXBar(Uint32 gpioNumber, Uint32 inputXbarNumber);\nvoid configureOutputXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert, Uint32 latch);\nvoid configureEpwmXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert);\nvoid configureCLBXbarInCPU2(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert);\nvoid configureSyncSocRegsInCPU2(Uint32 syncSelectVal , Uint32 syncSelectPosition);\n#endif\nvoid initSetGPIOIPC(void);\n\n#if MW_RUNTIME_FLASHLOAD\nextern Uint16 MW_RamfuncsRunStart;\nextern Uint16 MW_RamfuncsLoadSize;\nextern Uint16 MW_RamfuncsLoadStart;\n#endif\nextern Uint16 Cla1ConstRunStart, Cla1ConstLoadStart, Cla1ConstLoadSize;\nvoid c2000_flash_init(void)\n{\n  #if MW_RUNTIME_FLASHLOAD\n  /* Copy InitFlash function code and Flash setup code to RAM */\n  memcpy(&RamfuncsRunStart,&RamfuncsLoadStart, (Uint32)(&RamfuncsLoadEnd-&RamfuncsLoadStart));\n  memcpy(&MW_RamfuncsRunStart, &MW_RamfuncsLoadStart, (Uint32)&MW_RamfuncsLoadSize);\n  #ifdef CLA_BLOCK_INCLUDED\n    memcpy(&Cla1funcsRunStart, &Cla1funcsLoadStart, (Uint32)&Cla1funcsLoadSize);\n    memcpy(&Cla1ConstRunStart, &Cla1ConstLoadStart, (Uint32)&Cla1ConstLoadSize);\n    /*memcpy(&Cla1mathTablesRunStart, &Cla1mathTablesLoadStart, (Uint32)&Cla1mathTablesLoadSize); */\n  #endif\n  /* Call Flash Initialization to setup flash waitstates\n   This function must reside in RAM */\n  InitFlash();\n  #endif\n}\n\nvoid initSetGPIOIPC(void)\n{\n\n    uint32_t *pulMsgRam;\n    volatile uint32_t ipcCountVar = 0;\n    #ifdef CPU1\n\tuint32_t i = 0;\n\tuint32_t MemCfgRegVar = 0;\n        EALLOW; // This is needed to write to EALLOW protected registers\n        PieVectTable.IPC0_INT = &CPU02toCPU01IPC0IntHandler;\n        /*Each global shared RAM section size is 4096 (2^12)*/\n        for (i=((uint32_t)CPU2_RAMGS_DATA_START) >> 12; i < (((uint32_t)CPU2_RAMGS_DATA_LENGTH + (uint32_t)CPU2_RAMGS_DATA_START) >> 12); i++)\n        {\n            /*Global shred RAM strts at 0xC000*/\n            MemCfgRegVar = MemCfgRegVar | (1UL<<(i-12));\n        }\n        for (i=((uint32_t)CPU2_RAMGS_PROG_START) >> 12; i < (((uint32_t)CPU2_RAMGS_PROG_LENGTH + (uint32_t)CPU2_RAMGS_PROG_START) >> 12); i++)\n        {\n            MemCfgRegVar = MemCfgRegVar | (1UL<<(i-12));\n        }\n        MemCfgRegs.GSxMSEL.all = MemCfgRegs.GSxMSEL.all | MemCfgRegVar;\n        EDIS;    // This is needed to disable write to EALLOW protected registers\n\t\t\n\t    // Any new entry to pulMsgRam should follow with change in starting address CPU01_TO_CPU02_PASSMSG\n        pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        pulMsgRam[0] = (uint32_t)&setGPIOForCPU2;\n        pulMsgRam[1] = (uint32_t)&mwInitStart;\n        pulMsgRam[2] = (uint32_t)&mwInitEnd;\n        pulMsgRam[3] = (uint32_t)&setInXBARForCPU2;\n        pulMsgRam[4] = (uint32_t)&setOutXBARForCPU2;\n        pulMsgRam[5] = (uint32_t)&setEpwmXBARForCPU2;\n        pulMsgRam[6] = (uint32_t)&setCLBXBARForCPU2;\n        pulMsgRam[7] = (uint32_t)&setSyncSocRegsForCPU2;\n        PieCtrlRegs.PIEIER1.bit.INTx13 = 1;     // IPC INT0\n        IER |= M_INT1;\n        EINT;  // Enable Global interrupt INTM\n        ERTM;  // Enable Global realtime interrupt DBGM\n        \n    //#if MW_RUNTIME_FLASHLOAD\n      #ifndef TIC2000_SOC_BASEPRODUCT\n        //Wait for CPU2 to get ready to accept boot command from CPU1\n        while (((IpcRegs.IPCBOOTSTS & 0x0000000F) != C2_BOOTROM_BOOTSTS_SYSTEM_READY) && (700 > ipcCountVar))\n        {\n            ipcCountVar++;\n        }\n        //CPU01 to CPU02 IPC Boot Mode Register\n        IpcRegs.IPCBOOTMODE = C1C2_BROM_BOOTMODE_BOOT_FROM_FLASH;\n        // CPU01 To CPU02 IPC Command Register\n        IpcRegs.IPCSENDCOM  = BROM_IPC_EXECUTE_BOOTMODE_CMD;\n        // CPU01 to CPU02 IPC flag register\n        IpcRegs.IPCSET.all = 0x80000001;\n        ipcCountVar = 0;\n        // Give ~35 usec delay to start CPU2 init\n        while (500 > ipcCountVar) {\n            ipcCountVar++;\n        }\n      #endif\n\n    //#endif\n\n    #else\n        #ifndef TIC2000_SOC_BASEPRODUCT\n        pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        IPCLiteLtoRDataWrite(IPC_FLAG0, pulMsgRam[1], 0x425,\n                         IPC_LENGTH_32_BITS, IPC_FLAG31);\n        #endif\n    #endif\n}\n\n#ifdef CPU1\nUint32 setGPIOForCPU2(Uint32 gpioData)\n{\n    if (((gpioData & 0xFF000000)>>24) == GPIO_MUX_CPU2CLA) /* from CLA inside CPU2, GPIO_MUX_CPU2CLA defined to value 3*/\n    {\n        gpioData = gpioData & 0x00FFFFFF; /* remove added encryption GPIO_MUX_CPU2CLA, MSB is the flag and we use only flag 0*/\n        GPIO_SetupPinMux(gpioData & 0x000000FF, GPIO_MUX_CPU2CLA, (gpioData & 0x0000FF00)>>8);\n        GPIO_SetupPinOptions(gpioData & 0x000000FF, (gpioData & 0x00FF0000)>>16, (gpioData & 0xFF000000)>>24);\n    }\n    else\n    {\n        GPIO_SetupPinMux(gpioData & 0x000000FF, GPIO_MUX_CPU2, (gpioData & 0x0000FF00)>>8);/* From CPU2*/\n        GPIO_SetupPinOptions(gpioData & 0x000000FF, (gpioData & 0x00FF0000)>>16, (gpioData & 0xFF000000)>>24);\n    }\n    return 1;\n}\n\nUint32 setInXBARForCPU2(Uint32 inData)\n{\n    Uint16 pin = (Uint16)(inData & 0x000000FF);\n    EALLOW;\n    switch((inData & 0x0000FF00) >> 8)\n    {\n        case 1:\n            InputXbarRegs.INPUT1SELECT = pin;\n            break;\n        case 2:\n            InputXbarRegs.INPUT2SELECT = pin;\n            break;\n        case 3:\n            InputXbarRegs.INPUT3SELECT = pin;\n            break;\n        case 4:\n            InputXbarRegs.INPUT4SELECT = pin;\n            break;\n        case 5:\n            InputXbarRegs.INPUT5SELECT = pin;\n            break;\n        case 6:\n            InputXbarRegs.INPUT6SELECT = pin;\n            break;\n        case 7:\n            InputXbarRegs.INPUT7SELECT = pin;\n            break;\n        case 8:\n            InputXbarRegs.INPUT8SELECT = pin;\n            break;\n        case 9:\n            InputXbarRegs.INPUT9SELECT = pin;\n            break;\n        case 10:\n            InputXbarRegs.INPUT10SELECT = pin;\n            break;\n        case 11:\n            InputXbarRegs.INPUT11SELECT = pin;\n            break;\n        case 12:\n            InputXbarRegs.INPUT12SELECT = pin;\n            break;\n        case 13:\n            InputXbarRegs.INPUT13SELECT = pin;\n            break;\n        case 14:\n            InputXbarRegs.INPUT14SELECT = pin;\n            break;\n    }\n    EDIS;\n    return 1;\n}\n\nUint32 setOutXBARForCPU2(Uint32 inData)\n{\n    volatile Uint32 *muxEnableRegAddr;\n    volatile Uint32 *muxRegAddr;\n    volatile Uint32 *muxLatchRegAddr;\n    volatile Uint32 *muxInvertRegAddr;\n    Uint16 latch = (Uint16)((inData & 0xF0000000) >> 28);\n    Uint16 invert = (Uint16)((inData & 0x0F000000) >> 24);\n    Uint16 muxVal = (Uint16)((inData & 0x00FF0000) >> 16);\n    Uint16 mux = (Uint16)((inData & 0x0000FF00) >> 8);\n    Uint16 xbar = (Uint16)(inData & 0x000000FF);\n    Uint16 muxPosition = mux%16;\n    \n    muxRegAddr          = (Uint32 *)&OutputXbarRegs + ((2*xbar)-2) + (mux/16);\n    muxEnableRegAddr    = (Uint32 *)&OutputXbarRegs + 0x10 + (xbar-1);\n    muxLatchRegAddr    = (Uint32 *)&OutputXbarRegs + 0x1B;\n    muxInvertRegAddr    = (Uint32 *)&OutputXbarRegs + 0x1C;\n    EALLOW;\n    *muxRegAddr        |= (Uint32)(muxVal & 0x3) << (2*muxPosition);\n    *muxEnableRegAddr  |= (Uint32)1 << mux;\n    *muxLatchRegAddr   |= (Uint32)(latch & 0x1) << (xbar-1);\n    *muxInvertRegAddr  |= (Uint32)(invert & 0x1) << (xbar-1);\n    EDIS;\n    return 1;\n}\n\nUint32 setEpwmXBARForCPU2(Uint32 inData)\n{\n    volatile Uint32 *muxEnableRegAddr;\n    volatile Uint32 *muxRegAddr;\n    volatile Uint32 *muxInvertRegAddr;\n    Uint16 invert = (Uint16)((inData & 0x0F000000) >> 24);\n    Uint16 muxVal = (Uint16)((inData & 0x00FF0000) >> 16);\n    Uint16 mux = (Uint16)((inData & 0x0000FF00) >> 8);\n    Uint16 xbar = (Uint16)(inData & 0x000000FF);\n    Uint16 muxPosition = mux%16;\n    \n    muxRegAddr          = (Uint32 *)&EPwmXbarRegs + ((2*xbar)-2) + (mux/16);\n    muxEnableRegAddr    = (Uint32 *)&EPwmXbarRegs + 0x10 + (xbar-1);\n    muxInvertRegAddr    = (Uint32 *)&EPwmXbarRegs + 0x1C;\n    EALLOW;\n    *muxRegAddr        |= (Uint32)(muxVal & 0x3) << (2*muxPosition);\n    *muxEnableRegAddr  |= (Uint32)1 << mux;\n    *muxInvertRegAddr  |= (Uint32)(invert & 0x1) << (xbar-1);\n    EDIS;\n    return 1;\n}\n\nUint32 setCLBXBARForCPU2(Uint32 inData)\n{\n    volatile Uint32 *muxEnableRegAddr;\n    volatile Uint32 *muxRegAddr;\n    volatile Uint32 *muxInvertRegAddr;\n    Uint16 invert = (Uint16)((inData & 0x0F000000) >> 24);\n    Uint16 muxVal = (Uint16)((inData & 0x00FF0000) >> 16);\n    Uint16 mux = (Uint16)((inData & 0x0000FF00) >> 8);\n    Uint16 xbar = (Uint16)(inData & 0x000000FF);\n    Uint16 muxPosition = mux%16;\n    \n    muxRegAddr          = (Uint32 *)&ClbXbarRegs + (2*xbar) + (mux/16);\n    muxEnableRegAddr    = (Uint32 *)&ClbXbarRegs + 0x10 + xbar;\n    muxInvertRegAddr    = (Uint32 *)&ClbXbarRegs + 0x1C;\n    EALLOW;\n    *muxRegAddr        |= (Uint32)(muxVal & 0x3) << (2*muxPosition);\n    *muxEnableRegAddr  |= (Uint32)1 << mux;\n    *muxInvertRegAddr  |= (Uint32)(invert & 0x1) << (xbar);\n    EDIS;\n    return 1;\n}\n\nUint32 setSyncSocRegsForCPU2(Uint32 inData)\n{\n    volatile Uint32 *syncSelectRegAddr;\n\t//First byte to store the sync select value\n    Uint16 syncSelectVal = (Uint16)(inData & 0x000000FFU);\n\t//Second byte to store the sync select position\n    Uint16 syncSelectPosition = (Uint16)((inData & 0x0000FF00U) >> 8U);\n    \n    syncSelectRegAddr          = (Uint32 *)&SyncSocRegs;\n    EALLOW;\n\t//Each sync select uses 3 bits to store the value.\n\t//3*syncSelectPosition ensures value is set at proper bit position\n    *syncSelectRegAddr        |= (Uint32)(syncSelectVal & 0x7U) << (3*syncSelectPosition);\n    EDIS;\n    return 1;\n}\n\n__interrupt void CPU02toCPU01IPC0IntHandler (void)\n{\n    // Continue processing messages\n    uint32_t command;\n    command = IpcRegs.IPCRECVCOM;\n    \n    switch (command)\n    {\n    case IPC_SET_BITS_16:\n        IPCLiteRtoLSetBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_SET_BITS_32:\n        IPCLiteRtoLSetBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_16:\n        IPCLiteRtoLClearBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_32:\n        IPCLiteRtoLClearBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_16:\n        IPCLiteRtoLDataWrite(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_32:\n        IPCLiteRtoLDataWrite(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_SET_BITS_16_PROTECTED:\n        IPCLiteRtoLSetBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_SET_BITS_32_PROTECTED:\n        IPCLiteRtoLSetBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_16_PROTECTED:\n        IPCLiteRtoLClearBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_32_PROTECTED:\n        IPCLiteRtoLClearBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_16_PROTECTED:\n        IPCLiteRtoLDataWrite_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_32_PROTECTED:\n        IPCLiteRtoLDataWrite_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_READ_16:\n        IPCLiteRtoLDataRead(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_READ_32:\n        IPCLiteRtoLDataRead(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_FUNC_CALL:\n        IPCLiteRtoLFunctionCall(IPC_FLAG0, IPC_FLAG31);\n        break;\n    default:\n        ErrorFlag = 1;\n        break;\n    }\n\n    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;   // Acknowledge interrupt to PIE\n    // try re-mapping the IPC INT0.\n    if (IpcRegs.IPCRECVDATA == 0x36E) // mwInitEnd\n    {\n        IpcRegs.IPCACK.all |= IPC_FLAG0;\n        IpcRegs.IPCACK.all |= IPC_FLAG31;\n        IpcRegs.IPCCLR.all |= IPC_FLAG0;\n        IpcRegs.IPCCLR.all |= IPC_FLAG31;\n        #ifdef REMAPIPCINT0\n            EALLOW;\n            PieVectTable.IPC0_INT = &IPC0_INT_isr; /* Map ISR to vector table */\n            EDIS;\n        #else\n            /* Support new HWI where ISR are registered */ \n            if (CIPC0_INT_fptr != NULL) // CIPC0_INT_fptr is set only when there is an IPC0 interrupt block and otherwise will be NULL\n            {\n                EALLOW;\n                PieVectTable.IPC0_INT = CIPC0_INT_fptr; /* Map ISR to vector table */\n                EDIS;\n            }\n            else\n            {\n                asm(\" SETC INTM\");\n                PieCtrlRegs.PIEIER1.bit.INTx13 = 0;     // IPC INT0 disable\n                asm(\" RPT #5 || NOP\");\n                IFR &= 0xFFFE;\n                PieCtrlRegs.PIEACK.all = 0x1;\n                asm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n            }\n        #endif\n    }\n}\n\n#else\n    void configureCPU2Peripherals(Uint32 gpioNumber, Uint32 gpGRegValA, Uint32 gpRegValA)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 ulRWord32 = 0;\n        Uint32 gpioData = 0x00010000;\n        gpioData = gpioData|gpioNumber;\n        gpioData = gpioData|(gpRegValA << 8);\n        gpioData = gpioData|(gpGRegValA << 10);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n        while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                        IPC_FLAG31) != STATUS_PASS)\n        {\n\n        }\n    }\n    void configureInputXBar(Uint32 gpioNumber, Uint32 inputXbarNumber)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 ulRWord32 = 0;\n        Uint32 gpioData = 0x00000000;\n        gpioData = 0x00000000;\n        gpioData = gpioData|gpioNumber;\n        gpioData = gpioData|(inputXbarNumber << 8);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[3], gpioData, IPC_FLAG31);\n        while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }    \n    }\n    void configureOutputXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert, Uint32 latch)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 gpioData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        gpioData = 0x00000000;\n        gpioData = gpioData|xbar;\n        gpioData = gpioData|(mux << 8);\n        gpioData = gpioData|(muxVal << 16);\n        gpioData = gpioData|(invert << 24);\n        gpioData = gpioData|(latch << 28);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[4], gpioData, IPC_FLAG31);\n\t\twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n    void configureEpwmXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 gpioData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        gpioData = 0x00000000;\n        gpioData = gpioData|xbar;\n        gpioData = gpioData|(mux << 8);\n        gpioData = gpioData|(muxVal << 16);\n        gpioData = gpioData|(invert << 24);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[5], gpioData, IPC_FLAG31);\n\t\twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n\t\n\tvoid configureCLBXbarInCPU2(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 gpioData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        gpioData = 0x00000000;\n        gpioData = gpioData|xbar;\n        gpioData = gpioData|(mux << 8);\n        gpioData = gpioData|(muxVal << 16);\n        gpioData = gpioData|(invert << 24);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[6], gpioData, IPC_FLAG31);\n\t\twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n\n    void configureSyncSocRegsInCPU2(Uint32 syncSelectVal , Uint32 syncSelectPosition)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 outData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        outData = outData|syncSelectVal;\n        outData = outData|(syncSelectPosition << 8);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[7], outData, IPC_FLAG31);\n    \twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n#endif\n"},{"name":"c2837xDInit.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*\n *   Copyright 2020-2022 The MathWorks, Inc.\n *\n */\n\n#include \"MW_target_hardware_resources.h\"\n#include \"F2837xD_Ipc_drivers.h\"\n#include \"F2837xD_Gpio_defines.h\"\n#include \"F2837xD_Pie_defines.h\"\n#include \"MW_F2837xD_MemoryMap.h\"\n#include \"F2837xD_sysctrl.h\"\n\n#ifdef TIC2000_SOC_BASEPRODUCT\n/* Master CPU functions */\nvoid waitUntilAllSlaveCPUsReadyToBoot(void)\n{\n    uint16_t ipcCountVar;\n    ipcCountVar = 0;\n    \n    //Wait for CPU2 to get ready to accept boot command from CPU1\n    while (((IpcRegs.IPCBOOTSTS & 0x0000000F) != C2_BOOTROM_BOOTSTS_SYSTEM_READY) && (700 > ipcCountVar))\n    {\n        ipcCountVar++;\n    }\n}\n\nvoid sendStartBootCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    uint16_t ipcCountVar;\n    //CPU01 to CPU02 IPC Boot Mode Register\n    IpcRegs.IPCBOOTMODE = C1C2_BROM_BOOTMODE_BOOT_FROM_FLASH;\n    // CPU01 To CPU02 IPC Command Register\n    IpcRegs.IPCSENDCOM  = BROM_IPC_EXECUTE_BOOTMODE_CMD;\n    // CPU01 to CPU02 IPC flag register\n    IpcRegs.IPCSET.all = 0x80000001;\n    ipcCountVar = 0;\n    // Give ~35 usec delay to start CPU2 init\n    while (500 > ipcCountVar) {\n        ipcCountVar++;\n    }\n}\n\nvoid sendStartModelInitCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    IpcRegs.IPCSET.bit.IPC30 = 1;\n}\n\nvoid waitForAckForStartModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    while (IpcRegs.IPCFLG.bit.IPC30 == 1);\n}\n\nboolean_T receiveEndModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    boolean_T status;\n\n    if (IpcRegs.IPCSTS.bit.IPC30 == 1)\n    {\n        status = 1;\n        IpcRegs.IPCACK.bit.IPC30 = 1;\n    }\n    else\n        status = 0;\n\n    return status;\n}\n\nboolean_T checkSlaveCPUReadyToRunApplication(uint32_t slaveCpuId)\n{\n    return (IpcRegs.IPCSTS.bit.IPC29 == 1);\n}\n\nvoid sendRunApplicationCmdToAllSlaveCPUs(void)\n{\n    if (IpcRegs.IPCFLG.bit.IPC29 != 1)\n        IpcRegs.IPCSET.bit.IPC29 = 1;\n}\n\n/* Slave functions */\nvoid notifySlaveCPUReadyToBoot(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForBootCommandFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForModelInitCmdFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    while (IpcRegs.IPCSTS.bit.IPC30 == 0);\n}\n\nvoid sendAckForStartModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    IpcRegs.IPCACK.bit.IPC30 = 1;\n}\n\nvoid sendEndModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    IpcRegs.IPCSET.bit.IPC30 = 1;\n}\n\nvoid sendReadyToRunApplicationToMasterCPU(uint32_t slaveCpuId)\n{\n    if (IpcRegs.IPCFLG.bit.IPC29 != 1)\n        IpcRegs.IPCSET.bit.IPC29 = 1;\n}\n\nboolean_T checkRunApplicationCmdFromMaster(uint32_t slaveCpuId)\n{\n    return (IpcRegs.IPCSTS.bit.IPC29 == 1);\n}\n\n#else\n/* Master CPU functions */\nvoid waitUntilAllSlaveCPUsReadyToBoot(void)\n{\n    \n}\n\nvoid sendStartBootCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nvoid sendStartModelInitCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nvoid waitForAckForStartModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nboolean_T receiveEndModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n    return 1;\n}\n\nboolean_T checkSlaveCPUReadyToRunApplication(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n    return 1;\n}\n\nvoid sendRunApplicationCmdToAllSlaveCPUs(void)\n{\n    \n}\n\n/* Slave functions */\nvoid notifySlaveCPUReadyToBoot(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForBootCommandFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForModelInitCmdFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid sendAckForStartModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid sendEndModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid sendReadyToRunApplicationToMasterCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nboolean_T checkRunApplicationCmdFromMaster(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n    return (boolean_T)1;\n}\n#endif\n\n\nvoid allotADCPeripheralModuleToCPU(uint16_t moduleID,uint32_t cpuId)\n{\n    #ifdef CPU1\n    /* Allot to c28xCPU1 */\n    if (1 == cpuId)\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL11.all &= ~(0x01UL << moduleID);\n        EDIS;\n    }\n    /* Allot to c28xCPU2 */\n    else\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL11.all |= (0x01UL << moduleID);\n        EDIS;\n    }\n    #endif\n}\n\nvoid allotPWMPeripheralModuleToCPU(uint16_t moduleID,uint32_t cpuId)\n{\n    #ifdef CPU1\n    /* Allot to c28xCPU1 */\n    if (1 == cpuId)\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL0.all &= ~(0x01UL << moduleID);\n        EDIS;\n    }\n    /* Allot to c28xCPU2 */\n    else\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL0.all |= (0x01UL << moduleID);\n        EDIS;\n    }\n    #endif\n}\nvoid allotSerialForExtModeToCPU(uint32_t cpuId)\n{\n    #ifdef CPU1\n    /* Allot to c28xCPU1 */\n    if (1 == cpuId)\n    {\n        EALLOW;\n        #if MW_EXTMODE_SCIMODULE == 0\n        DevCfgRegs.CPUSEL5.bit.SCI_A = 0;\n        #elif MW_EXTMODE_SCIMODULE == 1\n        DevCfgRegs.CPUSEL5.bit.SCI_B = 0;\n        #elif MW_EXTMODE_SCIMODULE == 2\n        DevCfgRegs.CPUSEL5.bit.SCI_C = 0;\n        #elif MW_EXTMODE_SCIMODULE == 3\n        DevCfgRegs.CPUSEL5.bit.SCI_D = 0;\n        #endif\n        EDIS;\n    }\n    /* Allot to c28xCPU2 */\n    else if(2 == cpuId)\n    {\n        EALLOW;\n        #if MW_EXTMODE_SCIMODULE == 0\n        DevCfgRegs.CPUSEL5.bit.SCI_A = 1;\n        #elif MW_EXTMODE_SCIMODULE == 1\n        DevCfgRegs.CPUSEL5.bit.SCI_B = 1;\n        #elif MW_EXTMODE_SCIMODULE == 2\n        DevCfgRegs.CPUSEL5.bit.SCI_C = 1;\n        #elif MW_EXTMODE_SCIMODULE == 3\n        DevCfgRegs.CPUSEL5.bit.SCI_D = 1;\n        #endif\n        EDIS;\n    }\n    else /* for ARM*/\n    {\n    }\n    #endif\n}\n/* LocalWords:  IPC usec Bootstatus BOOTROM BOOTSTS\n */\n"},{"name":"c2837xDSchedulerTimer0.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2021 The MathWorks, Inc. */\n\n#include \"MW_f2837xD_includes.h\"\n#include \"MW_c28xx_pie.h\"\n\nextern void rt_OneStep(void);\nextern uint32_t mwInitStart;\nextern uint32_t mwInitEnd;\n\ninterrupt void TINT0_isr(void)\n{\n      #ifdef PIEMASK0\n        volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;\n      #endif\n      #ifdef PIEMASK1\n        volatile unsigned int PIEIER2_stack_save  = PieCtrlRegs.PIEIER2.all;\n      #endif\n      #ifdef PIEMASK2\n        volatile unsigned int PIEIER3_stack_save  = PieCtrlRegs.PIEIER3.all;\n      #endif\n      #ifdef PIEMASK3\n        volatile unsigned int PIEIER4_stack_save  = PieCtrlRegs.PIEIER4.all;\n      #endif\n      #ifdef PIEMASK4\n        volatile unsigned int PIEIER5_stack_save  = PieCtrlRegs.PIEIER5.all;\n      #endif\n      #ifdef PIEMASK5\n        volatile unsigned int PIEIER6_stack_save  = PieCtrlRegs.PIEIER6.all;\n      #endif\n      #ifdef PIEMASK6\n        volatile unsigned int PIEIER7_stack_save  = PieCtrlRegs.PIEIER7.all;\n      #endif\n      #ifdef PIEMASK7\n        volatile unsigned int PIEIER8_stack_save  = PieCtrlRegs.PIEIER8.all;\n      #endif\n      #ifdef PIEMASK8\n        volatile unsigned int PIEIER9_stack_save  = PieCtrlRegs.PIEIER9.all;\n      #endif\n      #ifdef PIEMASK9\n        volatile unsigned int PIEIER10_stack_save = PieCtrlRegs.PIEIER10.all;\n      #endif\n      #ifdef PIEMASK10\n        volatile unsigned int PIEIER11_stack_save = PieCtrlRegs.PIEIER11.all;\n      #endif\n      #ifdef PIEMASK11\n        volatile unsigned int PIEIER12_stack_save = PieCtrlRegs.PIEIER12.all;\n      #endif\n\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all &= ~PIEMASK0;      /* disable group1 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all &= ~PIEMASK1;      /* disable group2 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all &= ~PIEMASK2;      /* disable group3 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all &= ~PIEMASK3;      /* disable group4 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all &= ~PIEMASK4;      /* disable group5 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all &= ~PIEMASK5;      /* disable group6 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all &= ~PIEMASK6;      /* disable group7 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all &= ~PIEMASK7;      /* disable group8 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all &= ~PIEMASK8;      /* disable group9 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all &= ~PIEMASK9;     /* disable group10 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all &= ~PIEMASK10;    /* disable group11 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all &= ~PIEMASK11;    /* disable group12 lower/equal priority interrupts */\n      #endif\n\t  #ifdef PIEMASK12\n\t\tIER &= ~(M_INT13);\n      #endif\n\t  #ifdef PIEMASK13\n\t\tIER &= ~(M_INT14);\n      #endif\n\t  \n      asm(\" RPT #5 || NOP\");               /* wait 5 cycles */\n      IFR &= ~IFRMASK;                           /* eventually disable lower/equal priority pending interrupts */\n      PieCtrlRegs.PIEACK.all = IFRMASK;          /* ACK to allow other interrupts from the same group to fire */\n      IER |= 1;\n      EINT;                                /* global interrupt enable */\n      rt_OneStep();\n      DINT;                                /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;/*restore PIEIER register that was modified */\n      #endif  \n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all = PIEIER2_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all = PIEIER3_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all = PIEIER4_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all = PIEIER5_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all = PIEIER6_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all = PIEIER7_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all = PIEIER8_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all = PIEIER9_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all= PIEIER10_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all= PIEIER11_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all= PIEIER12_stack_save;/*restore PIEIER register that was modified */\n      #endif\n\t  #ifdef PIEMASK12\n\t\tIER |= M_INT13;\n      #endif\n\t  #ifdef PIEMASK13\n\t\tIER |= M_INT14;\n      #endif\n}\n\nvoid configureTimer0(float baseRate, float systemClock)\n{\n  #ifndef TIC2000_SOC_BASEPRODUCT\n    #ifdef CPU1\n        EINT;\n        uint32_t ipcCountVar = 0;\n        if (0x425 == mwInitStart)\n        {\n            /* Wait until completion of CPU2 GPIO initialization */\n            while ((0x36E != mwInitEnd))\n            {\n                ipcCountVar++;\n            }\n        }\n        DINT;\n    #else\n\t      uint32_t *pulMsgRam;\n\t      pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        IPCLiteLtoRDataWrite(IPC_FLAG0, pulMsgRam[2], 0x36E,\n                         IPC_LENGTH_32_BITS, IPC_FLAG31);\n    #endif\n  #endif\n    \n    /* InitCpuTimers() - CPU Timers are initialized in \n     * MW_c28xx_board.c in the generated code.\n     */\n\n\t/* Configure CPU-Timer 0 to interrupt every base rate. */\n\t/* Parameters:  Timer Pointer, CPU Freq in MHz, Period in usec. */\n\tConfigCpuTimer(&CpuTimer0, systemClock, baseRate * 1000000);\n\tStartCpuTimer0();\n\n    #ifdef TIC2000_SOC_BASEPRODUCT\n\tPieCtrlRegs.PIEIFR1.bit.INTx7 = 1;   /* Set Pending interrupt for TINT0. TINT0 will trigger as soon as the its interrupt is enabled*/\n    #endif\n    \n\tEALLOW;\n\tPieVectTable.TIMER0_INT = &TINT0_isr;     /* Hook interrupt to the ISR*/\n\tEDIS;\n\n\tPieCtrlRegs.PIEIER1.bit.INTx7 = 1;   /* Enable interrupt TINT0 */\n\tIER |= M_INT1;\n}\n\nvoid stopTimer0(void)\n{\n    StopCpuTimer0();\n}\nvoid enableTimer0Interrupt(void)\n{\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n\tEALLOW;\n\tPieCtrlRegs.PIEIER1.all |= (1 << 6); /* Enable PIER bit for timer 0 */\n\tEDIS;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n}\n\nbool disableTimer0Interrupt(void)\n{\n    bool isrEnabled = false;\n\t\n    asm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n    \n    isrEnabled = PieCtrlRegs.PIEIER1.all & (1 << 6) ;\n\tEALLOW;\n\tPieCtrlRegs.PIEIER1.all &= ~(1 << 6); /* Disable PIER bit for timer 0 */\n\tasm(\" RPT #5 || NOP\");\n\tIFR &= 0xFFFE;\n\tPieCtrlRegs.PIEACK.all = 0x1;\n\tEDIS;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n    \n    return isrEnabled;\n}\n\nvoid restoreTimer0Interrupt(bool isrStatus){\n    if(isrStatus)\n        enableTimer0Interrupt();\n    else\n        disableTimer0Interrupt();\n}\n"},{"name":"clb.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\driverlib\\f2837xd\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   clb.c\n//\n// TITLE:  C28x CLB driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"clb.h\"\n\n//*****************************************************************************\n//\n// CLB_configCounterLoadMatch\n//\n//*****************************************************************************\nvoid CLB_configCounterLoadMatch(uint32_t base, CLB_Counters counterID,\n                               uint32_t load, uint32_t match1, uint32_t match2)\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    EALLOW;\n    switch(counterID)\n    {\n        case CLB_CTR0:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_MATCH2, match2);\n            break;\n\n        case CLB_CTR1:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_MATCH2, match2);\n            break;\n\n        case CLB_CTR2:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_MATCH2, match2);\n            break;\n\n        default:\n            //\n            // Invalid counterID value\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// CLB_clearFIFOs\n//\n//*****************************************************************************\nvoid CLB_clearFIFOs(uint32_t base)\n{\n    uint16_t i;\n\n    ASSERT(CLB_isBaseValid(base));\n\n    for(i = 0U; i < CLB_FIFO_SIZE; i++)\n    {\n        HWREG(base + CLB_DATAEXCH + CLB_O_PULL(i)) = 0U;\n    }\n\n    HWREG(base + CLB_LOGICCTL + CLB_O_BUF_PTR) = 0U;\n}\n\n//*****************************************************************************\n//\n// CLB_writeFIFOs\n//\n//*****************************************************************************\nvoid CLB_writeFIFOs(uint32_t base , const uint32_t pullData[])\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    //\n    // Clear the FIFO and pointer\n    //\n    CLB_clearFIFOs(base);\n\n    //\n    // Write data into the FIFO.\n    //\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(0)) = pullData[0U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(1)) = pullData[1U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(2)) = pullData[2U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(3)) = pullData[3U];\n}\n\n//*****************************************************************************\n//\n// CLB_readFIFOs\n//\n//*****************************************************************************\nvoid CLB_readFIFOs(uint32_t base , uint32_t pushData[])\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    //\n    // Read data from the FIFO.\n    //\n    pushData[0U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(0)) ;\n    pushData[1U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(1)) ;\n    pushData[2U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(2)) ;\n    pushData[3U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(3)) ;\n}\n\n\n"},{"name":"dma.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\driverlib\\f2837xd\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   dma.c\n//\n// TITLE:  C28x DMA driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"dma.h\"\n\n//*****************************************************************************\n//\n// DMA_configAddresses\n//\n//*****************************************************************************\nvoid DMA_configAddresses(uint32_t base, const void *destAddr,\n                         const void *srcAddr)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    EALLOW;\n\n    //\n    // Set up SOURCE address.\n    //\n    HWREG(base + DMA_O_SRC_BEG_ADDR_SHADOW) = (uint32_t)srcAddr;\n    HWREG(base + DMA_O_SRC_ADDR_SHADOW)     = (uint32_t)srcAddr;\n\n    //\n    // Set up DESTINATION address.\n    //\n    HWREG(base + DMA_O_DST_BEG_ADDR_SHADOW) = (uint32_t)destAddr;\n    HWREG(base + DMA_O_DST_ADDR_SHADOW)     = (uint32_t)destAddr;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configBurst\n//\n//*****************************************************************************\nvoid DMA_configBurst(uint32_t base, uint16_t size, int16_t srcStep,\n                     int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT((size >= 1U) && (size <= 32U));\n\n    EALLOW;\n\n    //\n    // Set up BURST registers.\n    //\n    HWREGH(base + DMA_O_BURST_SIZE)     = size - 1U;\n    HWREGH(base + DMA_O_SRC_BURST_STEP) = srcStep;\n    HWREGH(base + DMA_O_DST_BURST_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configTransfer\n//\n//*****************************************************************************\nvoid DMA_configTransfer(uint32_t base, uint32_t transferSize, int16_t srcStep,\n                        int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT(transferSize <= 0x10000U);\n\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers.\n    //\n    HWREGH(base + DMA_O_TRANSFER_SIZE)     = (uint16_t)(transferSize - 1U);\n    HWREGH(base + DMA_O_SRC_TRANSFER_STEP) = srcStep;\n    HWREGH(base + DMA_O_DST_TRANSFER_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configWrap\n//\n//*****************************************************************************\nvoid DMA_configWrap(uint32_t base, uint32_t srcWrapSize, int16_t srcStep,\n                    uint32_t destWrapSize, int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT((srcWrapSize <= 0x10000U) || (destWrapSize <= 0x10000U));\n\n    EALLOW;\n\n    //\n    // Set up WRAP registers.\n    //\n    HWREGH(base + DMA_O_SRC_WRAP_SIZE) = (uint16_t)(srcWrapSize - 1U);\n    HWREGH(base + DMA_O_SRC_WRAP_STEP) = srcStep;\n\n    HWREGH(base + DMA_O_DST_WRAP_SIZE) = (uint16_t)(destWrapSize - 1U);\n    HWREGH(base + DMA_O_DST_WRAP_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configMode\n//\n//*****************************************************************************\nvoid DMA_configMode(uint32_t base, DMA_Trigger trigger, uint32_t config)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    EALLOW;\n\n    //\n    // Set up trigger selection in the CMA/CLA trigger source selection\n    // registers. These are considered part of system control.\n    //\n    switch(base)\n    {\n        case DMA_CH1_BASE:\n            //\n            // Channel 1\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH1_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH1_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH1_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH1_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 1U;\n            break;\n\n        case DMA_CH2_BASE:\n            //\n            // Channel 2\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH2_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH2_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH2_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH2_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 2U;\n            break;\n\n        case DMA_CH3_BASE:\n            //\n            // Channel 3\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH3_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH3_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH3_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH3_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 3U;\n            break;\n\n        case DMA_CH4_BASE:\n            //\n            // Channel 4\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH4_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH4_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH4_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH4_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 4U;\n            break;\n\n        case DMA_CH5_BASE:\n            //\n            // Channel 5\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL2_CH5_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL2_CH5_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH5_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH5_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 5U;\n            break;\n\n        case DMA_CH6_BASE:\n            //\n            // Channel 6\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL2_CH6_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL2_CH6_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH6_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH6_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 6U;\n            break;\n\n        default:\n            //\n            // Invalid base.\n            //\n            break;\n    }\n\n    //\n    // Write the configuration to the mode register.\n    //\n    HWREGH(base + DMA_O_MODE) &= ~(DMA_MODE_DATASIZE | DMA_MODE_CONTINUOUS |\n                                   DMA_MODE_ONESHOT);\n    HWREGH(base + DMA_O_MODE) |= config;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configChannel\n//\n//*****************************************************************************\nvoid DMA_configChannel(uint32_t base, const DMA_ConfigParams *transfParams)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    //\n    // Configure DMA Channel\n    //\n    DMA_configAddresses(base, (const void *)transfParams->destAddr,\n                        (const void *)transfParams->srcAddr);\n\n    //\n    // Configure the size of each burst and the address step size\n    //\n    DMA_configBurst(base, transfParams->burstSize, transfParams->srcBurstStep,\n                    transfParams->destBurstStep);\n\n    //\n    // Configure the transfer size and the address step that is\n    // made after each burst.\n    //\n    DMA_configTransfer(base, transfParams->transferSize,\n                       transfParams->srcTransferStep,\n                       transfParams->destTransferStep);\n\n    //\n    // Configure the DMA channel's wrap settings\n    //\n    DMA_configWrap(base, transfParams->srcWrapSize, transfParams->srcWrapStep,\n                   transfParams->destWrapSize, transfParams->destWrapStep);\n\n    //\n    // Configure the DMA channel's trigger and mode\n    //\n    DMA_configMode(base, transfParams->transferTrigger,\n                   transfParams->transferMode | transfParams->reinitMode |\n                   transfParams->configSize);\n\n    //\n    // Enable the selected peripheral trigger to start a DMA transfer\n    //\n    DMA_enableTrigger(base);\n\n    if(transfParams->enableInterrupt)\n    {\n        //\n        // Set the channel interrupt mode\n        //\n        DMA_setInterruptMode(base, transfParams->interruptMode);\n\n        //\n        // Enable the indicated DMA channel interrupt source\n        //\n        DMA_enableInterrupt(base);\n    }\n    else\n    {\n        //\n        // Disable the indicated DMA channel interrupt source\n        //\n        DMA_disableInterrupt(base);\n    }\n}\n\n"},{"name":"memcpy_fast.asm","type":"other","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\libraries\\dsp\\FPU\\c28\\source\\fpu32\\utility","tag":"","groupDisplay":"Other files","code":";;#############################################################################\n;;! \\file source/vector/memcpy_fast.asm\n;;!\n;;! \\brief Optimized memory copy, src->dest.\n;;! \\author David M. Alter\n;;! \\date   07/06/11\n;;\n;;\n;; HISTORY:\n;;   07/06/11 - original (D. Alter)\n;;   10/23/14 - Added note about non-interruptibility and no support for\n;;              above 22 bit address. (D. Alter)\n;;\n;; DESCRIPTION: Optimized memory copy, src->dest.\n;;\n;; FUNCTION: \n;;   extern void memcpy_fast(void* dst, const void* src, Uint16 N);\n;;\n;; USAGE:       memcpy_fast(dst, src, N);\n;;\n;; PARAMETERS:  void* dst = pointer to destination\n;;              const void* src = pointer to source\n;;              N = number of 16-bit words to copy\n;;\n;; RETURNS:     none\n;;\n;; BENCHMARK:   1 cycle per copy + ~20 cycles of overhead (including\n;;   the call and return).  This assumes src and dst are located in\n;;   different internal RAM blocks.\n;;\n;; NOTES:\n;;   1) The function checks for the case of N=0 and just returns if true.\n;;   2) This function is not interruptible.  Use memcpy_fast_far instead for \n;;      interruptibility.\n;;   3) This function does not support memory above 22 bits address.\n;;      For input data above 22 bits address, use memcpy_fast_far instead.\n;;\n;;  Group:            C2000\n;;  Target Family:    C28x+FPU32\n;;\n;;#############################################################################\n;;\n;;\n;; $Copyright: Copyright (C) 2023 Texas Instruments Incorporated -\n;;             http://www.ti.com/ ALL RIGHTS RESERVED $\n;;#############################################################################\n        .if __TI_EABI__\n        .asg memcpy_fast, _memcpy_fast\n        .endif\n    \n        .global _memcpy_fast\n        .text\n\n_memcpy_fast:\n        ADDB    AL, #-1                ;Repeat \"N-1\" times\n        BF      done, NC               ;Branch if N was zero\n        MOVL    XAR7, XAR5             ;XAR7 = XAR5 = dst\n        RPT     @AL\n    ||  PREAD   *XAR4++, *XAR7         ;Do the copy\n\n;Finish up\ndone:\n        LRETR                          ;return\n\n;end of function memcpy_fast()\n;*********************************************************************\n\n       .end\n;;#############################################################################\n;;  End of File\n;;#############################################################################\n"},{"name":"mw_soc_c2000_ipc.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_soc\\src","tag":"","groupDisplay":"Other files","code":"/* mw_soc_c2000_ipc.c\n*\n* Copyright 2020-2024 The MathWorks, Inc.\n*\n*/\n#ifdef IPC_BLOCK_INCLUDED\n#include \"mw_soc_c2000_ipc.h\"\n\n#if !defined(__TMS320C28XX_CLA__) && !defined(CM)\n#pragma CODE_SECTION(MW_IPC_Write, \"ramfuncs\");\n#pragma CODE_SECTION(MW_IPC_Read, \"ramfuncs\");\n#endif\n\n/* Add each channel (symbols) some sections and assign to the GS0 or GS1.\n* The size of the symbols shall reflect the dataLength of the data to be sent.\n* On receive, we will use the senders CPU location in GS and access it, not required to set any length.\n*/\n#define DEBUG  0  /* Debugging info 1:on 0:off */\n#if DEBUG\n#include <stdlib.h> /*printf*/\n#endif\n#ifndef __TMS320C28XX_CLA__\n#include <string.h> /* for memcpy*/\n#endif /*__TMS320C28XX_CLA__*/\n\n/* Add each channel (symbols) some sections and assign to the GS0 or GS1.\n* The size of the symbols shall reflect the dataLength of the data to be sent.\n* On receive, we will use the senders CPU location in GS and access it, not required to set any length.\n*/\n#define IPC_DTYPE_INDEX_32_BITS     0x00000006 /* From index 6 data type needs 32 bits (1-5 index needs 15 bits, 6-8 index needs 32 bits)*/\n\n#define ADDRESS_GRANULATIRY (2)\n\n#ifndef __TMS320C28XX_CLA__\n\n/* total number of connections/channels between n cores = n(n-1)/2 */\n#define TOTAL_CHANNELS_BETWEEN_PU (NUM_CORES*(NUM_CORES - 1) / 2)\n\n#if defined(MW_F2838X) || defined(MW_F28P65X)\n#if defined(CPU1)\nvolatile uint32_t *setReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.all);\nvolatile uint32_t *stsReg = &(Cpu1toCpu2IpcRegs.CPU2TOCPU1IPCSTS.all);\nvolatile uint32_t *ackReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.all);\nvolatile uint32_t *clrReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCCLR.all);\nvolatile uint32_t *flgReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCFLG.all);\n#elif defined (CPU2)\nvolatile uint32_t *setReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.all);\nvolatile uint32_t *stsReg = &(Cpu2toCpu1IpcRegs.CPU1TOCPU2IPCSTS.all);\nvolatile uint32_t *ackReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.all);\nvolatile uint32_t *clrReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCCLR.all);\nvolatile uint32_t *flgReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCFLG.all);\n#elif defined (CM)\nvolatile IPC_Flag_Ctr_Reg_t  *IPC_CMTOCPU1_FlagReg = (volatile IPC_Flag_Ctr_Reg_t *) IPC_CMTOCPU1_BASE;\nvolatile IPC_Flag_Ctr_Reg_t  *IPC_CMTOCPU2_FlagReg = (volatile IPC_Flag_Ctr_Reg_t *) IPC_CMTOCPU2_BASE;\n#endif\n#else\nvolatile uint32_t *setReg = &(IpcRegs.IPCSET.all);\nvolatile uint32_t *stsReg = &(IpcRegs.IPCSTS.all);\nvolatile uint32_t *ackReg = &(IpcRegs.IPCACK.all);\nvolatile uint32_t *clrReg = &(IpcRegs.IPCCLR.all);\nvolatile uint32_t *flgReg = &(IpcRegs.IPCFLG.all);\n#endif\n\n/* Every connection betweeen 2 processing units requires an independent ipcHandle\n* In this 2D array,\n*      each row corresponds to one connection between 2 PUs,\n*      and each column corresponds to one channel\n* For example,\n*      ipcHandle[0][2] --> 2nd channel of CPU1 to CPU2 channel\n*      ipcHandle[2][0] --> 0th channel of CPU2 to CM channel\n* This will be used with notation ipcHandle[IpcParams->IPCBetween][IpcParams->ChNum]\n*\n* ipcHandle[0][x] --> CPU1 CPU2 channel\n* ipcHandle[1][x] --> CPU1 CM channel\n* ipcHandle[2][x] --> CPU2 CM channel\n*/\n\n/* The IPC handle contains some basic information with the pointers to the memory where the IPC data is stored \n* IPC handles are allocated based on the number of channels required\n* For every IPC core pair,\n*      there is a ipcChannelXXXList that contains the list of channel numbers used,\n*      and handles are allocated only for these\n* For example,\n*      ipcChannelCPUList[] = {3, 4, 12, 30} --> There are 4 channels between CPU1 and CPU2\n*      ipcChannelCPU1CMList[] = {2, 3} --> There are 3 channels between CPU1 and CM\n*      ipcHandle[3][4] --> Only 4 handles are allocated, which is the maximum required\n*/\n\n/* The IPC data is stored in the respective RAMs (see mw_soc_c2000_ipc.h for more information)\n* The structure of the IPC data is broken down into\n*      IPC channel information that contains the pointer information of IPCChannelStruct_T and is stored for all 32 channels\n*      IPC buffer data is configured as per the required channel buffer sizes\n* For example,\n*      Channel 0 - head\n*      Channel 0 - tail\n*      ...\n*      Channel 0 - bufferStartAdd\n*      Channel 1 - head\n*      ...\n*      Channel 32 - bufferStartAdd\n*      Channel 0 - buffer data\n*      Channel 1 - buffer data\n* The only exception is for c28x-CM IPC where an additional pointer is required per channel, as part of the channel information, due to the different views\n*/\n\n#define MW_NUM_IPC_CHANNELS_TOTAL 32 // This macro is used to determine the offset where the IPC data is stored and is not used while allocating handles\n\n#if defined(CPU1_CPU2_IPC)\n    #if defined(CPU1)\n    uint16_t isInitialized = 0; // Boolean to initialize GS RAM R/W access\n    #endif\n\nvolatile uint32_t buffCPUOffsetInWords = 0;\nconst uint16_t ipcChannelCPUList[] = MW_IPC_CHANNELS_CPU_LIST;\n#endif\n\n#if defined(CPU1_CM_IPC)\n    #if defined(CPU1)\n    volatile uint32_t buffCPU1CMOffsetInWords = MW_NUM_IPC_CHANNELS_TOTAL * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR));\n    #elif defined(CM)\n    volatile uint32_t buffCPU1CMOffsetInBytes = MW_NUM_IPC_CHANNELS_TOTAL * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR));\n    #endif\nconst uint16_t ipcChannelCPU1CMList[] = MW_IPC_CHANNELS_CPU1CM_LIST;\n#endif\n\n#if defined(CPU2_CM_IPC) && (defined(CPU2) || defined(CM))\n    #if defined(CPU2)\n    volatile uint32_t buffCPU2CMOffsetInWords = MW_NUM_IPC_CHANNELS_TOTAL * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR));\n    #elif defined(CM)\n    volatile uint32_t buffCPU2CMOffsetInBytes = MW_NUM_IPC_CHANNELS_TOTAL * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR));\n    #endif\nconst uint16_t ipcChannelCPU2CMList[] = MW_IPC_CHANNELS_CPU2CM_LIST;\n#endif\n\nvolatile IPC_CPUHandle_T ipcHandle[TOTAL_CHANNELS_BETWEEN_PU][MW_NUM_IPC_CHANNELS];\n\n#if defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n#pragma DATA_SECTION(ipcHandleForCLA,\"Cla1DataRam0\");\nvolatile uint32_t buffCPUCLAOffsetInWords = MW_NUM_IPC_CHANNELS_TOTAL * (8*sizeof(uint16_t) + sizeof(CLA_PTR));\nconst uint16_t ipcChannelCPUCLAList[] = MW_IPC_CHANNELS_CPUCLA_LIST;\n#endif\n\nvolatile IPC_CPUHandle_T ipcHandleForCLA[MW_NUM_IPC_CHANNELS_CPUCLA];\n\nuint16_t MW_bSearch_IPC_Channels(const uint16_t sorted_array[], uint16_t size, uint16_t target) {\n    uint16_t left = 0;\n    uint16_t right = size - 1;\n\n    while (left <= right) {\n        uint16_t mid = left + ((right - left) >> 1); // Right shift operator for division by 2 \n\n        if (sorted_array[mid] == target)\n            return mid; // Found the target index\n        else if (sorted_array[mid] < target)\n            left = mid + 1; // Continue searching in the right half\n        else\n            right = mid - 1; // Continue searching in the left half\n    }\n\n    return 0; // Target index not found\n}\n\nMW_IPC_Handle MW_IPC_Init(MW_IPC_Params_T *IpcParams)\n{\n    uint32_t ipcflag = 0x00000001, ipcflag1;\n    /* Reset the IPC Status flags*/\n    ipcflag1 = ipcflag << IpcParams->ChNum;\n    #if defined(CPU1) || defined(CPU2)\n    (*clrReg) |= ipcflag1;\n    #elif defined(CM)\n    IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n    IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n    #endif\n\n    #ifdef CPU1_CPU2_IPC\n    if(IpcParams->IPCBetween == IPC_CPU1CPU2)\n    {\n        // Initialize required GS RAM for each c28x core\n        #if defined(CPU1)\n        if (!isInitialized)\n        {\n            uint32_t i = 0;\n            uint32_t MemCfgRegVar = 0;\n\n            // Set access of GS RAM for CPU1\n            EALLOW;\n            #if defined(MW_F28P65X)\n                for (i=((uint32_t)RAMGS_IPC_CPU1_START) >> 12; i < (((uint32_t)RAMGS_IPC_CPU1_LENGTH + (uint32_t)RAMGS_IPC_CPU1_START) >> 12); i = i + 2)\n                {\n                    MemCfgRegVar = MemCfgRegVar & (~(1UL<<((i - RAMGS_START)/2)));\n                }\n                \n                // Set access of GS RAM for CPU2\n                for (i=((uint32_t)RAMGS_IPC_CPU2_START) >> 12; i < (((uint32_t)RAMGS_IPC_CPU2_LENGTH + (uint32_t)RAMGS_IPC_CPU2_START) >> 12); i = i + 2)\n                {\n                    MemCfgRegVar = MemCfgRegVar | (1UL<<((i - RAMGS_START)/2));\n                }\n            #else\n                for (i=((uint32_t)RAMGS_IPC_CPU1_START) >> 12; i < (((uint32_t)RAMGS_IPC_CPU1_LENGTH + (uint32_t)RAMGS_IPC_CPU1_START) >> 12); i++)\n                {\n                    MemCfgRegVar = MemCfgRegVar & (~(1UL<<(i - RAMGS_START)));\n                }\n                \n                // Set access of GS RAM for CPU2\n                for (i=((uint32_t)RAMGS_IPC_CPU2_START) >> 12; i < (((uint32_t)RAMGS_IPC_CPU2_LENGTH + (uint32_t)RAMGS_IPC_CPU2_START) >> 12); i++)\n                {\n                    MemCfgRegVar = MemCfgRegVar | (1UL<<(i - RAMGS_START));\n                }\n            #endif\n            MemCfgRegs.GSxMSEL.all = MemCfgRegs.GSxMSEL.all | MemCfgRegVar;\n            EDIS;\n            isInitialized = 1;\n        }\n        #endif\n\n        volatile uint16_t blkC1C2ChIndex = MW_bSearch_IPC_Channels(ipcChannelCPUList, MW_NUM_IPC_CHANNELS_CPU, IpcParams->ChNum);\n\n        /* CPU1 to CPU2 channel init */\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.chNum = IpcParams->ChNum;\n\n        volatile uint32_t buffAddrCPU1ToCPU2 = C1TOC2_SHRD_MSG_RAM + (IpcParams->ChNum * (8*sizeof(uint16_t) + sizeof(CLA_PTR)));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.head.ptr = (uint16_t *)buffAddrCPU1ToCPU2;\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.tail.ptr = (uint16_t *)(buffAddrCPU1ToCPU2 + 1*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.full.ptr = (uint16_t *)(buffAddrCPU1ToCPU2 + 2*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.mutex.ptr = (uint16_t *)(buffAddrCPU1ToCPU2 + 3*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.overwrite.ptr = (uint16_t *)(buffAddrCPU1ToCPU2 + 4*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.lastReadStatus.ptr = (uint16_t *)(buffAddrCPU1ToCPU2 + 5*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.bufferLength.ptr = (uint16_t *)(buffAddrCPU1ToCPU2 + 6*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCPU1ToCPU2 + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCPU1ToCPU2 + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        #if defined(CPU1)\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.head.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.tail.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.full.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.mutex.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.overwrite.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.lastReadStatus.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.bufferStartAdd.ptr)).ptr =  (uint16_t *)(C1TOC2_IPC_GS_RAM + buffCPUOffsetInWords);\n\n        buffCPUOffsetInWords = buffCPUOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes) / 2);\n\n        if (ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.intEnable)\n        {\n            switch (ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU1.chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC0 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC0 = 1;\n                    #endif\n                    break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC1 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC1 = 1;\n                    #endif\n                    break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC2 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC2 = 1;\n                    #endif\n                    break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC3 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC3 = 1;\n                    #endif\n                    break;\n            }\n        }\n        #endif\n\n        /* CPU2 to CPU1 channel init */\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.chNum = IpcParams->ChNum;\n\n        volatile uint32_t buffAddrCPU2ToCPU1 = C2TOC1_SHRD_MSG_RAM + (IpcParams->ChNum * (8*sizeof(uint16_t) + sizeof(CLA_PTR)));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.head.ptr = (uint16_t *)buffAddrCPU2ToCPU1;\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.tail.ptr = (uint16_t *)(buffAddrCPU2ToCPU1 + 1*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.full.ptr = (uint16_t *)(buffAddrCPU2ToCPU1 + 2*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.mutex.ptr = (uint16_t *)(buffAddrCPU2ToCPU1 + 3*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.overwrite.ptr = (uint16_t *)(buffAddrCPU2ToCPU1 + 4*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.lastReadStatus.ptr = (uint16_t *)(buffAddrCPU2ToCPU1 + 5*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.bufferLength.ptr = (uint16_t *)(buffAddrCPU2ToCPU1 + 6*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCPU2ToCPU1 + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCPU2ToCPU1 + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        #if defined(CPU2)\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.head.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.tail.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.full.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.mutex.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.overwrite.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.lastReadStatus.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.bufferStartAdd.ptr)).ptr = (uint16_t *)(C2TOC1_IPC_GS_RAM + buffCPUOffsetInWords);\n\n        buffCPUOffsetInWords = buffCPUOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes) / 2);\n\n        if (ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.intEnable)\n        {\n            switch (ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_PU2.chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC0 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC0 = 1;\n                    #endif\n                    break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC1 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC1 = 1;\n                    #endif\n                    break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC2 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC2 = 1;\n                    #endif\n                    break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC3 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC3 = 1;\n                    #endif\n                    break;\n            }\n        }\n        #endif\n\n        ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex].H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandle[IpcParams->IPCBetween][blkC1C2ChIndex];\n    }\n    #endif\n    #ifdef CPU1_CM_IPC\n    if(IpcParams->IPCBetween == IPC_CPU1CM)\n    {\n        volatile uint16_t blkC1CMChIndex = MW_bSearch_IPC_Channels(ipcChannelCPU1CMList, MW_NUM_IPC_CHANNELS_CPU1CM, IpcParams->ChNum);\n\n        /* CPU1 to CM channel init */\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.chNum = IpcParams->ChNum;\n\n        #if defined(CPU1)\n        volatile uint32_t buffAddrCPU1ToCM = C1TOCM_SHRD_MSG_RAM_C28XVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #elif defined(CM)\n        volatile uint32_t buffAddrCPU1ToCM = C1TOCM_SHRD_MSG_RAM_CMVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #endif\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.head.ptr = (uint16_t *)buffAddrCPU1ToCM;\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.tail.ptr = (uint16_t *)(buffAddrCPU1ToCM + 1*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.full.ptr = (uint16_t *)(buffAddrCPU1ToCM + 2*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.mutex.ptr = (uint16_t *)(buffAddrCPU1ToCM + 3*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.overwrite.ptr = (uint16_t *)(buffAddrCPU1ToCM + 4*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.lastReadStatus.ptr = (uint16_t *)(buffAddrCPU1ToCM + 5*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.bufferLength.ptr = (uint16_t *)(buffAddrCPU1ToCM + 6*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCPU1ToCM + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCPU1ToCM + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        #if defined(CPU1)\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.head.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.tail.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.full.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.mutex.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.overwrite.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.lastReadStatus.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.bufferStartAdd.ptr)).ptr =  (uint16_t *)(C1TOCM_SHRD_MSG_RAM_C28XVIEW + buffCPU1CMOffsetInWords);\n        (*(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.bufferStartAdd.ptr + 1)).ptr = (uint16_t *)(C1TOCM_SHRD_MSG_RAM_CMVIEW + (buffCPU1CMOffsetInWords * 2));\n\n        buffCPU1CMOffsetInWords = buffCPU1CMOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes) / 2);\n\n        if (ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.intEnable)\n        {\n            switch (ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU1.chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC0 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC0 = 1;\n                    #endif\n                    break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC1 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC1 = 1;\n                    #endif\n                    break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC2 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC2 = 1;\n                    #endif\n                    break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC3 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC3 = 1;\n                    #endif\n                    break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC4 = 1 ;\n                    #endif\n                    break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC5 = 1 ;\n                    #endif\n                    break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC6 = 1 ;\n                    #endif\n                    break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC7 = 1 ;\n                    #endif\n                    break;\n            }\n        }\n        #endif\n\n        /* CM to CPU1 channel init */\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.chNum = IpcParams->ChNum;\n\n        #if defined(CPU1)\n        volatile uint32_t buffAddrCMToCPU1 = CMTOC1_SHRD_MSG_RAM_C28XVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #elif defined(CM)\n        volatile uint32_t buffAddrCMToCPU1 = CMTOC1_SHRD_MSG_RAM_CMVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #endif\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.head.ptr = (uint16_t *)buffAddrCMToCPU1;\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.tail.ptr = (uint16_t *)(buffAddrCMToCPU1 + 1*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.full.ptr = (uint16_t *)(buffAddrCMToCPU1 + 2*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.mutex.ptr = (uint16_t *)(buffAddrCMToCPU1 + 3*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.overwrite.ptr = (uint16_t *)(buffAddrCMToCPU1 + 4*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.lastReadStatus.ptr = (uint16_t *)(buffAddrCMToCPU1 + 5*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.bufferLength.ptr = (uint16_t *)(buffAddrCMToCPU1 + 6*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCMToCPU1 + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCMToCPU1 + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        #if defined(CM)\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.head.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.tail.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.full.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.mutex.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.overwrite.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.lastReadStatus.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.bufferStartAdd.ptr)).ptr =  (uint16_t *)(CMTOC1_SHRD_MSG_RAM_CMVIEW + buffCPU1CMOffsetInBytes);\n        (*(ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.bufferStartAdd.ptr + 1)).ptr = (uint16_t *)(CMTOC1_SHRD_MSG_RAM_C28XVIEW + (buffCPU1CMOffsetInBytes / 2));\n\n        buffCPU1CMOffsetInBytes = buffCPU1CMOffsetInBytes + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes));\n\n        if (ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_PU2.intEnable)\n        {\n            IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n        }\n        #endif\n\n        ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex].H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandle[IpcParams->IPCBetween][blkC1CMChIndex];\n    }\n    #endif\n\n    #ifdef CPU2_CM_IPC\n    if(IpcParams->IPCBetween == IPC_CPU2CM)\n    {\n        volatile uint16_t blkC2CMChIndex = MW_bSearch_IPC_Channels(ipcChannelCPU2CMList, MW_NUM_IPC_CHANNELS_CPU2CM, IpcParams->ChNum);\n\n        /* CPU2 to CM channel init */\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.chNum = IpcParams->ChNum;\n\n        #if defined(CPU2)\n        volatile uint32_t buffAddrCPU2ToCM = C2TOCM_SHRD_MSG_RAM_C28XVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #elif defined(CM)\n        volatile uint32_t buffAddrCPU2ToCM = C2TOCM_SHRD_MSG_RAM_CMVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #endif\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.head.ptr = (uint16_t *)buffAddrCPU2ToCM;\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.tail.ptr = (uint16_t *)(buffAddrCPU2ToCM + 1*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.full.ptr = (uint16_t *)(buffAddrCPU2ToCM + 2*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.mutex.ptr = (uint16_t *)(buffAddrCPU2ToCM + 3*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.overwrite.ptr = (uint16_t *)(buffAddrCPU2ToCM + 4*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.lastReadStatus.ptr = (uint16_t *)(buffAddrCPU2ToCM + 5*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.bufferLength.ptr = (uint16_t *)(buffAddrCPU2ToCM + 6*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCPU2ToCM + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCPU2ToCM + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        #if defined(CPU2)\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.head.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.tail.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.full.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.mutex.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.overwrite.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.lastReadStatus.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.bufferStartAdd.ptr)).ptr =  (uint16_t *)(C2TOCM_SHRD_MSG_RAM_C28XVIEW + buffCPU2CMOffsetInWords);\n        (*(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.bufferStartAdd.ptr + 1)).ptr = (uint16_t *)(C2TOCM_SHRD_MSG_RAM_CMVIEW + (buffCPU2CMOffsetInWords * 2));\n\n        buffCPU2CMOffsetInWords = buffCPU2CMOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes) / 2);\n\n        if (ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.intEnable)\n        {\n            switch (ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU1.chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC0 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC0 = 1;\n                    #endif\n                    break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC1 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC1 = 1;\n                    #endif\n                    break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC2 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC2 = 1;\n                    #endif\n                    break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC3 = 1 ;\n                    #else\n                    IpcRegs.IPCACK.bit.IPC3 = 1;\n                    #endif\n                    break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC4 = 1 ;\n                    #endif\n                    break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC5 = 1 ;\n                    #endif\n                    break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC6 = 1 ;\n                    #endif\n                    break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC7 = 1 ;\n                    #endif\n                    break;\n            }\n        }\n        #endif\n\n        /* CM to CPU2 channel init */\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.chNum = IpcParams->ChNum;\n\n        #if defined(CPU2)\n        volatile uint32_t buffAddrCMToCPU2 = CMTOC2_SHRD_MSG_RAM_C28XVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #elif defined(CM)\n        volatile uint32_t buffAddrCMToCPU2 = CMTOC2_SHRD_MSG_RAM_CMVIEW + (IpcParams->ChNum * (8*sizeof(uint16_t) + 2*sizeof(CLA_PTR)));\n        #endif\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.head.ptr = (uint16_t *)buffAddrCMToCPU2;\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.tail.ptr = (uint16_t *)(buffAddrCMToCPU2 + 1*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.full.ptr = (uint16_t *)(buffAddrCMToCPU2 + 2*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.mutex.ptr = (uint16_t *)(buffAddrCMToCPU2 + 3*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.overwrite.ptr = (uint16_t *)(buffAddrCMToCPU2 + 4*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.lastReadStatus.ptr = (uint16_t *)(buffAddrCMToCPU2 + 5*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.bufferLength.ptr = (uint16_t *)(buffAddrCMToCPU2 + 6*sizeof(uint16_t));\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCMToCPU2 + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCMToCPU2 + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        #if defined(CM)\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.head.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.tail.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.full.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.mutex.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.overwrite.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.lastReadStatus.ptr) = 0;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.bufferStartAdd.ptr)).ptr =  (uint16_t *)(CMTOC2_SHRD_MSG_RAM_CMVIEW + buffCPU2CMOffsetInBytes);\n        (*(ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.bufferStartAdd.ptr + 1)).ptr = (uint16_t *)(CMTOC2_SHRD_MSG_RAM_C28XVIEW + (buffCPU2CMOffsetInBytes / 2));\n\n        buffCPU2CMOffsetInBytes = buffCPU2CMOffsetInBytes + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes));\n\n        if (ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_PU2.intEnable)\n        {\n            IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n        }\n        #endif\n\n        ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex].H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandle[IpcParams->IPCBetween][blkC2CMChIndex];\n    }\n    #endif\n    #if defined(CPU1_CLA_IPC)\n    if(IpcParams->IPCBetween == IPC_CPU1CLA)\n    {\n        volatile uint32_t blkC1CLA1ChIndex = MW_bSearch_IPC_Channels(ipcChannelCPUCLAList, MW_NUM_IPC_CHANNELS_CPUCLA, IpcParams->ChNum);\n\n        volatile uint32_t buffAddrCPUToCLA = CPUTOCLA_SHRD_MSG_RAM + (IpcParams->ChNum * (8*sizeof(uint16_t) + sizeof(CLA_PTR)));\n\n        if (ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.head.ptr == (uint16_t *)buffAddrCPUToCLA)\n            return (MW_IPC_Handle) ipcHandleForCLA[blkC1CLA1ChIndex];\n\n        /* CPU1 to CLA channel init */\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.chNum = IpcParams->ChNum;\n\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.head.ptr = (uint16_t *)buffAddrCPUToCLA;\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.tail.ptr = (uint16_t *)(buffAddrCPUToCLA + 1*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.full.ptr = (uint16_t *)(buffAddrCPUToCLA + 2*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.mutex.ptr = (uint16_t *)(buffAddrCPUToCLA + 3*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.overwrite.ptr = (uint16_t *)(buffAddrCPUToCLA + 4*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.lastReadStatus.ptr = (uint16_t *)(buffAddrCPUToCLA + 5*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.bufferLength.ptr = (uint16_t *)(buffAddrCPUToCLA + 6*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCPUToCLA + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCPUToCLA + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.head.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.tail.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.full.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.mutex.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.overwrite.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.lastReadStatus.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1.bufferStartAdd.ptr)).ptr =  (uint16_t *)(CPUTOCLA_SHRD_MSG_RAM + buffCPUCLAOffsetInWords);\n\n        /* CLA to CPU1 channel init */\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.chNum = IpcParams->ChNum;\n\n        volatile uint32_t buffAddrCLAToCPU = CLATOCPU_SHRD_MSG_RAM + (IpcParams->ChNum * (8*sizeof(uint16_t) + sizeof(CLA_PTR)));\n\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.head.ptr = (uint16_t *)buffAddrCLAToCPU;\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.tail.ptr = (uint16_t *)(buffAddrCLAToCPU + 1*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.full.ptr = (uint16_t *)(buffAddrCLAToCPU + 2*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.mutex.ptr = (uint16_t *)(buffAddrCLAToCPU + 3*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.overwrite.ptr = (uint16_t *)(buffAddrCLAToCPU + 4*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.lastReadStatus.ptr = (uint16_t *)(buffAddrCLAToCPU + 5*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.bufferLength.ptr = (uint16_t *)(buffAddrCLAToCPU + 6*sizeof(uint16_t));\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCLAToCPU + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCLAToCPU + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.head.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.tail.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.full.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.mutex.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.overwrite.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.lastReadStatus.ptr) = 0;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2.bufferStartAdd.ptr)).ptr =  (uint16_t *)(CLATOCPU_SHRD_MSG_RAM + buffCPUCLAOffsetInWords);\n\n        buffCPUCLAOffsetInWords = buffCPUCLAOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes) / 2);\n\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandleForCLA[blkC1CLA1ChIndex];\n    }\n    #endif\n    #if defined(CPU2_CLA_IPC)\n    if(IpcParams->IPCBetween == IPC_CPU2CLA)\n    {\n        volatile uint32_t blkC2CLA1ChIndex = MW_bSearch_IPC_Channels(ipcChannelCPUCLAList, MW_NUM_IPC_CHANNELS_CPUCLA, IpcParams->ChNum);\n\n        volatile uint32_t buffAddrCPUToCLA = CPUTOCLA_SHRD_MSG_RAM + (IpcParams->ChNum * (8*sizeof(uint16_t) + sizeof(CLA_PTR)));\n\n        if (ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.head.ptr == (uint16_t *)buffAddrCPUToCLA)\n            return (MW_IPC_Handle) ipcHandleForCLA[blkC2CLA1ChIndex];\n\n        /* CPU2 to CLA channel init */\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.chNum = IpcParams->ChNum;\n\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.head.ptr = (uint16_t *)buffAddrCPUToCLA;\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.tail.ptr = (uint16_t *)(buffAddrCPUToCLA + 1*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.full.ptr = (uint16_t *)(buffAddrCPUToCLA + 2*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.mutex.ptr = (uint16_t *)(buffAddrCPUToCLA + 3*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.overwrite.ptr = (uint16_t *)(buffAddrCPUToCLA + 4*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.lastReadStatus.ptr = (uint16_t *)(buffAddrCPUToCLA + 5*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.bufferLength.ptr = (uint16_t *)(buffAddrCPUToCLA + 6*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCPUToCLA + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCPUToCLA + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.head.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.tail.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.full.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.mutex.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.overwrite.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.lastReadStatus.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU1.bufferStartAdd.ptr)).ptr =  (uint16_t *)(CPUTOCLA_SHRD_MSG_RAM + buffCPUCLAOffsetInWords);\n\n        /* CLA to CPU2 channel init */\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.chNum = IpcParams->ChNum;\n\n        volatile uint32_t buffAddrCLAToCPU = CLATOCPU_SHRD_MSG_RAM + (IpcParams->ChNum * (8*sizeof(uint16_t) + sizeof(CLA_PTR)));\n\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.head.ptr = (uint16_t *)buffAddrCLAToCPU;\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.tail.ptr = (uint16_t *)(buffAddrCLAToCPU + 1*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.full.ptr = (uint16_t *)(buffAddrCLAToCPU + 2*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.mutex.ptr = (uint16_t *)(buffAddrCLAToCPU + 3*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.overwrite.ptr = (uint16_t *)(buffAddrCLAToCPU + 4*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.lastReadStatus.ptr = (uint16_t *)(buffAddrCLAToCPU + 5*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.bufferLength.ptr = (uint16_t *)(buffAddrCLAToCPU + 6*sizeof(uint16_t));\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.dataTypeInBytes.ptr =  (uint16_t *)(buffAddrCLAToCPU + 7*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.bufferStartAdd.ptr =  (CLA_PTR *)(buffAddrCLAToCPU + 8*sizeof(uint16_t));  /* actual data resides after control flags in MSGRAM*/\n\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.head.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.tail.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.full.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.mutex.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.overwrite.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.lastReadStatus.ptr) = 0;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n        (*(ipcHandleForCLA[blkC2CLA1ChIndex].H_PU2.bufferStartAdd.ptr)).ptr =  (uint16_t *)(CLATOCPU_SHRD_MSG_RAM + buffCPUCLAOffsetInWords);\n\n        buffCPUCLAOffsetInWords = buffCPUCLAOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes) / 2);\n\n        ipcHandleForCLA[blkC2CLA1ChIndex].H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandleForCLA[blkC2CLA1ChIndex];\n    }\n    #endif\n}\n\nvoid MW_IPC_Write(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Const_Void_Ptr_T dataToSend, MW_IPC_Diag_T *diagDataOut)\n{\n    #if defined(CPU1_CPU2_IPC) || defined(CPU1_CM_IPC) || defined(CPU2_CM_IPC) || defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n    /* Processing Unit 1 */\n    if((ipcHandle->H_IPCBetween==IPC_CPU1CPU2 && CurrentPU==IPC_c28xCPU1) ||\n       (ipcHandle->H_IPCBetween==IPC_CPU1CM && CurrentPU==IPC_c28xCPU1) ||\n       (ipcHandle->H_IPCBetween==IPC_CPU2CM && CurrentPU==IPC_c28xCPU2) ||\n       (ipcHandle->H_IPCBetween==IPC_CPU1CLA) || (ipcHandle->H_IPCBetween==IPC_CPU2CLA))\n    {\n        uint16_t head =  *(ipcHandle->H_PU1).head.ptr;\n        uint16_t tail;\n        uint16_t dataInBytes;\n        uint16_t dataInWords; /* 16 bit int size is 1 word*/\n\n        dataInBytes = *(ipcHandle->H_PU1).bufferLength.ptr * (*(ipcHandle->H_PU1).dataTypeInBytes.ptr);\n        dataInWords = dataInBytes/2;\n\n        /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n        #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n        if (DataTypeId==MW_DOUBLE)\n        {\n            dataInBytes = dataInBytes/2;\n            dataInWords = dataInWords/2;\n        }\n        #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n        while(*(ipcHandle->H_PU2).mutex.ptr); /* sleep until mutex is locked by CPU2. CPU2 locks just to update flags*/\n        *(ipcHandle->H_PU1).mutex.ptr = 1; /*lock the mutex*/\n        if ((head | 0xF0) != (*(ipcHandle->H_PU2).tail.ptr & 0xFF)) /* tail of reading CPU is compared with head of writing CPU*/\n        {\n            *(ipcHandle->H_PU1).head.ptr = head | 0xF0; /* set writing in progress*/\n            /* If buffer is full and the reading CPU has not yet read the data - overwrite the contents at this buffer location*/\n            /* The full flag is updated at the end of this funciton. So at this point, we are looking at the full flag from the previous run.\n            * In case the reader has read data, the full flag is no longer indicating the correct status. To take care of such a condition, the lastReadStatus is used.\n            * The reader lastReadStatus is updated when ever the reader reads data and the writer full flag is set. */\n            if(*(ipcHandle->H_PU1).full.ptr && *(ipcHandle->H_PU1).lastReadStatus.ptr == *(ipcHandle->H_PU2).lastReadStatus.ptr)\n            {\n                /*Update tail value in writer CPU. This is the correct position to read from next. The reading CPU will update its tail to match with this.*/\n                tail =  ((head + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (head+1);\n                *(ipcHandle->H_PU1).tail.ptr = tail;\n                /* Increment overwrite.*/\n                /* Writer overwrite flag is updated by counting up. The counter value is used by the reader CPU to decide whether the flag is outdated or not.*/\n                *(ipcHandle->H_PU1).overwrite.ptr = *(ipcHandle->H_PU2).overwrite.ptr + 1;\n                /* for diagnostics - update number of overwrites */\n                diagDataOut->OverwriteDiag = diagDataOut->OverwriteDiag + 1;\n            }\n            else\n            {\n                *(ipcHandle->H_PU1).lastReadStatus.ptr = *(ipcHandle->H_PU2).lastReadStatus.ptr;\n                *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU2).tail.ptr;\n                *(ipcHandle->H_PU1).overwrite.ptr = 0;\n                tail = *(ipcHandle->H_PU2).tail.ptr;\n            }\n            *(ipcHandle->H_PU1).mutex.ptr = 0; /*unlock the mutex*/\n\n            #if defined(CM)\n            memcpy((*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInBytes);\n            #else\n            memcpy_fast((*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInWords);\n            #endif\n\n            *(ipcHandle->H_PU1).head.ptr = ( ((head+1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (head+1) ) ;\n            *(ipcHandle->H_PU1).full.ptr = (*(ipcHandle->H_PU1).head.ptr == tail);\n        }\n        else /* If reading is in progress advance head. Head jumps the tail. Always*/\n        {\n            *(ipcHandle->H_PU1).head.ptr = ( ((head+1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (head+1) ) | 0xF0;\n            *(ipcHandle->H_PU1).mutex.ptr = 0;\n            #if defined(CM)\n            memcpy((*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + ( ((head+1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (head+1) )*dataInWords, dataToSend, dataInBytes);\n            #else\n            memcpy_fast((*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + ( ((head+1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (head+1) )*dataInWords, dataToSend, dataInWords);\n            #endif\n            *(ipcHandle->H_PU1).head.ptr = ((head+2) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (head+2);\n            *(ipcHandle->H_PU1).full.ptr = (*(ipcHandle->H_PU1).head.ptr == tail);\n        }\n\n        /*Interrupts*/\n        /*No need to handle interrupts if communicating with CLA*/\n        if ((ipcHandle->H_PU1).intEnable &&\n            !((ipcHandle->H_IPCBetween==IPC_CPU1CLA) || (ipcHandle->H_IPCBetween==IPC_CPU2CLA)))\n        {\n            #if defined(CPU1)\n            switch ((ipcHandle->H_PU1).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC0 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC1 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC2 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC3 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CPU2)\n            switch ((ipcHandle->H_PU1).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC1 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC2 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC3 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CM)\n            uint32_t ipcflag = 0x00000001, ipcflag1;\n            ipcflag1 = ipcflag << (ipcHandle->H_PU1).chNum;\n            if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                IPC_CMTOCPU1_FlagReg->IPC_SET |= ipcflag1;\n            else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                IPC_CMTOCPU2_FlagReg->IPC_SET |= ipcflag1;\n            #endif\n        }\n\n        /* for diagnostics - calculate number of buffers used */\n        if(*(ipcHandle->H_PU1).full.ptr == 1)\n        {\n            diagDataOut->NumBuffUsedDiag = (ipcHandle->H_PU1).numOfBuffers;\n        }\n        else\n        {\n            if(head>=tail)\n                diagDataOut->NumBuffUsedDiag = (head - tail) + 1;\n            else\n                diagDataOut->NumBuffUsedDiag = ((head + (ipcHandle->H_PU1).numOfBuffers) - tail);\n        }\n    }\n    /* Processing Unit 2 */\n    else\n        /* if((ipcHandle->H_IPCBetween==IPC_CPU1CPU2 && CurrentPU==IPC_c28xCPU2) || (ipcHandle->H_IPCBetween==IPC_CPU1CM && CurrentPU==IPC_ArmCPU3) || ((ipcHandle->H_IPCBetween==IPC_CPU2CM && CurrentPU==IPC_ArmCPU3))) */\n    {\n        uint16_t head =  *(ipcHandle->H_PU2).head.ptr;\n        uint16_t tail;\n        uint16_t dataInBytes;\n        uint16_t dataInWords; /* 16 bit int size is 1 word*/\n\n        dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr);\n        dataInWords = dataInBytes/2;\n\n        /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n        #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n        if(DataTypeId==MW_DOUBLE)\n        {\n            dataInBytes = dataInBytes/2;\n            dataInWords = dataInWords/2;\n        }\n        #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n        while(*(ipcHandle->H_PU1).mutex.ptr);\n        *(ipcHandle->H_PU2).mutex.ptr = 1;\n        if ((head | 0xF0) != (*(ipcHandle->H_PU1).tail.ptr & 0xFF))\n        {\n            *(ipcHandle->H_PU2).head.ptr = head | 0xF0;\n            /* If buffer is full and the reading CPU has not yet read the data - overwrite the contents at this buffer location*/\n            /* The full flag is updated at the end of this funciton. So at this point, we are looking at the full flag from the previous run.\n            * In case the reader has read data, the full flag is no longer indicating the correct status. To take care of such a condition, the lastReadStatus is used.\n            * The reader lastReadStatus is updated when ever the reader reads data and the writer full flag is set. */\n            if(*(ipcHandle->H_PU2).full.ptr && *(ipcHandle->H_PU2).lastReadStatus.ptr == *(ipcHandle->H_PU1).lastReadStatus.ptr)\n            {\n                /*Update tail value in writer CPU. This is the correct position to read from next. The reading CPU will update its tail to match with this.*/\n                tail =  ((head + 1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1);\n                *(ipcHandle->H_PU2).tail.ptr = tail;\n                /* Increment overwrite.*/\n                /* Writer overwrite flag is updated by counting up. The counter value is used by the reader CPU to decide whether the flag is outdated or not.*/\n                *(ipcHandle->H_PU2).overwrite.ptr = *(ipcHandle->H_PU1).overwrite.ptr + 1;\n                /* for diagnostics - update number of overwrites */\n                diagDataOut->OverwriteDiag = diagDataOut->OverwriteDiag + 1;\n            }\n            else\n            {\n                *(ipcHandle->H_PU2).lastReadStatus.ptr = *(ipcHandle->H_PU1).lastReadStatus.ptr;\n                *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU1).tail.ptr;\n                *(ipcHandle->H_PU2).overwrite.ptr = 0;\n                tail = *(ipcHandle->H_PU1).tail.ptr;\n            }\n            *(ipcHandle->H_PU2).mutex.ptr = 0;\n            #if defined(CM)\n            memcpy((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInBytes);\n            #else\n            memcpy_fast((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInWords);\n            #endif\n            *(ipcHandle->H_PU2).head.ptr = ((head+1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1);\n            *(ipcHandle->H_PU2).full.ptr = (*(ipcHandle->H_PU2).head.ptr == tail);\n        }\n        else /* If reading is in progress advance head. Head jumps the tail. Always*/\n        {\n            *(ipcHandle->H_PU2).head.ptr = ( ((head+1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1) ) | 0xF0;\n            *(ipcHandle->H_PU2).mutex.ptr = 0;\n            #if defined(CM)\n            memcpy((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + ( ((head+1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1) )*dataInWords, dataToSend, dataInBytes);\n            #else\n            memcpy_fast((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + ( ((head+1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1) )*dataInWords, dataToSend, dataInWords);\n            #endif\n            *(ipcHandle->H_PU2).head.ptr = ((head+2) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+2);\n            *(ipcHandle->H_PU2).full.ptr = (*(ipcHandle->H_PU2).head.ptr == tail);\n        }\n\n        /*Interrupts*/\n        if ((ipcHandle->H_PU2).intEnable)\n        {\n            #if defined(CPU1)\n            switch ((ipcHandle->H_PU2).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC1 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC2 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC3 = 1 ;\n                         #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CPU2)\n            switch ((ipcHandle->H_PU2).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC1 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC2 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC3 = 1 ;\n                    #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCSET.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CM)\n            uint32_t ipcflag = 0x00000001, ipcflag1;\n            ipcflag1 = ipcflag << (ipcHandle->H_PU2).chNum;\n            if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                IPC_CMTOCPU1_FlagReg->IPC_SET |= ipcflag1;\n            else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                IPC_CMTOCPU2_FlagReg->IPC_SET |= ipcflag1;\n            #endif\n        }\n\n        /* for diagnostics - calculate number of buffers used */\n        if(*(ipcHandle->H_PU2).full.ptr == 1)\n        {\n            diagDataOut->NumBuffUsedDiag = (ipcHandle->H_PU2).numOfBuffers;\n        }\n        else\n        {\n            if(head>=tail)\n                diagDataOut->NumBuffUsedDiag = (head - tail) + 1;\n            else\n                diagDataOut->NumBuffUsedDiag = ((head + (ipcHandle->H_PU2).numOfBuffers) - tail);\n        }\n    }\n    #endif\n}\n\n\nvoid MW_IPC_Read(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Void_Ptr_T dataTobeRead, int8_T* status)\n{\n    /*  Do all statuts should be update in both CPU1 & PU2 & CLA\n    0 - No errors\n    1 - Data not available\n    2 - Data type mismatch => uint16_t dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr); & DataTypeId should match\n    4 - Data length mismatch => *(ipcHandle->H_PU1).bufferLength.ptr should be checked against *(ipcHandle->H_PU2).bufferLength.ptr;\n    6 - Data type and Data length mismatch\n    */\n    *status = 0;\n    #if defined(CPU1_CPU2_IPC) || defined(CPU1_CM_IPC) || defined(CPU2_CM_IPC) || defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n    /* Processing Unit 2 */\n    if(!(ipcHandle->H_IPCBetween==IPC_CPU1CLA1 || ipcHandle->H_IPCBetween==IPC_CPU2CLA1) &&\n       !((ipcHandle->H_IPCBetween==IPC_CPU1CPU2 && CurrentPU==IPC_c28xCPU1) ||\n         (ipcHandle->H_IPCBetween==IPC_CPU1CM && CurrentPU==IPC_c28xCPU1) ||\n         (ipcHandle->H_IPCBetween==IPC_CPU2CM && CurrentPU==IPC_c28xCPU2) ||\n         (ipcHandle->H_IPCBetween==IPC_CPU1CLA && CurrentPU==IPC_c28xCPU1)))\n    {\n        uint16_t tail;\n        uint16_t dataInBytes;\n        uint16_t dataInWords; /* 16 bit int size is 1 word*/\n\n        dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr);\n        dataInWords = dataInBytes/2;\n\n        /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n        #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n        if(DataTypeId==MW_DOUBLE)\n        {\n            dataInBytes = dataInBytes/2;\n            dataInWords = dataInWords/2;\n        }\n        #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n        if( ((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr)) && (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr))\n        {\n            *status = 6;\n        }\n        else if((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr))\n        {\n            *status = 2;\n        }\n        else if (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr)\n        {\n            *status = 4;\n        }\n        while(*(ipcHandle->H_PU1).mutex.ptr); /* wait while writing CPU is updating its flags */\n        *(ipcHandle->H_PU2).mutex.ptr = 1; /* lock mutex */\n        if ((*(ipcHandle->H_PU2).tail.ptr | 0xF0) != (*(ipcHandle->H_PU1).head.ptr & 0xFF))\n        {\n            if(*(ipcHandle->H_PU1).full.ptr)\n                *(ipcHandle->H_PU2).lastReadStatus.ptr = *(ipcHandle->H_PU2).lastReadStatus.ptr + 1;\n            /* Buffer is condidered to be empty if (writer head == reader tail) and (writer indicates that buffer is not full) => buffer is empty */\n            /* This is negation of that condition i.e. there is data in the buffer*/\n            if(!((*(ipcHandle->H_PU2).tail.ptr == *(ipcHandle->H_PU1).head.ptr) && (*(ipcHandle->H_PU1).full.ptr == 0)))\n            {\n                /* if writer CPU indicates an overwrite, update tail to read the earliest data in the buffer*/\n                if (*(ipcHandle->H_PU1).overwrite.ptr)\n                {\n                    /* writer overwrite flag may not have been updated. so reader also maintains an overwrite flag (*(ipcHandle->H_PU2).overwrite.ptr) that checks against this condition.\n                    * tail is not updated in case the writer overwrite flag is outdated\n                    * more on the logic:\n                    *      *(ipcHandle->H_PU2).overwrite.ptr is 0 when the reader CPU is reading for the first time after overwrite flag is set in the writer CPU\n                    *      The second time this condition is encountered -\n                    *          1) BEFORE the writer CPU runs again, *(ipcHandle->H_PU2).overwrite.ptr == *(ipcHandle->H_PU1).overwrite.ptr. Flag is outdated\n                    *          2) AFTER the writer CPU runs and sets its overwrite flag again, *(ipcHandle->H_PU2).overwrite.ptr != *(ipcHandle->H_PU1).overwrite.ptr. Flag NOT outdated\n                    */\n                    if((*(ipcHandle->H_PU2).overwrite.ptr == 0) || ((*(ipcHandle->H_PU2).overwrite.ptr != 0) && (*(ipcHandle->H_PU2).overwrite.ptr != *(ipcHandle->H_PU1).overwrite.ptr)))\n                        *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU1).tail.ptr;\n                    *(ipcHandle->H_PU2).overwrite.ptr =  *(ipcHandle->H_PU1).overwrite.ptr;\n                }\n                else\n                    *(ipcHandle->H_PU2).overwrite.ptr =  0;\n                tail = *(ipcHandle->H_PU2).tail.ptr;\n                *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr | 0xF0;\n                *(ipcHandle->H_PU2).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);/* every copy we should remove full flag. How to do that.*/\n                #endif\n                *(ipcHandle->H_PU2).tail.ptr = ((tail+1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1);\n            }\n            else/* no data or buff empty. Then output the last read index (read old data again).*/\n            {\n                *status = 1;\n                /* remove data from last read index (old data)*/\n                if (*(ipcHandle->H_PU2).tail.ptr) /* if tail is positive value*/\n                    *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr - 1;\n                else /* if tail is zero, return to end of buffer index to read*/\n                    *(ipcHandle->H_PU2).tail.ptr = (ipcHandle->H_PU1).numOfBuffers - 1;\n                tail =  *(ipcHandle->H_PU2).tail.ptr;\n                *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr | 0xF0;\n                *(ipcHandle->H_PU2).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n                #endif\n                *(ipcHandle->H_PU2).tail.ptr = ((tail+1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1) ;\n            }\n        }\n        else /* if writing in progress, jump to next location and check if buffer is empty*/\n        {\n            /*if buffer is full, then read old data*/\n            if (*(ipcHandle->H_PU1).full.ptr && (*(ipcHandle->H_PU1).head.ptr == *(ipcHandle->H_PU2).tail.ptr))\n            {\n                tail = *(ipcHandle->H_PU2).tail.ptr;\n                *(ipcHandle->H_PU2).tail.ptr = (((tail + 1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1)) | 0xF0;\n                *(ipcHandle->H_PU2).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + ((((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + ((((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + ((((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInWords);\n                #endif\n                *(ipcHandle->H_PU2).tail.ptr = ((tail + 2) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+2) ;\n            }\n            else/* no data or buff empty. Then output the last read index.*/\n            {\n                *status = 1;\n                /* remove data from last read index (old data)*/\n                if (*(ipcHandle->H_PU2).tail.ptr)\n                    *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr - 1;\n                else\n                    *(ipcHandle->H_PU2).tail.ptr = (ipcHandle->H_PU1).numOfBuffers - 1;\n                tail =  *(ipcHandle->H_PU2).tail.ptr;\n                *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr | 0xF0;\n                *(ipcHandle->H_PU2).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n                #endif\n                *(ipcHandle->H_PU2).tail.ptr = ((tail + 1) >= (ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1);\n            }\n        }\n\n        /*Interrupts*/\n        if ((ipcHandle->H_PU2).intEnable)\n        {\n            #if defined(CPU1)\n            switch ((ipcHandle->H_PU2).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC1 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC2 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC3 = 1 ;\n                         #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CPU2)\n            switch ((ipcHandle->H_PU2).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC1 = 1 ;\n                    #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC2 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC3 = 1 ;\n                    #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CM)\n            uint32_t ipcflag = 0x00000001, ipcflag1;\n            ipcflag1 = ipcflag << (ipcHandle->H_PU2).chNum;\n            if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n            else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n            #endif\n        }\n    }\n    /* Processing Unit 1 */\n    else\n    {\n        uint16_t tail;\n        uint16_t dataInBytes;\n        uint16_t dataInWords; /* 16 bit int size is 1 word*/\n\n        dataInBytes = *(ipcHandle->H_PU1).bufferLength.ptr * (*(ipcHandle->H_PU1).dataTypeInBytes.ptr);\n        dataInWords = dataInBytes/2;\n\n        /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n        #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n        if(DataTypeId==MW_DOUBLE)\n        {\n            dataInBytes = dataInBytes/2;\n            dataInWords = dataInWords/2;\n        }\n        #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n        if(((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr)) && (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr))\n        {\n            *status = 6;\n        }\n        else if((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr))\n        {\n            *status = 2;\n        }\n        else if (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr)\n        {\n            *status = 4;\n        }\n        while(*(ipcHandle->H_PU2).mutex.ptr);\n        *(ipcHandle->H_PU1).mutex.ptr = 1;\n        if ((*(ipcHandle->H_PU1).tail.ptr | 0xF0) != (*(ipcHandle->H_PU2).head.ptr & 0xFF))\n        {\n            if(*(ipcHandle->H_PU2).full.ptr)\n                *(ipcHandle->H_PU1).lastReadStatus.ptr = *(ipcHandle->H_PU1).lastReadStatus.ptr + 1;\n            /* Buffer is condidered to be empty if (writer head == reader tail) and (writer indicates that buffer is not full) => buffer is empty */\n            /* This is negation of that condition i.e. there is data in the buffer*/\n            if(!((*(ipcHandle->H_PU1).tail.ptr == *(ipcHandle->H_PU2).head.ptr) && (*(ipcHandle->H_PU2).full.ptr == 0)))\n            {\n                /* if writer CPU indicates an overwrite, update tail to read the earliest data in the buffer*/\n                if (*(ipcHandle->H_PU2).overwrite.ptr)\n                {\n                    /* writer overwrite flag may not have been updated. so reader also maintains an overwrite flag (*(ipcHandle->H_PU2).overwrite.ptr) that checks against this condition.\n                    * tail is not updated in case the writer overwrite flag is outdated\n                    * more on the logic:\n                    *      *(ipcHandle->H_PU2).overwrite.ptr is 0 when the reader CPU is reading for the first time after overwrite flag is set in the writer CPU\n                    *      The second time this condition is encountered -\n                    *          1) BEFORE the writer CPU runs again, *(ipcHandle->H_PU2).overwrite.ptr == *(ipcHandle->H_PU1).overwrite.ptr. Flag is outdated\n                    *          2) AFTER the writer CPU runs and sets its overwrite flag again, *(ipcHandle->H_PU2).overwrite.ptr != *(ipcHandle->H_PU1).overwrite.ptr. Flag NOT outdated\n                    */\n                    if((*(ipcHandle->H_PU1).overwrite.ptr == 0) || ((*(ipcHandle->H_PU1).overwrite.ptr != 0) && (*(ipcHandle->H_PU1).overwrite.ptr != *(ipcHandle->H_PU2).overwrite.ptr)))\n                        *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU2).tail.ptr;\n                    *(ipcHandle->H_PU1).overwrite.ptr =  *(ipcHandle->H_PU2).overwrite.ptr;\n                }\n                else\n                    *(ipcHandle->H_PU1).overwrite.ptr =  0;\n                tail = *(ipcHandle->H_PU1).tail.ptr;\n                *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU1).tail.ptr | 0xF0;\n                *(ipcHandle->H_PU1).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n                #endif\n                *(ipcHandle->H_PU1).tail.ptr = ((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1) ;\n            }\n            else\n            {\n                *status = 1;\n                if (*(ipcHandle->H_PU1).tail.ptr)\n                    *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU1).tail.ptr - 1;\n                else\n                    *(ipcHandle->H_PU1).tail.ptr = (ipcHandle->H_PU1).numOfBuffers - 1;\n                tail =  *(ipcHandle->H_PU1).tail.ptr;\n                *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU1).tail.ptr | 0xF0;\n                *(ipcHandle->H_PU1).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n                #endif\n                *(ipcHandle->H_PU1).tail.ptr = ((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1);\n            }\n        }\n        else\n        {\n            if (*(ipcHandle->H_PU2).full.ptr && (*(ipcHandle->H_PU2).head.ptr == *(ipcHandle->H_PU1).tail.ptr))\n            {\n                tail = *(ipcHandle->H_PU1).tail.ptr;\n                *(ipcHandle->H_PU1).tail.ptr = (((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1))  | 0xF0;\n                *(ipcHandle->H_PU1).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + ((((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInBytes);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + ((((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInWords);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + ((((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInWords);\n                #endif\n                *(ipcHandle->H_PU1).tail.ptr = ((tail + 2) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+2) ;\n            }\n            else\n            {\n                *status = 1;\n                if (*(ipcHandle->H_PU1).tail.ptr)\n                    *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU1).tail.ptr - 1;\n                else\n                    *(ipcHandle->H_PU1).tail.ptr = (ipcHandle->H_PU1).numOfBuffers - 1;\n                tail =  *(ipcHandle->H_PU1).tail.ptr;\n                *(ipcHandle->H_PU1).tail.ptr = *(ipcHandle->H_PU1).tail.ptr | 0xF0;\n                *(ipcHandle->H_PU1).mutex.ptr = 0;\n                #if defined(CM)\n                memcpy(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n                #else\n                if (ipcHandle->H_IPCBetween==IPC_CPU1CM || ipcHandle->H_IPCBetween==IPC_CPU2CM)\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n                else\n                    memcpy_fast(dataTobeRead, (*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInBytes);\n                #endif\n                *(ipcHandle->H_PU1).tail.ptr = ((tail + 1) >= (ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1);\n            }\n        }\n\n        /*Interrupts*/\n        if ((ipcHandle->H_PU1).intEnable &&\n            !(ipcHandle->H_IPCBetween==IPC_CPU1CLA1 || ipcHandle->H_IPCBetween==IPC_CPU2CLA1))\n        {\n            #if defined(CPU1)\n            switch ((ipcHandle->H_PU1).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC1 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC2 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC3 = 1 ;\n                         #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n\n\n            }\n            #elif defined(CPU2)\n            switch ((ipcHandle->H_PU1).chNum)\n            {\n                case 0:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC0 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC0 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1;\n                            #endif\n                            break;\n                case 1:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC1 = 1 ;\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC1 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1;\n                            #endif\n                            break;\n                case 2:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC2 = 1 ;\n\n                        #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC2 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1;\n                            #endif\n                            break;\n                case 3:\n                    #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC3 = 1 ;\n                    #if defined(MW_F2838X)\n                        else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC3 = 1 ;\n                            #endif\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1;\n                            #endif\n                            break;\n                case 4:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC4 = 1 ;\n                        #endif\n                        break;\n                case 5:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC5 = 1 ;\n                        #endif\n                        break;\n                case 6:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC6 = 1 ;\n                        #endif\n                        break;\n                case 7:\n                    #if defined(MW_F2838X)\n                    if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC7 = 1 ;\n                        #endif\n                        break;\n            }\n            #elif defined(CM)\n            uint32_t ipcflag = 0x00000001, ipcflag1;\n            ipcflag1 = ipcflag << (ipcHandle->H_PU1).chNum;\n            if(ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n            else if(ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n            #endif\n        }\n    }\n    #endif\n}\n\nvoid MW_IPC_Terminate(MW_IPC_Handle ipcHandle)\n{\n    /* add later*/\n}\n\n#endif /*__TMS320C28XX_CLA__*/\n\n#ifdef __TMS320C28XX_CLA__\nvoid MW_IPC_Write_CLA(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Const_Void_Ptr_T dataToSend)\n{\n    uint16_t head =  *(ipcHandle->H_PU2).head.ptr;\n    uint16_t tail;\n    uint16_t dataInBytes;\n    uint16_t dataInWords; /* 16 bit int size is 1 word*/\n\n    dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr);\n    dataInWords = dataInBytes/2;\n\n    /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n    #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n    if(DataTypeId==MW_DOUBLE)\n    {\n        dataInBytes = dataInBytes/2;\n        dataInWords = dataInWords/2;\n    }\n    #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n    while(*(ipcHandle->H_PU1).mutex.ptr);\n    *(ipcHandle->H_PU2).mutex.ptr = 1;\n    if ((head | 0xF0) != (*(ipcHandle->H_PU1).tail.ptr & 0xFF))\n    {\n        *(ipcHandle->H_PU2).head.ptr = head | 0xF0;\n        /* If buffer is full and the reading CPU has not yet read the data - overwrite the contents at this buffer location*/\n        /* The full flag is updated at the end of this funciton. So at this point, we are looking at the full flag from the previous run.\n        * In case the reader has read data, the full flag is no longer indicating the correct status. To take care of such a condition, the lastReadStatus is used.\n        * The reader lastReadStatus is updated when ever the reader reads data and the writer full flag is set. */\n        if(*(ipcHandle->H_PU2).full.ptr && *(ipcHandle->H_PU2).lastReadStatus.ptr == *(ipcHandle->H_PU1).lastReadStatus.ptr)\n        {\n            /*Update tail value in writer CPU. This is the correct position to read from next. The reading CPU will update its tail to match with this.*/\n            tail =  ((uint16_t)(head + 1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (uint16_t)(head+1);\n            *(ipcHandle->H_PU2).tail.ptr = tail;\n            /* Increment overwrite.*/\n            /* Writer overwrite flag is updated by counting up. The counter value is used by the reader CPU to decide whether the flag is outdated or not.*/\n            *(ipcHandle->H_PU2).overwrite.ptr = *(ipcHandle->H_PU1).overwrite.ptr + 1;\n        }\n        else\n        {\n            *(ipcHandle->H_PU2).lastReadStatus.ptr = *(ipcHandle->H_PU1).lastReadStatus.ptr;\n            *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU1).tail.ptr;\n            *(ipcHandle->H_PU2).overwrite.ptr = 0;\n            tail = *(ipcHandle->H_PU1).tail.ptr;\n        }\n        *(ipcHandle->H_PU2).mutex.ptr = 0;\n\n        memcpy_cla((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInWords);\n\n        *(ipcHandle->H_PU2).head.ptr = ((uint16_t)(head+1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1);\n        *(ipcHandle->H_PU2).full.ptr = (*(ipcHandle->H_PU2).head.ptr == tail);\n    }\n    else /* If reading is in progress advance head. Head jumps the tail. Always*/\n    {\n        *(ipcHandle->H_PU2).head.ptr = ( ((uint16_t)(head+1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1) ) | 0xF0;\n        *(ipcHandle->H_PU2).mutex.ptr = 0;\n        *((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + ( ((uint16_t)(head+1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1) )*dataInWords) = *(uint16_t*)dataToSend;\n        memcpy_cla((*((ipcHandle->H_PU2).bufferStartAdd.ptr)).ptr + ( ((uint16_t)(head+1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+1) )*dataInWords, dataToSend, dataInWords);\n        *(ipcHandle->H_PU2).head.ptr = ((uint16_t)(head+2) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (head+2);\n        *(ipcHandle->H_PU2).full.ptr = (*(ipcHandle->H_PU2).head.ptr == tail);\n    }\n}\n\nvoid MW_IPC_Read_CLA(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Void_Ptr_T dataTobeRead, int8_T* status)\n{\n    uint16_t tail;\n    *status = 0;\n    uint16_t dataInBytes;\n    uint16_t dataInWords; /* 16 bit int size is 1 word*/\n    \n    dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr);\n    dataInWords = dataInBytes/2;\n\n    /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n    #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n    if(DataTypeId==MW_DOUBLE)\n    {\n        dataInBytes = dataInBytes/2;\n        dataInWords = dataInWords/2;\n    }\n    #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n    if(((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr)) && (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr))\n    {\n        *status = 6;\n    }\n    else if((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr))\n    {\n        *status = 2;\n    }\n    else if (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr)\n    {\n        *status = 4;\n    }\n    while(*(ipcHandle->H_PU1).mutex.ptr); /* wait while writing CPU is updating its flags */\n    *(ipcHandle->H_PU2).mutex.ptr = 1; /* lock mutex */\n    if ((*(ipcHandle->H_PU2).tail.ptr | 0xF0) != (*(ipcHandle->H_PU1).head.ptr & 0xFF))\n    {\n        if(*(ipcHandle->H_PU1).full.ptr)\n            *(ipcHandle->H_PU2).lastReadStatus.ptr = *(ipcHandle->H_PU2).lastReadStatus.ptr + 1;\n        /* Buffer is condidered to be empty if (writer head == reader tail) and (writer indicates that buffer is not full) => buffer is empty */\n        /* This is negation of that condition i.e. there is data in the buffer*/\n        if(!((*(ipcHandle->H_PU2).tail.ptr == *(ipcHandle->H_PU1).head.ptr) && (*(ipcHandle->H_PU1).full.ptr == 0)))\n        {\n            /* if writer CPU indicates an overwrite, update tail to read the earliest data in the buffer*/\n            if (*(ipcHandle->H_PU1).overwrite.ptr)\n            {\n                /* writer overwrite flag may not have been updated. so reader also maintains an overwrite flag (*(ipcHandle->H_PU2).overwrite.ptr) that checks against this condition.\n                * tail is not updated in case the writer overwrite flag is outdated\n                * more on the logic:\n                *      *(ipcHandle->H_PU2).overwrite.ptr is 0 when the reader CPU is reading for the first time after overwrite flag is set in the writer CPU\n                *      The second time this condition is encountered -\n                *          1) BEFORE the writer CPU runs again, *(ipcHandle->H_PU2).overwrite.ptr == *(ipcHandle->H_PU1).overwrite.ptr. Flag is outdated\n                *          2) AFTER the writer CPU runs and sets its overwrite flag again, *(ipcHandle->H_PU2).overwrite.ptr != *(ipcHandle->H_PU1).overwrite.ptr. Flag NOT outdated\n                */\n                if((*(ipcHandle->H_PU2).overwrite.ptr == 0) || ((*(ipcHandle->H_PU2).overwrite.ptr != 0) && (*(ipcHandle->H_PU2).overwrite.ptr != *(ipcHandle->H_PU1).overwrite.ptr)))\n                    *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU1).tail.ptr;\n                *(ipcHandle->H_PU2).overwrite.ptr =  *(ipcHandle->H_PU1).overwrite.ptr;\n            }\n            else\n                *(ipcHandle->H_PU2).overwrite.ptr =  0;\n            tail = *(ipcHandle->H_PU2).tail.ptr;\n            *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr | 0xF0;\n            *(ipcHandle->H_PU2).mutex.ptr = 0;\n\n            memcpy_cla(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n\n            *(ipcHandle->H_PU2).tail.ptr = ((uint16_t)(tail+1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1);\n        }\n        else/* no data or buff empty. Then output the last read index (read old data again).*/\n        {\n            *status = 1;\n            /* remove data from last read index (old data)*/\n            if (*(ipcHandle->H_PU2).tail.ptr) /* if tail is positive value*/\n                *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr - 1;\n            else /* if tail is zero, return to end of buffer index to read*/\n                *(ipcHandle->H_PU2).tail.ptr = (ipcHandle->H_PU1).numOfBuffers - 1;\n            tail =  *(ipcHandle->H_PU2).tail.ptr;\n            *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr | 0xF0;\n            *(ipcHandle->H_PU2).mutex.ptr = 0;\n\n            memcpy_cla(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n\n            *(ipcHandle->H_PU2).tail.ptr = ((uint16_t)(tail+1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1) ;\n        }\n    }\n    else /* if writing in progress, jump to next location and check if buffer is empty*/\n    {\n        /*if buffer is full, then read old data*/\n        if (*(ipcHandle->H_PU1).full.ptr && (*(ipcHandle->H_PU1).head.ptr == *(ipcHandle->H_PU2).tail.ptr))\n        {\n            tail = *(ipcHandle->H_PU2).tail.ptr;\n            *(ipcHandle->H_PU2).tail.ptr = (((uint16_t)(tail + 1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1)) | 0xF0;\n            *(ipcHandle->H_PU2).mutex.ptr = 0;\n            memcpy_cla(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + ((((uint16_t)(tail + 1) >= (uint16_t)(ipcHandle->H_PU1).numOfBuffers) ? 0 : (tail+1)) * dataInWords), dataInWords);\n            *(ipcHandle->H_PU2).tail.ptr = ((uint16_t)(tail + 2) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+2) ;\n        }\n        else/* no data or buff empty. Then output the last read index.*/\n        {\n            *status = 1;\n            /* remove data from last read index (old data)*/\n            if (*(ipcHandle->H_PU2).tail.ptr)\n                *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr - 1;\n            else\n                *(ipcHandle->H_PU2).tail.ptr = (ipcHandle->H_PU1).numOfBuffers - 1;\n            tail =  *(ipcHandle->H_PU2).tail.ptr;\n            *(ipcHandle->H_PU2).tail.ptr = *(ipcHandle->H_PU2).tail.ptr | 0xF0;\n            *(ipcHandle->H_PU2).mutex.ptr = 0;\n            memcpy_cla(dataTobeRead, (*((ipcHandle->H_PU1).bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n            *(ipcHandle->H_PU2).tail.ptr = ((uint16_t)(tail + 1) >= (uint16_t)(ipcHandle->H_PU2).numOfBuffers) ? 0 : (tail+1);\n        }\n    }\n}\n\nvoid memcpy_cla(void *dest, const void *src, uint16_T n)\n{\n    char_T *csrc = (char_T *)src;\n    char_T *cdest = (char_T *)dest;\n    uint16_T i=0;\n    for (;i<n; ++i)\n        cdest[i] = csrc[i];\n}\n#endif /*__TMS320C28XX_CLA__*/\n\n#endif /*IPC_BLOCK_INCLUDED*/\n"},{"name":"sysctl.c","type":"source","group":"legacy","path":"C:\\Users\\mubar\\OneDrive\\Desktop\\Internship\\pwm_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_00_00_00\\driverlib\\f2837xd\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   sysctl.c\n//\n// TITLE:  C28x system control driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"cputimer.h\"\n#include \"sysctl.h\"\n\n//\n// Define to isolate inline assembly\n//\n#define SYSCTL_DELAY        __asm(\" .if __TI_EABI__\\n\"                         \\\n                                  \" .asg    SysCtl_delay    , _SysCtl_delay\\n\" \\\n                                  \" .endif\\n\"                                  \\\n                                  \" .def _SysCtl_delay\\n\"                      \\\n                                  \" .sect \\\".TI.ramfunc\\\"\\n\"                   \\\n                                  \" .global  _SysCtl_delay\\n\"                  \\\n                                  \"_SysCtl_delay:\\n\"                           \\\n                                  \" SUB    ACC,#1\\n\"                           \\\n                                  \" BF     _SysCtl_delay, GEQ\\n\"               \\\n                                  \" LRETR\\n\")\n#define SYSCTL_CLRC_DBGM    __asm(\" CLRC DBGM\")\n\n//\n// Define Timer1 and Timer2 seed values\n//\n#define TMR1SYSCLKCTR       0xF0000000U\n#define TMR2INPCLKCTR       0x800U\n\n#define XTAL_CPUTIMER_PERIOD 1023U\n\n\n//\n// Macro used for adding delay between 2 consecutive writes to CLKSRCCTL1\n// register.\n// Delay = 300 NOPs\n//\n#define SYSCTL_CLKSRCCTL1_DELAY  asm(\" RPT #250 || NOP \\n RPT #50 || NOP\")\n\n//*****************************************************************************\n//\n// SysCtl_delay()\n//\n//*****************************************************************************\nSYSCTL_DELAY;\n\n\nstatic void\nSysCtl_pollCpuTimer(void)\n{\n    //\n    // Delay for 1 ms while the XTAL powers up\n    //\n    // 2000 loops, 5 cycles per loop + 9 cycles overhead = 10009 cycles\n    //\n    SysCtl_delay(2000);\n\n    //\n    // Wait for cpu timer 2 to overflow\n    //\n    while(CPUTimer_getTimerOverflowStatus(CPUTIMER2_BASE) == false);\n    {\n        //\n        // If your application is stuck in this loop, please check if the\n        // input clock source is valid.\n        //\n    }\n\n    //\n    // Clear cpu timer 2 overflow flag\n    //\n    CPUTimer_clearOverflowFlag(CPUTIMER2_BASE);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getClock()\n//\n//*****************************************************************************\nuint32_t\nSysCtl_getClock(uint32_t clockInHz)\n{\n    uint32_t temp;\n    uint32_t oscSource;\n    uint32_t clockOut;\n\n    //\n    // Don't proceed if an MCD failure is detected.\n    //\n    if(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // OSCCLKSRC2 failure detected. Returning the INTOSC1 rate. You need\n        // to handle the MCD and clear the failure.\n        //\n        clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n    }\n    else\n    {\n        //\n        // If one of the internal oscillators is being used, start from the\n        // known default frequency.  Otherwise, use clockInHz parameter.\n        //\n        oscSource = HWREG(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n                    (uint32_t)SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M;\n\n        if((oscSource == (SYSCTL_OSCSRC_OSC2 >> SYSCTL_OSCSRC_S)) ||\n           (oscSource == (SYSCTL_OSCSRC_OSC1 >> SYSCTL_OSCSRC_S)))\n        {\n            clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n        }\n        else\n        {\n            clockOut = clockInHz;\n        }\n\n        //\n        // If the PLL is enabled calculate its effect on the clock\n        //\n        if((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &\n            (SYSCTL_SYSPLLCTL1_PLLEN | SYSCTL_SYSPLLCTL1_PLLCLKEN)) == 3U)\n        {\n            //\n            // Calculate portion from fractional multiplier\n            //\n            temp = (clockInHz * ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                  SYSCTL_SYSPLLMULT_FMULT_M) >>\n                                 SYSCTL_SYSPLLMULT_FMULT_S)) / 4U;\n\n            //\n            // Calculate integer multiplier and fixed divide by 2\n            //\n            clockOut = clockOut * ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                    SYSCTL_SYSPLLMULT_IMULT_M) >>\n                                   SYSCTL_SYSPLLMULT_IMULT_S);\n\n            //\n            // Add in fractional portion\n            //\n            clockOut += temp;\n        }\n\n        if((HWREG(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n            SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) != 0U)\n        {\n            clockOut /= (2U * (HWREG(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                               SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M));\n        }\n    }\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getAuxClock()\n//\n//*****************************************************************************\nuint32_t SysCtl_getAuxClock(uint32_t clockInHz)\n{\n    uint32_t temp;\n    uint32_t oscSource;\n    uint32_t clockOut;\n\n    oscSource = HWREG(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n                (uint32_t)SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M;\n\n    //\n    // If one of the internal oscillators is being used, start from the\n    // known default frequency.  Otherwise, use clockInHz parameter.\n    //\n    if(oscSource == (SYSCTL_AUXPLL_OSCSRC_OSC2 >> SYSCTL_OSCSRC_S))\n    {\n        //\n        // 10MHz Internal Clock\n        //\n        clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n    }\n    else\n    {\n        clockOut = clockInHz;\n    }\n\n    //\n    // If the PLL is enabled calculate its effect on the clock\n    //\n    if((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &\n        (SYSCTL_AUXPLLCTL1_PLLEN | SYSCTL_AUXPLLCTL1_PLLCLKEN)) == 3U)\n    {\n        //\n        // Calculate portion from fractional multiplier\n        //\n        temp = (clockInHz * ((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                              SYSCTL_AUXPLLMULT_FMULT_M) >>\n                             SYSCTL_AUXPLLMULT_FMULT_S)) / 4U;\n\n        //\n        // Calculate integer multiplier\n        //\n        clockOut = clockOut * ((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                                SYSCTL_AUXPLLMULT_IMULT_M) >>\n                               SYSCTL_AUXPLLMULT_IMULT_S);\n\n        //\n        // Add in fractional portion\n        //\n        clockOut += temp;\n    }\n\n    clockOut /= (1U << (HWREG(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) &\n                        SYSCTL_AUXCLKDIVSEL_AUXPLLDIV_M));\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_setClock()\n//\n//*****************************************************************************\nbool\nSysCtl_setClock(uint32_t config)\n{\n    uint16_t divSel;\n    uint16_t iMult = 0U, fMult = 0U, pllMult = 0U, div;\n    bool status, sysclkInvalidFreq = true;\n    uint16_t i, tempSCSR, tempWDCR, tempWDWCR, intStatus;\n    uint16_t t1TCR, t1TPR, t1TPRH, t2TCR, t2TPR, t2TPRH, t2CLKCTL;\n    uint32_t t1PRD, t2PRD, ctr1;\n    float32_t sysclkToInClkError, mult;\n\n    //\n    // Check the arguments.\n    //\n    ASSERT((config & SYSCTL_OSCSRC_M) != SYSCTL_OSCSRC_M); // 3 is not valid\n\n    //\n    // Don't proceed to the PLL initialization if an MCD failure is detected.\n    //\n    if(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // OSCCLKSRC2 failure detected. Returning false. You'll need to clear\n        // the MCD error.\n        //\n        status = false;\n    }\n    else\n    {\n        //\n        // Configure oscillator source\n        //\n        SysCtl_selectOscSource(config & SYSCTL_OSCSRC_M);\n\n        //\n        // Bypass PLL\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n            ~SYSCTL_SYSPLLCTL1_PLLCLKEN;\n        EDIS;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        SysCtl_delay(23U);\n\n        //\n        // Configure PLL if enabled\n        //\n        EALLOW;\n        if((config & SYSCTL_PLL_ENABLE) == SYSCTL_PLL_ENABLE)\n        {\n            if((HWREGH(DEVCFG_BASE + SYSCTL_O_SYSDBGCTL) &\n                SYSCTL_SYSDBGCTL_BIT_0) != 0U)\n            {\n                //\n                // The user can optionally insert handler code here. This will\n                // only be executed if a watchdog reset occurred after a failed\n                // system PLL initialization. See your device user's guide for\n                // more information.\n                //\n                // If the application has a watchdog reset handler, this bit\n                // should be checked to determine if the watchdog reset\n                // occurred because of the PLL.\n                //\n                // No action here will continue with retrying the PLL as\n                // normal.\n                //\n            }\n\n            //\n            // Set dividers to /1\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) = 0U;\n\n            //\n            // Get the PLL multiplier settings from config\n            //\n            iMult |= (uint16_t)(config & SYSCTL_IMULT_M);\n            fMult |= (uint16_t)((config & SYSCTL_FMULT_M) >> SYSCTL_FMULT_S);\n            pllMult |= (iMult << SYSCTL_SYSPLLMULT_IMULT_S) |\n                       (fMult << SYSCTL_SYSPLLMULT_FMULT_S);\n\n            //\n            // Lock the PLL five times. This helps ensure a successful start.\n            // Five is the minimum recommended number. The user can increase\n            // this number according to allotted system initialization time.\n            //\n            for(i = 0U; i < 5U; i++)\n            {\n                //\n                // Turn off PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                    ~SYSCTL_SYSPLLCTL1_PLLEN;\n\n                asm(\" RPT #60 || NOP\");\n\n                //\n                // Write multiplier, which automatically turns on the PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) = pllMult;\n\n                //\n                // Wait for the SYSPLL lock counter\n                //\n                while((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                       SYSCTL_SYSPLLSTS_LOCKS) == 0U)\n                {\n                    //\n                    // Consider to servicing the watchdog using\n                    // SysCtl_serviceWatchdog()\n                    //\n                }\n            }\n        }\n\n        //\n        // Configure Dividers. Set divider to produce slower output frequency\n        // to limit current increase.\n        //\n        divSel = (uint16_t)(config & SYSCTL_SYSDIV_M) >> SYSCTL_SYSDIV_S;\n\n        if(divSel != (126U / 2U))\n        {\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                ~(uint16_t)SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | (divSel + 1U);\n        }\n        else\n        {\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                 ~(uint16_t)SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | divSel;\n        }\n\n        //\n        //      *CAUTION*\n        // It is recommended to use the following watchdog code to monitor the\n        // PLLstartup sequence. If your application has already cleared the\n        // watchdog SCRS[WDOVERRIDE] bit this cannot be done. It is recommended\n        // not to clear this bit until after the PLL has been initiated.\n        //\n\n        //\n        // Backup User Watchdog\n        //\n        tempSCSR = HWREGH(WD_BASE + SYSCTL_O_SCSR);\n        tempWDCR = HWREGH(WD_BASE + SYSCTL_O_WDCR);\n        tempWDWCR = HWREGH(WD_BASE + SYSCTL_O_WDWCR);\n\n        //\n        // Disable windowed functionality, reset counter\n        //\n        HWREGH(WD_BASE + SYSCTL_O_WDWCR) = 0x0U;\n        SysCtl_serviceWatchdog();\n\n        //\n        // Disable global interrupts\n        //\n        intStatus = __disable_interrupts();\n\n        //\n        // Configure for watchdog reset and to run at max frequency\n        //\n        EALLOW;\n        HWREGH(WD_BASE + SYSCTL_O_SCSR) = 0x0U;\n        HWREGH(WD_BASE + SYSCTL_O_WDCR) = SYSCTL_WD_CHKBITS;\n\n        //\n        // This bit is reset only by power-on-reset (POR) and will not be\n        // cleared by a WD reset\n        //\n        HWREGH(DEVCFG_BASE + SYSCTL_O_SYSDBGCTL) |= SYSCTL_SYSDBGCTL_BIT_0;\n\n        //\n        // Enable PLLSYSCLK is fed from system PLL clock\n        //\n        HWREGH(CLKCFG_BASE +\n               SYSCTL_O_SYSPLLCTL1) |= SYSCTL_SYSPLLCTL1_PLLCLKEN;\n\n        EDIS;\n\n        //\n        // Delay to ensure system is clocking from PLL prior to clearing\n        // status bit\n        //\n        SysCtl_delay(3U);\n\n        //\n        // Slip Bit Monitor and SYSCLK Frequency Check using timers\n        // Re-lock routine for SLIP condition or if SYSCLK and CLKSRC timer\n        // counts are off by +/- 10%. At a minimum, SYSCLK check is performed.\n        // Re-lock attempt is carried out if SLIPS bit is set.\n        // This while loop is monitored by watchdog.\n        // In the event that the PLL does not successfully lock, the loop will\n        // be aborted by watchdog reset.\n        //\n        while(((config & SYSCTL_PLL_ENABLE) == SYSCTL_PLL_ENABLE) &&\n              (sysclkInvalidFreq == true))\n        {\n            EALLOW;\n\n            //\n            // Perform PLL re-lock only if SLIPS bit is set, otherwise monitor\n            // SYSCLK frequency with timers\n            //\n            if((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                SYSCTL_SYSPLLSTS_SLIPS) == 1U)\n            {\n                //\n                // Bypass PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                    ~SYSCTL_SYSPLLCTL1_PLLCLKEN;\n\n                //\n                // Delay of at least 120 OSCCLK cycles required post PLL bypass\n                //\n                SysCtl_delay(23U);\n\n                //\n                // Turn off PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                    ~SYSCTL_SYSPLLCTL1_PLLEN;\n\n                SysCtl_delay(3U);\n\n                //\n                // Write multiplier, which automatically turns on the PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) |= pllMult;\n\n                //\n                // Wait for the SYSPLL lock counter\n                //\n                while((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                        SYSCTL_SYSPLLSTS_LOCKS) == 0U)\n                {\n                    ;\n                }\n\n                //\n                // Enable PLLSYSCLK is fed from system PLL clock\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) |=\n                    SYSCTL_SYSPLLCTL1_PLLCLKEN;\n\n                //\n                // Delay to ensure system is clocking from PLL prior to\n                // clearing status bit\n                //\n                SysCtl_delay(3U);\n            }\n\n            //\n            // Backup timer1 and timer2 settings\n            //\n            t1TCR = HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR);\n            t1PRD = HWREG(CPUTIMER1_BASE + CPUTIMER_O_PRD);\n            t1TPR = HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPR);\n            t1TPRH = HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPRH);\n            t2CLKCTL = HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL);\n            t2TCR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR);\n            t2PRD = HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD);\n            t2TPR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR);\n            t2TPRH = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH);\n\n            //\n            // Set up timers 1 and 2\n            // Configure timer1 to count SYSCLK cycles\n            //\n\n            //\n            // Stop timer 1\n            // Seed timer1 counter\n            // Set sysclock divider\n            // Reload timer with value in PRD\n            // Clear interrupt flag\n            // Enable interrupt\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREG(CPUTIMER1_BASE + CPUTIMER_O_PRD) = (uint32_t)TMR1SYSCLKCTR;\n            HWREG(CPUTIMER1_BASE + CPUTIMER_O_TPR) = 0U;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIE;\n\n            //\n            // Configure timer2 to count Input clock cycles\n            //\n            switch (config & SYSCTL_OSCSRC_M)\n            {\n                case SYSCTL_OSCSRC_OSC1:\n                    //\n                    // Clk Src = INT_OSC1\n                    //\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) &=\n                        ~SYSCTL_TMR2CLKCTL_TMR2CLKSRCSEL_M;\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) |= 1U;\n                    break;\n\n                case SYSCTL_OSCSRC_OSC2:\n                    //\n                    // Clk Src = INT_OSC2\n                    //\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) &=\n                        ~SYSCTL_TMR2CLKCTL_TMR2CLKSRCSEL_M;\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) |= 2U;\n                    break;\n\n                case SYSCTL_OSCSRC_XTAL:\n                    //\n                    // Clk Src = XTAL\n                    //\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) &=\n                        ~SYSCTL_TMR2CLKCTL_TMR2CLKSRCSEL_M;\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) |= 3U;\n                    break;\n\n                default:\n                    //\n                    // Do nothing. Not a valid clock source value.\n                    //\n                    break;\n            }\n\n            //\n            // Clear interrupt flag\n            // Enable interrupt\n            // Stop timer 2\n            // Seed timer2 counter\n            // Set sysclock divider\n            // Reload timer with value in PRD\n            //\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIE;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = (uint32_t)TMR2INPCLKCTR;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_TPR) = 0U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n\n            //\n            // Stop/Start timer counters\n            //\n\n            //\n            // Stop timer 1\n            // Stop timer 2\n            // Reload timer1 with value in PRD\n            // Reload timer2 with value in PRD\n            // Clear timer2 interrupt flag\n            // Start timer2\n            // Start timer1\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TSS;\n\n            //\n            // Wait for Timers - Stop if either timer overflows\n            //\n            while(((HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &\n                   CPUTIMER_TCR_TIF) == 0U)  &&\n                  ((HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) &\n                   CPUTIMER_TCR_TIF) == 0U))\n            {\n                ;\n            }\n\n            //\n            // Stop timer 1 and 2\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n\n            //\n            // Calculate elapsed counts on timer1\n            //\n            ctr1 = (uint32_t)TMR1SYSCLKCTR - HWREG(CPUTIMER1_BASE +\n                                                   CPUTIMER_O_TIM);\n\n            //\n            // Restore timer settings\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) = t1TCR;\n            HWREG(CPUTIMER1_BASE + CPUTIMER_O_PRD) = t1PRD;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPR) = t1TPR;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPRH) = t1TPRH;\n            HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = t2CLKCTL;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) = t2TCR;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = t2PRD;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = t2TPR;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = t2TPRH;\n\n            //\n            // Calculate Clock Error:\n            // Error = (mult/div) - (timer1 count/timer2 count)\n            //\n            mult = (float32_t)iMult + ((float32_t)fMult / 4.0F);\n\n            if((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) & 0x3FU) == 0U)\n            {\n                div = 1U;\n            }\n            else\n            {\n                div = (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                       0x3FU) << 1;\n            }\n\n            sysclkToInClkError = (mult / (float32_t)div) -\n                                 ((float32_t)ctr1 / (float32_t)TMR2INPCLKCTR);\n\n            //\n            // sysclkInvalidFreq will be set to true if sysclkToInClkError is\n            // off by 10%\n            //\n            sysclkInvalidFreq = ((sysclkToInClkError > 0.10F) ||\n                                 (sysclkToInClkError < -0.10F));\n\n            EDIS;\n        }\n\n        //\n        // Clear bit\n        //\n        EALLOW;\n        HWREGH(DEVCFG_BASE + SYSCTL_O_SYSDBGCTL) &= ~SYSCTL_SYSDBGCTL_BIT_0;\n        EDIS;\n\n        //\n        // Restore user watchdog, first resetting counter\n        //\n        SysCtl_serviceWatchdog();\n\n        //\n        // Set the KEY bits and make sure not to set the WDOVERRIDE bit\n        //\n        EALLOW;\n        HWREGH(WD_BASE + SYSCTL_O_WDCR) = tempWDCR | SYSCTL_WD_CHKBITS;\n        HWREGH(WD_BASE + SYSCTL_O_WDWCR) = tempWDWCR;\n        HWREGH(WD_BASE + SYSCTL_O_SCSR) = tempSCSR & ~SYSCTL_SCSR_WDOVERRIDE;\n        EDIS;\n\n        //\n        // Restore state of ST1[INTM]. This was set by the\n        // __disable_interrupts() intrinsic previously.\n        //\n        if((intStatus & 0x1U) == 0U)\n        {\n            EINT;\n        }\n\n        //\n        // Restore state of ST1[DBGM]. This was set by the\n        // __disable_interrupts() intrinsic previously.\n        //\n        if((intStatus & 0x2U) == 0U)\n        {\n            SYSCTL_CLRC_DBGM;\n        }\n\n        //\n        // ~200 PLLSYSCLK delay to allow voltage regulator to stabilize prior\n        // to increasing entire system clock frequency.\n        //\n        SysCtl_delay(40U);\n\n        //\n        // Set the divider to user value\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n            (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n             ~SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | divSel;\n        EDIS;\n\n        status = true;\n    }\n\n    return(status);\n}\n//*****************************************************************************\n//\n// SysCtl_setAuxClock()\n//\n//*****************************************************************************\nvoid SysCtl_setAuxClock(uint32_t config)\n{\n    uint16_t pllMult = 0U;\n    uint16_t counter = 0U, started = 0U, attempts = 0U;\n    uint16_t mult;\n    uint16_t i, t2TCR, t2TPR, t2TPRH, t2CLKCTL;\n    uint32_t t2PRD;\n\n    //\n    // Check the arguments\n    //\n    ASSERT((config & SYSCTL_OSCSRC_M) != SYSCTL_OSCSRC_M); // 3 is not valid\n\n    //\n    // Bypass PLL\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &= ~SYSCTL_AUXPLLCTL1_PLLCLKEN;\n    EDIS;\n\n    //\n    // Delay of at least 120 OSCCLK cycles required post PLL bypass\n    //\n    SysCtl_delay(23U);\n\n    //\n    // Configure oscillator source\n    //\n    SysCtl_selectOscSourceAuxPLL(config & SYSCTL_OSCSRC_M);\n\n    //\n    // Get the PLL multiplier settings from config\n    //\n    pllMult |= (uint16_t)((config & SYSCTL_IMULT_M) <<\n                          SYSCTL_AUXPLLMULT_IMULT_S);\n    pllMult |= (uint16_t)(((config & SYSCTL_FMULT_M) >> SYSCTL_FMULT_S) <<\n                          SYSCTL_AUXPLLMULT_FMULT_S);\n\n    //\n    // Get the PLL multipliers currently programmed\n    //\n    mult  = (uint16_t)((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                        (uint32_t)SYSCTL_AUXPLLMULT_IMULT_M) >>\n                       (uint32_t)SYSCTL_AUXPLLMULT_IMULT_S);\n    mult |= (uint16_t)(HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                             SYSCTL_AUXPLLMULT_FMULT_M);\n\n    //\n    // Lock PLL only if the multipliers need update\n    //\n    if(mult !=  pllMult)\n    {\n\n        //\n        // Configure PLL if enabled\n        //\n        if((config & SYSCTL_AUXPLL_ENABLE) == SYSCTL_AUXPLL_ENABLE)\n        {\n            //\n            // Backup Timer 2 settings\n            //\n            t2CLKCTL = HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL);\n            t2TCR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR);\n            t2PRD = HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD);\n            t2TPR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR);\n            t2TPRH = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH);\n\n            //\n            // Configure Timer 2 for AUXPLL as source in known configuration\n            // - Clock source to AUXPLL\n            // - Clock divider to divide by 1\n            // - Small period to detect overflow\n            // - Interrupt disabled\n            //\n            EALLOW;\n            HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = 6U;\n\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = 10U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = 0U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = 0U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TIE;\n\n            //\n            // Set AUX Divide by 8 to ensure that AUXPLLCLK <= SYSCLK / 2\n            // while using Timer 2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) = 0x3U;\n            EDIS;\n\n            //\n            // Lock the PLL up to five times.\n            //CPU Timer 2 will monitor a successful\n            // lock and break out of the loop earlier if detected.\n            //\n            while((counter < 5U) && (started == 0U))\n            {\n                EALLOW;\n\n                //\n                // Turn off AUXPLL and delay for it to power down.\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &=\n                    ~SYSCTL_AUXPLLCTL1_PLLEN;\n                SysCtl_delay(3U);\n\n                //\n                // Set integer and fractional multiplier, which automatically\n                // turns on the PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) |= pllMult;\n\n                //\n                // Enable AUXPLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |=\n                    SYSCTL_AUXPLLCTL1_PLLEN;\n                EDIS;\n\n                //\n                // Wait for the AUXPLL lock counter\n                //\n\n                while((HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLSTS) &\n                       SYSCTL_AUXPLLSTS_LOCKS) != 1U)\n                {\n                    //\n                    // Consider to servicing the watchdog using\n                    // SysCtl_serviceWatchdog()\n                    //\n                }\n\n\n                //\n                // Enable AUXPLLCLK to be fed from AUXPLL\n                //\n                EALLOW;\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |=\n                    SYSCTL_AUXPLLCTL1_PLLCLKEN;\n                SysCtl_delay(3U);\n\n                //\n                // CPU Timer 2 will now be setup to be clocked from AUXPLLCLK.\n                // This is used to test that the PLL has successfully started.\n                //\n                // Reload and start the timer\n                //\n                HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n                HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TSS;\n\n                //\n                // Check to see timer is counting properly\n                //\n                for(i = 0U; i < 1000U; i++)\n                {\n                    //\n                    // Check overflow flag\n                    //\n                    if((HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &\n                        CPUTIMER_TCR_TIF) != 0U)\n                    {\n                        //\n                        // Clear overflow flag\n                        //\n                        HWREGH(CPUTIMER2_BASE +\n                               CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n\n                        //\n                        // Set flag to indicate PLL started and break out of\n                        // for-loop\n                        //\n                        started = 1U;\n                        break;\n                    }\n                }\n\n                //\n                // Stop timer\n                //\n                HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n                counter++;\n                EDIS;\n            }\n\n            if(started == 0U)\n            {\n                //\n                // AUX PLL may not have started. Reset multiplier to 0 (bypass\n                // PLL).\n                //\n                EALLOW;\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) = 0U;\n                EDIS;\n\n                //\n                // The user should put some handler code here based on how\n                // this condition should be handled in their application.\n                //\n                ESTOP0;\n            }\n\n            //\n            // Restore Timer 2 configuration\n            //\n            EALLOW;\n            HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = t2CLKCTL;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) = t2TCR;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = t2PRD;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = t2TPR;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = t2TPRH;\n\n            //\n            // Reload period value\n            //\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            EDIS;\n        }\n    }\n    else\n    {\n        //\n        // Enable AUXPLLCLK to be fed from AUXPLL\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |= SYSCTL_AUXPLLCTL1_PLLCLKEN;\n        SysCtl_delay(3U);\n        EDIS;\n    }\n\n    //\n    // Slip Bit Monitor\n    // Re-lock routine for SLIP condition\n    //\n    while(((HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLSTS) &\n            SYSCTL_AUXPLLSTS_SLIPS) != 0U) && (attempts < 10U) &&\n          ((config & SYSCTL_AUXPLL_ENABLE) == SYSCTL_AUXPLL_ENABLE))\n    {\n        EALLOW;\n\n        //\n        // Bypass AUXPLL\n        //\n        HWREGH(CLKCFG_BASE +\n               SYSCTL_O_AUXPLLCTL1) &= ~SYSCTL_AUXPLLCTL1_PLLCLKEN;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        SysCtl_delay(23U);\n\n        //\n        // Turn off AUXPLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &= ~SYSCTL_AUXPLLCTL1_PLLEN;\n        SysCtl_delay(3U);\n\n        //\n        // Set integer and fractional multiplier, which automatically turns\n        // on the PLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) |= pllMult;\n\n        //\n        // Enable AUXPLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |= SYSCTL_AUXPLLCTL1_PLLEN;\n\n        //\n        // Wait for the AUXPLL lock counter\n        //\n        while((HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLSTS) &\n               SYSCTL_AUXPLLSTS_LOCKS) != 1U)\n        {\n            //\n            // Consider to servicing the watchdog using\n            // SysCtl_serviceWatchdog()\n            //\n        }\n\n        //\n        // Enable AUXPLLCLK to be fed from AUXPLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |= SYSCTL_AUXPLLCTL1_PLLCLKEN;\n\n        SysCtl_delay(3U);\n\n        attempts++;\n\n        EDIS;\n    }\n\n    //\n    // Set divider to desired value\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) =\n        (uint16_t)(config & SYSCTL_SYSDIV_M) >> SYSCTL_SYSDIV_S;\n    EDIS;\n\n}\n\n\n//*****************************************************************************\n//\n// SysCtl_selectXTAL()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectXTAL(void)\n{\n    uint16_t t2TCR, t2TPR, t2TPRH, t2CLKCTL;\n    uint32_t t2PRD;\n\n    //\n    // Backup CPU timer2 settings\n    //\n    t2CLKCTL = HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL);\n    t2TCR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR);\n    t2PRD = HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD);\n    t2TPR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR);\n    t2TPRH = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH);\n\n    //\n    // Backup AUX clock settings\n    //\n    uint16_t clksrcctl2 = HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2);\n    uint16_t auxpllctl1 = HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1);\n    uint16_t auxclkdivsel = HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL);\n\n    //\n    // Set AUX clock source to XTAL, bypass mode.\n    // AUXCLK is used as the CPUTimer Clock source. SYSCLK frequency must be\n    // atleast twice the frequency of AUXCLK. SYSCLK = INTOSC2(10MHz)\n    // Set the AUX divider to 8. The above condition will be met for XTAL\n    // frequencies up to 40MHz\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) =\n            (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n             ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M)) |\n            (1U << SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_S);\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) = 0x0U;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) = SYSCTL_AUXPLLCLK_DIV_8;\n\n\n    //\n    // Disable cpu timer 2 interrupt\n    //\n    CPUTimer_disableInterrupt(CPUTIMER2_BASE);\n\n    //\n    // Stop cpu timer 2 if running\n    //\n    CPUTimer_stopTimer(CPUTIMER2_BASE);\n\n    //\n    // Initialize cpu timer 2 period\n    //\n    CPUTimer_setPeriod(CPUTIMER2_BASE, XTAL_CPUTIMER_PERIOD);\n\n    //\n    // Set cpu timer 2 clock source to XTAL\n    //\n    CPUTimer_selectClockSource(CPUTIMER2_BASE, CPUTIMER_CLOCK_SOURCE_AUX,\n                               CPUTIMER_CLOCK_PRESCALER_1);\n\n    //\n    // Clear cpu timer 2 overflow flag\n    //\n    CPUTimer_clearOverflowFlag(CPUTIMER2_BASE);\n\n    //\n    // Start cpu timer 2\n    //\n    CPUTimer_startTimer(CPUTIMER2_BASE);\n\n    EALLOW;\n    //\n    // Turn on XTAL\n    //\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &= ~SYSCTL_CLKSRCCTL1_XTALOFF;\n    EDIS;\n\n    //\n    // Wait for the X1 clock to overflow cpu timer 2\n    //\n    SysCtl_pollCpuTimer();\n\n    //\n    // Select XTAL as the oscillator source\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n    ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n      (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n     (SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n    EDIS;\n\n    //\n    // If a missing clock failure was detected, try waiting for the cpu timer 2\n    // to overflow again.\n    //\n    while(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // Clear the MCD failure\n        //\n        SysCtl_resetMCD();\n\n        //\n        // Wait for the X1 clock to overflow cpu timer 2\n        //\n        SysCtl_pollCpuTimer();\n\n        //\n        // Select XTAL as the oscillator source\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n        ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n          (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n         (SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n        EDIS;\n    }\n\n    //\n    // Stop cpu timer 2\n    //\n    CPUTimer_stopTimer(CPUTIMER2_BASE);\n\n    //\n    // Restore Timer 2 configuration\n    //\n    EALLOW;\n    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = t2CLKCTL;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) = t2TCR;\n    HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = t2PRD;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = t2TPR;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = t2TPRH;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n\n    //\n    // Restore AUX clock settings\n    //\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) = clksrcctl2;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) = auxpllctl1;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) = auxclkdivsel;\n    EDIS;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectOscSource()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectOscSource(uint32_t oscSource)\n{\n    ASSERT((oscSource == SYSCTL_OSCSRC_OSC1) ||\n           (oscSource == SYSCTL_OSCSRC_OSC2) ||\n           (oscSource == SYSCTL_OSCSRC_XTAL));\n\n    //\n    // Select the specified source.\n    //\n    EALLOW;\n    switch(oscSource)\n    {\n        case SYSCTL_OSCSRC_OSC2:\n            //\n            // Turn on INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                ~SYSCTL_CLKSRCCTL1_INTOSC2OFF;\n\n            SYSCTL_CLKSRCCTL1_DELAY;\n\n            //\n            // Clk Src = INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                ~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M;\n\n            SYSCTL_CLKSRCCTL1_DELAY;\n\n            //\n            // Turn off XTALOSC\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) |=\n                SYSCTL_CLKSRCCTL1_XTALOFF;\n\n            break;\n\n        case SYSCTL_OSCSRC_XTAL:\n            //\n            // Select XTAL in crystal mode and wait for it to power up\n            //\n            SysCtl_selectXTAL();\n            break;\n\n        case SYSCTL_OSCSRC_OSC1:\n            //\n            // Clk Src = INTOSC1\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n                   (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n                    ~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M) |\n                   (SYSCTL_OSCSRC_OSC1 >> SYSCTL_OSCSRC_S);\n\n            SYSCTL_CLKSRCCTL1_DELAY;\n\n            //\n            //Turn off XTALOSC\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) |=\n                SYSCTL_CLKSRCCTL1_XTALOFF;\n\n            break;\n\n        default:\n            //\n            // Do nothing. Not a valid oscSource value.\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectOscSourceAuxPLL()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectOscSourceAuxPLL(uint32_t oscSource)\n{\n    bool status = false;\n\n    EALLOW;\n\n    switch(oscSource)\n    {\n        case SYSCTL_AUXPLL_OSCSRC_OSC2:\n            //\n            // Turn on INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                    ~(SYSCTL_CLKSRCCTL1_INTOSC2OFF);\n\n            //\n            // Clk Src = INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &=\n                    ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M);\n            break;\n\n        case SYSCTL_AUXPLL_OSCSRC_XTAL:\n            //\n            // Turn on XTALOSC\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                   ~(SYSCTL_CLKSRCCTL1_XTALOFF);\n\n            //\n            // Clk Src = XTAL\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) =\n                    (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n                     ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M)) |\n                    (1U << SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_S);\n            break;\n\n        case SYSCTL_AUXPLL_OSCSRC_AUXCLKIN:\n            //\n            // Clk Src = AUXCLKIN\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) =\n                    (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n                     ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M)) |\n                    (2U << SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_S);\n            break;\n\n        default:\n            //\n            // Do nothing. Not a valid clock source value.\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_getLowSpeedClock()\n//\n//*****************************************************************************\nuint32_t\nSysCtl_getLowSpeedClock(uint32_t clockInHz)\n{\n    uint32_t clockOut;\n\n    //\n    // Get the main system clock\n    //\n    clockOut = SysCtl_getClock(clockInHz);\n\n    //\n    // Apply the divider to the main clock\n    //\n    if((HWREG(CLKCFG_BASE + SYSCTL_O_LOSPCP) &\n        SYSCTL_LOSPCP_LSPCLKDIV_M) != 0U)\n    {\n        clockOut /= (2U * (HWREG(CLKCFG_BASE + SYSCTL_O_LOSPCP) &\n                            SYSCTL_LOSPCP_LSPCLKDIV_M));\n    }\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getDeviceParametric()\n//\n//*****************************************************************************\nuint16_t\nSysCtl_getDeviceParametric(SysCtl_DeviceParametric parametric)\n{\n    uint32_t value;\n\n    //\n    // Get requested parametric value\n    //\n    switch(parametric)\n    {\n        case SYSCTL_DEVICE_QUAL:\n            //\n            // Qualification Status\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_QUAL_M) >> SYSCTL_PARTIDL_QUAL_S);\n            break;\n\n        case SYSCTL_DEVICE_PINCOUNT:\n            //\n            // Pin Count\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_PIN_COUNT_M) >>\n                     SYSCTL_PARTIDL_PIN_COUNT_S);\n            break;\n\n        case SYSCTL_DEVICE_INSTASPIN:\n            //\n            // InstaSPIN Feature Set\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_INSTASPIN_M) >>\n                     SYSCTL_PARTIDL_INSTASPIN_S);\n            break;\n\n        case SYSCTL_DEVICE_FLASH:\n            //\n            // Flash Size (KB)\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_FLASH_SIZE_M) >>\n                     SYSCTL_PARTIDL_FLASH_SIZE_S);\n            break;\n\n        case SYSCTL_DEVICE_PARTID:\n            //\n            // PARTID Format Revision\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_PARTID_FORMAT_REVISION_M) >>\n                     SYSCTL_PARTIDL_PARTID_FORMAT_REVISION_S);\n            break;\n\n        case SYSCTL_DEVICE_FAMILY:\n            //\n            // Device Family\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_FAMILY_M) >> SYSCTL_PARTIDH_FAMILY_S);\n            break;\n\n        case SYSCTL_DEVICE_PARTNO:\n            //\n            // Part Number\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_PARTNO_M) >> SYSCTL_PARTIDH_PARTNO_S);\n            break;\n\n        case SYSCTL_DEVICE_CLASSID:\n            //\n            // Class ID\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_DEVICE_CLASS_ID_M) >>\n                     SYSCTL_PARTIDH_DEVICE_CLASS_ID_S);\n            break;\n\n        default:\n            //\n            // Not a valid value for PARTID register\n            //\n            value = 0U;\n            break;\n    }\n\n    return((uint16_t)value);\n}\n\n"}],"trace":"{\"model\":\"pwm\",\"sources\":[\"pwm.c\",\"pwm.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\",\"LocalParameters\"],\"sidPrefixes\":[\"pwm\"],\"fileRecords\":{\"0\":{\"records\":[{\"tk\":[86,3,86,4],\"els\":[\"0:12\"]},{\"tk\":[89,5,89,13],\"els\":[\"0:12\"]},{\"tk\":[89,13,89,14],\"els\":[\"0:12\"]},{\"tk\":[89,14,89,24],\"els\":[\"0:12\"]},{\"tk\":[89,24,89,25],\"els\":[\"0:12\"]},{\"tk\":[89,25,89,28],\"els\":[\"0:12\"]},{\"tk\":[89,28,89,29],\"els\":[\"0:12\"]},{\"tk\":[89,29,89,33],\"els\":[\"0:12\"]},{\"tk\":[89,34,89,35],\"els\":[\"0:12\"]},{\"tk\":[89,36,89,38],\"els\":[\"0:12\"]},{\"tk\":[89,38,89,39],\"els\":[\"0:12\"]},{\"tk\":[92,1,92,2],\"els\":[\"0:12\"]},{\"tk\":[92,2,92,8],\"els\":[\"0:12\"]},{\"tk\":[92,9,92,28],\"els\":[\"0:12\"]},{\"tk\":[94,5,94,8],\"els\":[\"0:12\"]},{\"tk\":[94,8,94,9],\"els\":[\"0:12\"]},{\"tk\":[94,9,94,25],\"els\":[\"0:12\"]},{\"tk\":[94,25,94,26],\"els\":[\"0:12\"]},{\"tk\":[94,26,94,27],\"els\":[\"0:12\"]},{\"tk\":[96,1,96,2],\"els\":[\"0:12\"]},{\"tk\":[96,2,96,7],\"els\":[\"0:12\"]},{\"tk\":[98,1,98,2],\"els\":[\"0:12\"]},{\"tk\":[98,2,98,7],\"els\":[\"0:12\"]},{\"tk\":[98,8,98,27],\"els\":[\"0:12\"]},{\"tk\":[100,5,100,13],\"els\":[\"0:12\"]},{\"tk\":[100,14,100,24],\"els\":[\"0:12\"]},{\"tk\":[100,24,100,25],\"els\":[\"0:12\"]},{\"tk\":[101,5,101,8],\"els\":[\"0:12\"]},{\"tk\":[101,9,101,10],\"els\":[\"0:12\"]},{\"tk\":[101,10,101,20],\"els\":[\"0:12\"]},{\"tk\":[101,20,101,21],\"els\":[\"0:12\"]},{\"tk\":[101,22,101,24],\"els\":[\"0:12\"]},{\"tk\":[101,24,101,25],\"els\":[\"0:12\"]},{\"tk\":[101,26,101,36],\"els\":[\"0:12\"]},{\"tk\":[101,37,101,38],\"els\":[\"0:12\"]},{\"tk\":[101,39,101,40],\"els\":[\"0:12\"]},{\"tk\":[101,40,101,41],\"els\":[\"0:12\"]},{\"tk\":[101,42,101,52],\"els\":[\"0:12\"]},{\"tk\":[101,52,101,54],\"els\":[\"0:12\"]},{\"tk\":[101,54,101,55],\"els\":[\"0:12\"]},{\"tk\":[102,7,102,13],\"els\":[\"0:12\"]},{\"tk\":[102,13,102,14],\"els\":[\"0:12\"]},{\"tk\":[102,14,102,15],\"els\":[\"0:12\"]},{\"tk\":[102,15,102,16],\"els\":[\"0:12\"]},{\"tk\":[104,1,104,2],\"els\":[\"0:12\"]},{\"tk\":[104,2,104,7],\"els\":[\"0:12\"]},{\"tk\":[106,5,106,10],\"els\":[\"0:12\"]},{\"tk\":[106,10,106,11],\"els\":[\"0:12\"]},{\"tk\":[106,11,106,15],\"els\":[\"0:12\"]},{\"tk\":[106,16,106,17],\"els\":[\"0:12\"]},{\"tk\":[106,18,106,19],\"els\":[\"0:12\"]},{\"tk\":[106,19,106,33],\"els\":[\"0:12\"]},{\"tk\":[106,33,106,34],\"els\":[\"0:12\"]},{\"tk\":[106,34,106,44],\"els\":[\"0:12\"]},{\"tk\":[106,44,106,45],\"els\":[\"0:12\"]},{\"tk\":[106,45,106,46],\"els\":[\"0:12\"]},{\"tk\":[107,3,107,4],\"els\":[\"0:12\"]},{\"tk\":[110,3,110,12],\"els\":[\"0:13#out:1\"]},{\"tk\":[110,13,110,14],\"els\":[\"0:13\"]},{\"tk\":[110,15,110,20],\"els\":[\"0:13\"]},{\"tk\":[110,21,110,31],\"els\":[\"0:13\"]},{\"tk\":[110,32,110,33],\"els\":[\"0:13\"]},{\"tk\":[110,34,110,39],\"els\":[\"0:13\"]},{\"tk\":[110,40,110,44],\"els\":[\"0:13\"]},{\"tk\":[115,3,115,10],\"els\":[\"0:14#out:1\"]},{\"tk\":[115,11,115,12],\"els\":[\"0:14\"]},{\"tk\":[115,13,115,18],\"els\":[\"0:16\"]},{\"tk\":[115,19,115,34],\"els\":[\"0:16\"]},{\"tk\":[115,35,115,36],\"els\":[\"0:14\"]},{\"tk\":[115,37,115,46],\"els\":[\"0:13#out:1\"]},{\"tk\":[120,3,120,4],\"els\":[\"0:3\"]},{\"tk\":[121,5,121,14],\"els\":[\"0:3\"]},{\"tk\":[121,14,121,15],\"els\":[\"0:3\"]},{\"tk\":[121,15,121,19],\"els\":[\"0:3\"]},{\"tk\":[121,19,121,20],\"els\":[\"0:3\"]},{\"tk\":[121,20,121,23],\"els\":[\"0:3\"]},{\"tk\":[121,23,121,24],\"els\":[\"0:3\"]},{\"tk\":[121,24,121,28],\"els\":[\"0:3\"]},{\"tk\":[121,29,121,30],\"els\":[\"0:3\"]},{\"tk\":[121,31,121,32],\"els\":[\"0:3\"]},{\"tk\":[121,32,121,40],\"els\":[\"0:3\"]},{\"tk\":[121,40,121,41],\"els\":[\"0:3\"]},{\"tk\":[121,41,121,42],\"els\":[\"0:3\"]},{\"tk\":[121,42,121,43],\"els\":[\"0:3\"]},{\"tk\":[121,43,121,51],\"els\":[\"0:3\"]},{\"tk\":[121,51,121,52],\"els\":[\"0:3\"]},{\"tk\":[121,52,121,61],\"els\":[\"0:3\"]},{\"tk\":[121,61,121,62],\"els\":[\"0:3\"]},{\"tk\":[121,62,121,67],\"els\":[\"0:3\"]},{\"tk\":[121,68,121,69],\"els\":[\"0:3\"]},{\"tk\":[121,70,121,79],\"els\":[\"0:3\",\"0:13#out:1\"]},{\"tk\":[121,80,121,81],\"els\":[\"0:3\"]},{\"tk\":[122,7,122,11],\"els\":[\"0:3\"]},{\"tk\":[122,11,122,12],\"els\":[\"0:3\"]},{\"tk\":[122,12,122,13],\"els\":[\"0:3\"]},{\"tk\":[123,3,123,4],\"els\":[\"0:3\"]},{\"tk\":[126,3,126,4],\"els\":[\"0:3\"]},{\"tk\":[127,5,127,14],\"els\":[\"0:3\"]},{\"tk\":[127,14,127,15],\"els\":[\"0:3\"]},{\"tk\":[127,15,127,19],\"els\":[\"0:3\"]},{\"tk\":[127,19,127,20],\"els\":[\"0:3\"]},{\"tk\":[127,20,127,23],\"els\":[\"0:3\"]},{\"tk\":[127,23,127,24],\"els\":[\"0:3\"]},{\"tk\":[127,24,127,28],\"els\":[\"0:3\"]},{\"tk\":[127,29,127,30],\"els\":[\"0:3\"]},{\"tk\":[127,31,127,32],\"els\":[\"0:3\"]},{\"tk\":[127,32,127,40],\"els\":[\"0:3\"]},{\"tk\":[127,40,127,41],\"els\":[\"0:3\"]},{\"tk\":[127,41,127,42],\"els\":[\"0:3\"]},{\"tk\":[127,42,127,43],\"els\":[\"0:3\"]},{\"tk\":[127,43,127,51],\"els\":[\"0:3\"]},{\"tk\":[127,51,127,52],\"els\":[\"0:3\"]},{\"tk\":[127,52,127,61],\"els\":[\"0:3\"]},{\"tk\":[127,61,127,62],\"els\":[\"0:3\"]},{\"tk\":[127,62,127,67],\"els\":[\"0:3\"]},{\"tk\":[127,68,127,69],\"els\":[\"0:3\"]},{\"tk\":[127,70,127,77],\"els\":[\"0:3\",\"0:14#out:1\"]},{\"tk\":[127,78,127,79],\"els\":[\"0:3\"]},{\"tk\":[128,7,128,11],\"els\":[\"0:3\"]},{\"tk\":[128,11,128,12],\"els\":[\"0:3\"]},{\"tk\":[128,12,128,13],\"els\":[\"0:3\"]},{\"tk\":[129,3,129,4],\"els\":[\"0:3\"]},{\"tk\":[134,3,134,4],\"els\":[\"0:23\"]},{\"tk\":[135,5,135,14],\"els\":[\"0:23\"]},{\"tk\":[135,14,135,15],\"els\":[\"0:23\"]},{\"tk\":[135,15,135,19],\"els\":[\"0:23\"]},{\"tk\":[135,19,135,20],\"els\":[\"0:23\"]},{\"tk\":[135,20,135,23],\"els\":[\"0:23\"]},{\"tk\":[135,23,135,24],\"els\":[\"0:23\"]},{\"tk\":[135,24,135,28],\"els\":[\"0:23\"]},{\"tk\":[135,29,135,30],\"els\":[\"0:23\"]},{\"tk\":[135,31,135,32],\"els\":[\"0:23\"]},{\"tk\":[135,32,135,40],\"els\":[\"0:23\"]},{\"tk\":[135,40,135,41],\"els\":[\"0:23\"]},{\"tk\":[135,41,135,42],\"els\":[\"0:23\"]},{\"tk\":[135,42,135,43],\"els\":[\"0:23\"]},{\"tk\":[135,43,135,51],\"els\":[\"0:23\"]},{\"tk\":[135,51,135,52],\"els\":[\"0:23\"]},{\"tk\":[135,52,135,61],\"els\":[\"0:23\"]},{\"tk\":[135,61,135,62],\"els\":[\"0:23\"]},{\"tk\":[135,62,135,67],\"els\":[\"0:23\"]},{\"tk\":[135,68,135,69],\"els\":[\"0:23\"]},{\"tk\":[135,70,135,79],\"els\":[\"0:23\",\"0:13#out:1\"]},{\"tk\":[135,80,135,81],\"els\":[\"0:23\"]},{\"tk\":[136,7,136,11],\"els\":[\"0:23\"]},{\"tk\":[136,11,136,12],\"els\":[\"0:23\"]},{\"tk\":[136,12,136,13],\"els\":[\"0:23\"]},{\"tk\":[137,3,137,4],\"els\":[\"0:23\"]},{\"tk\":[140,3,140,4],\"els\":[\"0:23\"]},{\"tk\":[141,5,141,14],\"els\":[\"0:23\"]},{\"tk\":[141,14,141,15],\"els\":[\"0:23\"]},{\"tk\":[141,15,141,19],\"els\":[\"0:23\"]},{\"tk\":[141,19,141,20],\"els\":[\"0:23\"]},{\"tk\":[141,20,141,23],\"els\":[\"0:23\"]},{\"tk\":[141,23,141,24],\"els\":[\"0:23\"]},{\"tk\":[141,24,141,28],\"els\":[\"0:23\"]},{\"tk\":[141,29,141,30],\"els\":[\"0:23\"]},{\"tk\":[141,31,141,32],\"els\":[\"0:23\"]},{\"tk\":[141,32,141,40],\"els\":[\"0:23\"]},{\"tk\":[141,40,141,41],\"els\":[\"0:23\"]},{\"tk\":[141,41,141,42],\"els\":[\"0:23\"]},{\"tk\":[141,42,141,43],\"els\":[\"0:23\"]},{\"tk\":[141,43,141,51],\"els\":[\"0:23\"]},{\"tk\":[141,51,141,52],\"els\":[\"0:23\"]},{\"tk\":[141,52,141,61],\"els\":[\"0:23\"]},{\"tk\":[141,61,141,62],\"els\":[\"0:23\"]},{\"tk\":[141,62,141,67],\"els\":[\"0:23\"]},{\"tk\":[141,68,141,69],\"els\":[\"0:23\"]},{\"tk\":[141,70,141,77],\"els\":[\"0:23\",\"0:14#out:1\"]},{\"tk\":[141,78,141,79],\"els\":[\"0:23\"]},{\"tk\":[142,7,142,11],\"els\":[\"0:23\"]},{\"tk\":[142,11,142,12],\"els\":[\"0:23\"]},{\"tk\":[142,12,142,13],\"els\":[\"0:23\"]},{\"tk\":[143,3,143,4],\"els\":[\"0:23\"]},{\"tk\":[150,3,150,8],\"els\":[\"0:2#out:1\"]},{\"tk\":[150,9,150,23],\"els\":[\"0:2#out:1\"]},{\"tk\":[150,24,150,25],\"els\":[\"0:2#out:1\",\"0:2\"]},{\"tk\":[150,27,150,33],\"els\":[\"0:2\"]},{\"tk\":[150,34,150,50],\"els\":[\"0:2\"]},{\"tk\":[150,51,150,52],\"els\":[\"0:2\"]},{\"tk\":[150,53,150,58],\"els\":[\"0:2\"]},{\"tk\":[150,59,150,78],\"els\":[\"0:2\"]},{\"tk\":[150,80,150,82],\"els\":[\"0:2\"]},{\"tk\":[151,6,151,12],\"els\":[\"0:2\"]},{\"tk\":[151,13,151,29],\"els\":[\"0:2\"]},{\"tk\":[151,30,151,32],\"els\":[\"0:2\"]},{\"tk\":[151,33,151,35],\"els\":[\"0:2\"]},{\"tk\":[151,37,151,38],\"els\":[\"0:2\"]},{\"tk\":[151,39,151,44],\"els\":[\"0:2\"]},{\"tk\":[151,45,151,63],\"els\":[\"0:2\"]},{\"tk\":[151,66,151,69],\"els\":[\"0:2\"]},{\"tk\":[154,3,154,5],\"els\":[\"0:2\"]},{\"tk\":[154,7,154,13],\"els\":[\"0:2\"]},{\"tk\":[154,14,154,30],\"els\":[\"0:2\"]},{\"tk\":[154,31,154,33],\"els\":[\"0:2\"]},{\"tk\":[154,34,154,39],\"els\":[\"0:2\"]},{\"tk\":[154,40,154,61],\"els\":[\"0:2\"]},{\"tk\":[154,62,154,63],\"els\":[\"0:2\"]},{\"tk\":[154,64,154,67],\"els\":[\"0:2\"]},{\"tk\":[155,5,155,11],\"els\":[\"0:2\"]},{\"tk\":[155,12,155,28],\"els\":[\"0:2\"]},{\"tk\":[155,29,155,30],\"els\":[\"0:2\"]},{\"tk\":[155,31,155,33],\"els\":[\"0:2\"]},{\"tk\":[157,5,157,11],\"els\":[\"0:2\"]},{\"tk\":[157,12,157,28],\"els\":[\"0:2\"]},{\"tk\":[157,28,157,30],\"els\":[\"0:2\"]},{\"tk\":[162,9,162,14],\"els\":[\"0:1\"]},{\"tk\":[162,15,162,29],\"els\":[\"0:1\"]},{\"tk\":[188,3,188,5],\"els\":[\"0:12\"]},{\"tk\":[188,6,188,7],\"els\":[\"0:12\"]},{\"tk\":[188,7,188,22],\"els\":[\"0:12\"]},{\"tk\":[188,23,188,25],\"els\":[\"0:12\"]},{\"tk\":[188,26,188,28],\"els\":[\"0:12\"]},{\"tk\":[188,28,188,29],\"els\":[\"0:12\"]},{\"tk\":[188,30,188,31],\"els\":[\"0:12\"]},{\"tk\":[189,5,189,13],\"els\":[\"0:12\"]},{\"tk\":[189,13,189,14],\"els\":[\"0:12\"]},{\"tk\":[189,14,189,15],\"els\":[\"0:12\"]},{\"tk\":[189,15,189,16],\"els\":[\"0:12\"]},{\"tk\":[190,5,190,20],\"els\":[\"0:12\"]},{\"tk\":[190,21,190,22],\"els\":[\"0:12\"]},{\"tk\":[190,23,190,25],\"els\":[\"0:12\"]},{\"tk\":[190,25,190,26],\"els\":[\"0:12\"]},{\"tk\":[191,3,191,4],\"els\":[\"0:12\"]},{\"tk\":[193,3,193,19],\"els\":[\"0:12\"]},{\"tk\":[193,20,193,21],\"els\":[\"0:12\"]},{\"tk\":[193,21,193,22],\"els\":[\"0:12\"]},{\"tk\":[193,22,193,23],\"els\":[\"0:12\"]},{\"tk\":[198,3,198,4],\"els\":[\"0:3\"]},{\"tk\":[213,5,213,14],\"els\":[\"0:3\"]},{\"tk\":[213,14,213,15],\"els\":[\"0:3\"]},{\"tk\":[213,15,213,20],\"els\":[\"0:3\"]},{\"tk\":[213,20,213,21],\"els\":[\"0:3\"]},{\"tk\":[213,21,213,24],\"els\":[\"0:3\"]},{\"tk\":[213,25,213,26],\"els\":[\"0:3\"]},{\"tk\":[213,27,213,28],\"els\":[\"0:3\"]},{\"tk\":[213,28,213,37],\"els\":[\"0:3\"]},{\"tk\":[213,37,213,38],\"els\":[\"0:3\"]},{\"tk\":[213,38,213,43],\"els\":[\"0:3\"]},{\"tk\":[213,43,213,44],\"els\":[\"0:3\"]},{\"tk\":[213,44,213,47],\"els\":[\"0:3\"]},{\"tk\":[213,48,213,49],\"els\":[\"0:3\"]},{\"tk\":[213,50,213,51],\"els\":[\"0:3\"]},{\"tk\":[213,51,213,58],\"els\":[\"0:3\"]},{\"tk\":[213,58,213,59],\"els\":[\"0:3\"]},{\"tk\":[213,60,213,61],\"els\":[\"0:3\"]},{\"tk\":[213,62,213,67],\"els\":[\"0:3\"]},{\"tk\":[213,67,213,68],\"els\":[\"0:3\"]},{\"tk\":[214,5,214,14],\"els\":[\"0:3\"]},{\"tk\":[214,14,214,15],\"els\":[\"0:3\"]},{\"tk\":[214,15,214,21],\"els\":[\"0:3\"]},{\"tk\":[214,21,214,22],\"els\":[\"0:3\"]},{\"tk\":[214,22,214,25],\"els\":[\"0:3\"]},{\"tk\":[214,26,214,27],\"els\":[\"0:3\"]},{\"tk\":[214,28,214,29],\"els\":[\"0:3\"]},{\"tk\":[214,29,214,38],\"els\":[\"0:3\"]},{\"tk\":[214,38,214,39],\"els\":[\"0:3\"]},{\"tk\":[214,39,214,45],\"els\":[\"0:3\"]},{\"tk\":[214,45,214,46],\"els\":[\"0:3\"]},{\"tk\":[214,46,214,49],\"els\":[\"0:3\"]},{\"tk\":[214,50,214,51],\"els\":[\"0:3\"]},{\"tk\":[214,52,214,53],\"els\":[\"0:3\"]},{\"tk\":[214,53,214,60],\"els\":[\"0:3\"]},{\"tk\":[214,60,214,61],\"els\":[\"0:3\"]},{\"tk\":[214,62,214,63],\"els\":[\"0:3\"]},{\"tk\":[214,64,214,68],\"els\":[\"0:3\"]},{\"tk\":[214,68,214,69],\"els\":[\"0:3\"]},{\"tk\":[217,5,217,14],\"els\":[\"0:3\"]},{\"tk\":[217,14,217,15],\"els\":[\"0:3\"]},{\"tk\":[217,15,217,20],\"els\":[\"0:3\"]},{\"tk\":[217,21,217,22],\"els\":[\"0:3\"]},{\"tk\":[217,23,217,28],\"els\":[\"0:3\"]},{\"tk\":[217,28,217,29],\"els\":[\"0:3\"]},{\"tk\":[222,5,222,14],\"els\":[\"0:3\"]},{\"tk\":[222,14,222,15],\"els\":[\"0:3\"]},{\"tk\":[222,15,222,20],\"els\":[\"0:3\"]},{\"tk\":[222,20,222,21],\"els\":[\"0:3\"]},{\"tk\":[222,21,222,24],\"els\":[\"0:3\"]},{\"tk\":[222,25,222,26],\"els\":[\"0:3\"]},{\"tk\":[222,27,222,28],\"els\":[\"0:3\"]},{\"tk\":[222,28,222,37],\"els\":[\"0:3\"]},{\"tk\":[222,37,222,38],\"els\":[\"0:3\"]},{\"tk\":[222,38,222,43],\"els\":[\"0:3\"]},{\"tk\":[222,43,222,44],\"els\":[\"0:3\"]},{\"tk\":[222,44,222,47],\"els\":[\"0:3\"]},{\"tk\":[222,48,222,49],\"els\":[\"0:3\"]},{\"tk\":[222,50,222,51],\"els\":[\"0:3\"]},{\"tk\":[222,51,222,62],\"els\":[\"0:3\"]},{\"tk\":[222,62,222,63],\"els\":[\"0:3\"]},{\"tk\":[222,64,222,65],\"els\":[\"0:3\"]},{\"tk\":[222,66,222,70],\"els\":[\"0:3\"]},{\"tk\":[222,70,222,71],\"els\":[\"0:3\"]},{\"tk\":[225,5,225,14],\"els\":[\"0:3\"]},{\"tk\":[225,14,225,15],\"els\":[\"0:3\"]},{\"tk\":[225,15,225,20],\"els\":[\"0:3\"]},{\"tk\":[225,21,225,22],\"els\":[\"0:3\"]},{\"tk\":[225,23,225,30],\"els\":[\"0:3\"]},{\"tk\":[225,30,225,31],\"els\":[\"0:3\"]},{\"tk\":[237,5,237,14],\"els\":[\"0:3\"]},{\"tk\":[237,14,237,15],\"els\":[\"0:3\"]},{\"tk\":[237,15,237,21],\"els\":[\"0:3\"]},{\"tk\":[237,21,237,22],\"els\":[\"0:3\"]},{\"tk\":[237,22,237,25],\"els\":[\"0:3\"]},{\"tk\":[237,26,237,27],\"els\":[\"0:3\"]},{\"tk\":[237,28,237,29],\"els\":[\"0:3\"]},{\"tk\":[237,29,237,38],\"els\":[\"0:3\"]},{\"tk\":[237,38,237,39],\"els\":[\"0:3\"]},{\"tk\":[237,39,237,45],\"els\":[\"0:3\"]},{\"tk\":[237,45,237,46],\"els\":[\"0:3\"]},{\"tk\":[237,46,237,49],\"els\":[\"0:3\"]},{\"tk\":[237,50,237,51],\"els\":[\"0:3\"]},{\"tk\":[237,52,237,53],\"els\":[\"0:3\"]},{\"tk\":[237,53,237,60],\"els\":[\"0:3\"]},{\"tk\":[237,60,237,61],\"els\":[\"0:3\"]},{\"tk\":[237,62,237,63],\"els\":[\"0:3\"]},{\"tk\":[237,64,237,68],\"els\":[\"0:3\"]},{\"tk\":[237,68,237,69],\"els\":[\"0:3\"]},{\"tk\":[246,5,246,14],\"els\":[\"0:3\"]},{\"tk\":[246,14,246,15],\"els\":[\"0:3\"]},{\"tk\":[246,15,246,22],\"els\":[\"0:3\"]},{\"tk\":[246,22,246,23],\"els\":[\"0:3\"]},{\"tk\":[246,23,246,26],\"els\":[\"0:3\"]},{\"tk\":[246,27,246,28],\"els\":[\"0:3\"]},{\"tk\":[246,29,246,30],\"els\":[\"0:3\"]},{\"tk\":[246,30,246,39],\"els\":[\"0:3\"]},{\"tk\":[246,39,246,40],\"els\":[\"0:3\"]},{\"tk\":[246,40,246,47],\"els\":[\"0:3\"]},{\"tk\":[246,47,246,48],\"els\":[\"0:3\"]},{\"tk\":[246,48,246,51],\"els\":[\"0:3\"]},{\"tk\":[246,52,246,53],\"els\":[\"0:3\"]},{\"tk\":[246,54,246,55],\"els\":[\"0:3\"]},{\"tk\":[246,55,246,62],\"els\":[\"0:3\"]},{\"tk\":[246,62,246,63],\"els\":[\"0:3\"]},{\"tk\":[246,64,246,65],\"els\":[\"0:3\"]},{\"tk\":[246,66,246,70],\"els\":[\"0:3\"]},{\"tk\":[246,70,246,71],\"els\":[\"0:3\"]},{\"tk\":[247,5,247,14],\"els\":[\"0:3\"]},{\"tk\":[247,14,247,15],\"els\":[\"0:3\"]},{\"tk\":[247,15,247,19],\"els\":[\"0:3\"]},{\"tk\":[247,19,247,20],\"els\":[\"0:3\"]},{\"tk\":[247,20,247,23],\"els\":[\"0:3\"]},{\"tk\":[247,23,247,24],\"els\":[\"0:3\"]},{\"tk\":[247,24,247,28],\"els\":[\"0:3\"]},{\"tk\":[247,29,247,30],\"els\":[\"0:3\"]},{\"tk\":[247,31,247,35],\"els\":[\"0:3\"]},{\"tk\":[247,35,247,36],\"els\":[\"0:3\"]},{\"tk\":[248,5,248,14],\"els\":[\"0:3\"]},{\"tk\":[248,14,248,15],\"els\":[\"0:3\"]},{\"tk\":[248,15,248,19],\"els\":[\"0:3\"]},{\"tk\":[248,19,248,20],\"els\":[\"0:3\"]},{\"tk\":[248,20,248,23],\"els\":[\"0:3\"]},{\"tk\":[248,23,248,24],\"els\":[\"0:3\"]},{\"tk\":[248,24,248,28],\"els\":[\"0:3\"]},{\"tk\":[248,29,248,30],\"els\":[\"0:3\"]},{\"tk\":[248,31,248,35],\"els\":[\"0:3\"]},{\"tk\":[248,35,248,36],\"els\":[\"0:3\"]},{\"tk\":[249,5,249,14],\"els\":[\"0:3\"]},{\"tk\":[249,14,249,15],\"els\":[\"0:3\"]},{\"tk\":[249,15,249,19],\"els\":[\"0:3\"]},{\"tk\":[249,20,249,21],\"els\":[\"0:3\"]},{\"tk\":[249,22,249,28],\"els\":[\"0:3\"]},{\"tk\":[249,28,249,29],\"els\":[\"0:3\"]},{\"tk\":[250,5,250,14],\"els\":[\"0:3\"]},{\"tk\":[250,14,250,15],\"els\":[\"0:3\"]},{\"tk\":[250,15,250,19],\"els\":[\"0:3\"]},{\"tk\":[250,20,250,21],\"els\":[\"0:3\"]},{\"tk\":[250,22,250,28],\"els\":[\"0:3\"]},{\"tk\":[250,28,250,29],\"els\":[\"0:3\"]},{\"tk\":[253,5,253,14],\"els\":[\"0:3\"]},{\"tk\":[253,14,253,15],\"els\":[\"0:3\"]},{\"tk\":[253,15,253,21],\"els\":[\"0:3\"]},{\"tk\":[253,21,253,22],\"els\":[\"0:3\"]},{\"tk\":[253,22,253,25],\"els\":[\"0:3\"]},{\"tk\":[253,26,253,27],\"els\":[\"0:3\"]},{\"tk\":[253,28,253,32],\"els\":[\"0:3\"]},{\"tk\":[253,32,253,33],\"els\":[\"0:3\"]},{\"tk\":[255,5,255,14],\"els\":[\"0:3\"]},{\"tk\":[255,14,255,15],\"els\":[\"0:3\"]},{\"tk\":[255,15,255,21],\"els\":[\"0:3\"]},{\"tk\":[255,21,255,22],\"els\":[\"0:3\"]},{\"tk\":[255,22,255,25],\"els\":[\"0:3\"]},{\"tk\":[255,26,255,27],\"els\":[\"0:3\"]},{\"tk\":[255,28,255,31],\"els\":[\"0:3\"]},{\"tk\":[255,31,255,32],\"els\":[\"0:3\"]},{\"tk\":[260,5,260,14],\"els\":[\"0:3\"]},{\"tk\":[260,14,260,15],\"els\":[\"0:3\"]},{\"tk\":[260,15,260,21],\"els\":[\"0:3\"]},{\"tk\":[260,21,260,22],\"els\":[\"0:3\"]},{\"tk\":[260,22,260,25],\"els\":[\"0:3\"]},{\"tk\":[260,26,260,27],\"els\":[\"0:3\"]},{\"tk\":[260,28,260,29],\"els\":[\"0:3\"]},{\"tk\":[260,29,260,38],\"els\":[\"0:3\"]},{\"tk\":[260,38,260,39],\"els\":[\"0:3\"]},{\"tk\":[260,39,260,45],\"els\":[\"0:3\"]},{\"tk\":[260,45,260,46],\"els\":[\"0:3\"]},{\"tk\":[260,46,260,49],\"els\":[\"0:3\"]},{\"tk\":[260,50,260,51],\"els\":[\"0:3\"]},{\"tk\":[260,52,260,53],\"els\":[\"0:3\"]},{\"tk\":[260,53,260,58],\"els\":[\"0:3\"]},{\"tk\":[260,58,260,59],\"els\":[\"0:3\"]},{\"tk\":[260,60,260,61],\"els\":[\"0:3\"]},{\"tk\":[260,62,260,66],\"els\":[\"0:3\"]},{\"tk\":[260,66,260,67],\"els\":[\"0:3\"]},{\"tk\":[266,5,266,14],\"els\":[\"0:3\"]},{\"tk\":[266,14,266,15],\"els\":[\"0:3\"]},{\"tk\":[266,15,266,22],\"els\":[\"0:3\"]},{\"tk\":[266,22,266,23],\"els\":[\"0:3\"]},{\"tk\":[266,23,266,26],\"els\":[\"0:3\"]},{\"tk\":[266,27,266,28],\"els\":[\"0:3\"]},{\"tk\":[266,29,266,30],\"els\":[\"0:3\"]},{\"tk\":[266,30,266,39],\"els\":[\"0:3\"]},{\"tk\":[266,39,266,40],\"els\":[\"0:3\"]},{\"tk\":[266,40,266,47],\"els\":[\"0:3\"]},{\"tk\":[266,47,266,48],\"els\":[\"0:3\"]},{\"tk\":[266,48,266,51],\"els\":[\"0:3\"]},{\"tk\":[266,52,266,53],\"els\":[\"0:3\"]},{\"tk\":[266,54,266,55],\"els\":[\"0:3\"]},{\"tk\":[266,55,266,59],\"els\":[\"0:3\"]},{\"tk\":[266,59,266,60],\"els\":[\"0:3\"]},{\"tk\":[266,61,266,62],\"els\":[\"0:3\"]},{\"tk\":[266,63,266,67],\"els\":[\"0:3\"]},{\"tk\":[266,67,266,68],\"els\":[\"0:3\"]},{\"tk\":[279,5,279,14],\"els\":[\"0:3\"]},{\"tk\":[279,14,279,15],\"els\":[\"0:3\"]},{\"tk\":[279,15,279,20],\"els\":[\"0:3\"]},{\"tk\":[279,20,279,21],\"els\":[\"0:3\"]},{\"tk\":[279,21,279,24],\"els\":[\"0:3\"]},{\"tk\":[279,25,279,26],\"els\":[\"0:3\"]},{\"tk\":[279,27,279,28],\"els\":[\"0:3\"]},{\"tk\":[279,28,279,37],\"els\":[\"0:3\"]},{\"tk\":[279,37,279,38],\"els\":[\"0:3\"]},{\"tk\":[279,38,279,43],\"els\":[\"0:3\"]},{\"tk\":[279,43,279,44],\"els\":[\"0:3\"]},{\"tk\":[279,44,279,47],\"els\":[\"0:3\"]},{\"tk\":[279,48,279,49],\"els\":[\"0:3\"]},{\"tk\":[279,50,279,51],\"els\":[\"0:3\"]},{\"tk\":[279,51,279,58],\"els\":[\"0:3\"]},{\"tk\":[279,58,279,59],\"els\":[\"0:3\"]},{\"tk\":[279,60,279,61],\"els\":[\"0:3\"]},{\"tk\":[279,62,279,66],\"els\":[\"0:3\"]},{\"tk\":[279,66,279,67],\"els\":[\"0:3\"]},{\"tk\":[280,5,280,14],\"els\":[\"0:3\"]},{\"tk\":[280,14,280,15],\"els\":[\"0:3\"]},{\"tk\":[280,15,280,20],\"els\":[\"0:3\"]},{\"tk\":[280,20,280,21],\"els\":[\"0:3\"]},{\"tk\":[280,21,280,24],\"els\":[\"0:3\"]},{\"tk\":[280,24,280,25],\"els\":[\"0:3\"]},{\"tk\":[280,25,280,30],\"els\":[\"0:3\"]},{\"tk\":[280,31,280,32],\"els\":[\"0:3\"]},{\"tk\":[280,33,280,34],\"els\":[\"0:3\"]},{\"tk\":[280,34,280,42],\"els\":[\"0:3\"]},{\"tk\":[280,42,280,43],\"els\":[\"0:3\"]},{\"tk\":[280,43,280,44],\"els\":[\"0:3\"]},{\"tk\":[280,44,280,45],\"els\":[\"0:3\"]},{\"tk\":[280,45,280,46],\"els\":[\"0:3\"]},{\"tk\":[280,46,280,47],\"els\":[\"0:3\"]},{\"tk\":[282,5,282,14],\"els\":[\"0:3\"]},{\"tk\":[282,14,282,15],\"els\":[\"0:3\"]},{\"tk\":[282,15,282,20],\"els\":[\"0:3\"]},{\"tk\":[282,20,282,21],\"els\":[\"0:3\"]},{\"tk\":[282,21,282,24],\"els\":[\"0:3\"]},{\"tk\":[282,24,282,25],\"els\":[\"0:3\"]},{\"tk\":[282,25,282,30],\"els\":[\"0:3\"]},{\"tk\":[282,31,282,32],\"els\":[\"0:3\"]},{\"tk\":[282,33,282,34],\"els\":[\"0:3\"]},{\"tk\":[282,34,282,42],\"els\":[\"0:3\"]},{\"tk\":[282,42,282,43],\"els\":[\"0:3\"]},{\"tk\":[282,43,282,44],\"els\":[\"0:3\"]},{\"tk\":[282,44,282,45],\"els\":[\"0:3\"]},{\"tk\":[282,45,282,46],\"els\":[\"0:3\"]},{\"tk\":[282,46,282,47],\"els\":[\"0:3\"]},{\"tk\":[303,5,303,14],\"els\":[\"0:3\"]},{\"tk\":[303,14,303,15],\"els\":[\"0:3\"]},{\"tk\":[303,15,303,20],\"els\":[\"0:3\"]},{\"tk\":[303,20,303,21],\"els\":[\"0:3\"]},{\"tk\":[303,21,303,24],\"els\":[\"0:3\"]},{\"tk\":[303,25,303,26],\"els\":[\"0:3\"]},{\"tk\":[303,27,303,28],\"els\":[\"0:3\"]},{\"tk\":[303,28,303,37],\"els\":[\"0:3\"]},{\"tk\":[303,37,303,38],\"els\":[\"0:3\"]},{\"tk\":[303,38,303,43],\"els\":[\"0:3\"]},{\"tk\":[303,43,303,44],\"els\":[\"0:3\"]},{\"tk\":[303,44,303,47],\"els\":[\"0:3\"]},{\"tk\":[303,48,303,49],\"els\":[\"0:3\"]},{\"tk\":[303,50,303,51],\"els\":[\"0:3\"]},{\"tk\":[303,51,303,58],\"els\":[\"0:3\"]},{\"tk\":[303,58,303,59],\"els\":[\"0:3\"]},{\"tk\":[303,60,303,61],\"els\":[\"0:3\"]},{\"tk\":[303,62,303,69],\"els\":[\"0:3\"]},{\"tk\":[303,69,303,70],\"els\":[\"0:3\"]},{\"tk\":[304,5,304,14],\"els\":[\"0:3\"]},{\"tk\":[304,14,304,15],\"els\":[\"0:3\"]},{\"tk\":[304,15,304,19],\"els\":[\"0:3\"]},{\"tk\":[304,19,304,20],\"els\":[\"0:3\"]},{\"tk\":[304,20,304,23],\"els\":[\"0:3\"]},{\"tk\":[304,24,304,25],\"els\":[\"0:3\"]},{\"tk\":[304,26,304,27],\"els\":[\"0:3\"]},{\"tk\":[304,27,304,36],\"els\":[\"0:3\"]},{\"tk\":[304,36,304,37],\"els\":[\"0:3\"]},{\"tk\":[304,37,304,41],\"els\":[\"0:3\"]},{\"tk\":[304,41,304,42],\"els\":[\"0:3\"]},{\"tk\":[304,42,304,45],\"els\":[\"0:3\"]},{\"tk\":[304,46,304,47],\"els\":[\"0:3\"]},{\"tk\":[304,48,304,49],\"els\":[\"0:3\"]},{\"tk\":[304,49,304,54],\"els\":[\"0:3\"]},{\"tk\":[304,54,304,55],\"els\":[\"0:3\"]},{\"tk\":[304,56,304,57],\"els\":[\"0:3\"]},{\"tk\":[304,58,304,63],\"els\":[\"0:3\"]},{\"tk\":[304,63,304,64],\"els\":[\"0:3\"]},{\"tk\":[305,5,305,14],\"els\":[\"0:3\"]},{\"tk\":[305,14,305,15],\"els\":[\"0:3\"]},{\"tk\":[305,15,305,22],\"els\":[\"0:3\"]},{\"tk\":[305,22,305,23],\"els\":[\"0:3\"]},{\"tk\":[305,23,305,26],\"els\":[\"0:3\"]},{\"tk\":[305,27,305,28],\"els\":[\"0:3\"]},{\"tk\":[305,29,305,30],\"els\":[\"0:3\"]},{\"tk\":[305,30,305,39],\"els\":[\"0:3\"]},{\"tk\":[305,39,305,40],\"els\":[\"0:3\"]},{\"tk\":[305,40,305,47],\"els\":[\"0:3\"]},{\"tk\":[305,47,305,48],\"els\":[\"0:3\"]},{\"tk\":[305,48,305,51],\"els\":[\"0:3\"]},{\"tk\":[305,52,305,53],\"els\":[\"0:3\"]},{\"tk\":[305,54,305,55],\"els\":[\"0:3\"]},{\"tk\":[305,55,305,61],\"els\":[\"0:3\"]},{\"tk\":[305,61,305,62],\"els\":[\"0:3\"]},{\"tk\":[305,63,305,64],\"els\":[\"0:3\"]},{\"tk\":[305,65,305,71],\"els\":[\"0:3\"]},{\"tk\":[305,71,305,72],\"els\":[\"0:3\"]},{\"tk\":[306,5,306,14],\"els\":[\"0:3\"]},{\"tk\":[306,14,306,15],\"els\":[\"0:3\"]},{\"tk\":[306,15,306,22],\"els\":[\"0:3\"]},{\"tk\":[306,22,306,23],\"els\":[\"0:3\"]},{\"tk\":[306,23,306,26],\"els\":[\"0:3\"]},{\"tk\":[306,27,306,28],\"els\":[\"0:3\"]},{\"tk\":[306,29,306,30],\"els\":[\"0:3\"]},{\"tk\":[306,30,306,39],\"els\":[\"0:3\"]},{\"tk\":[306,39,306,40],\"els\":[\"0:3\"]},{\"tk\":[306,40,306,47],\"els\":[\"0:3\"]},{\"tk\":[306,47,306,48],\"els\":[\"0:3\"]},{\"tk\":[306,48,306,51],\"els\":[\"0:3\"]},{\"tk\":[306,52,306,53],\"els\":[\"0:3\"]},{\"tk\":[306,54,306,55],\"els\":[\"0:3\"]},{\"tk\":[306,55,306,59],\"els\":[\"0:3\"]},{\"tk\":[306,59,306,60],\"els\":[\"0:3\"]},{\"tk\":[306,61,306,62],\"els\":[\"0:3\"]},{\"tk\":[306,63,306,67],\"els\":[\"0:3\"]},{\"tk\":[306,67,306,68],\"els\":[\"0:3\"]},{\"tk\":[315,5,315,14],\"els\":[\"0:3\"]},{\"tk\":[315,14,315,15],\"els\":[\"0:3\"]},{\"tk\":[315,15,315,20],\"els\":[\"0:3\"]},{\"tk\":[315,20,315,21],\"els\":[\"0:3\"]},{\"tk\":[315,21,315,24],\"els\":[\"0:3\"]},{\"tk\":[315,25,315,26],\"els\":[\"0:3\"]},{\"tk\":[315,27,315,28],\"els\":[\"0:3\"]},{\"tk\":[315,28,315,37],\"els\":[\"0:3\"]},{\"tk\":[315,37,315,38],\"els\":[\"0:3\"]},{\"tk\":[315,38,315,43],\"els\":[\"0:3\"]},{\"tk\":[315,43,315,44],\"els\":[\"0:3\"]},{\"tk\":[315,44,315,47],\"els\":[\"0:3\"]},{\"tk\":[315,48,315,49],\"els\":[\"0:3\"]},{\"tk\":[315,50,315,51],\"els\":[\"0:3\"]},{\"tk\":[315,51,315,57],\"els\":[\"0:3\"]},{\"tk\":[315,57,315,58],\"els\":[\"0:3\"]},{\"tk\":[315,59,315,60],\"els\":[\"0:3\"]},{\"tk\":[315,61,315,65],\"els\":[\"0:3\"]},{\"tk\":[315,65,315,66],\"els\":[\"0:3\"]},{\"tk\":[318,5,318,11],\"els\":[\"0:3\"]},{\"tk\":[318,11,318,12],\"els\":[\"0:3\"]},{\"tk\":[319,5,319,14],\"els\":[\"0:3\"]},{\"tk\":[319,14,319,15],\"els\":[\"0:3\"]},{\"tk\":[319,15,319,20],\"els\":[\"0:3\"]},{\"tk\":[319,20,319,21],\"els\":[\"0:3\"]},{\"tk\":[319,21,319,24],\"els\":[\"0:3\"]},{\"tk\":[319,25,319,26],\"els\":[\"0:3\"]},{\"tk\":[319,27,319,29],\"els\":[\"0:3\"]},{\"tk\":[319,29,319,30],\"els\":[\"0:3\"]},{\"tk\":[329,5,329,14],\"els\":[\"0:3\"]},{\"tk\":[329,14,329,15],\"els\":[\"0:3\"]},{\"tk\":[329,15,329,20],\"els\":[\"0:3\"]},{\"tk\":[329,20,329,21],\"els\":[\"0:3\"]},{\"tk\":[329,21,329,24],\"els\":[\"0:3\"]},{\"tk\":[329,25,329,26],\"els\":[\"0:3\"]},{\"tk\":[329,27,329,28],\"els\":[\"0:3\"]},{\"tk\":[329,28,329,37],\"els\":[\"0:3\"]},{\"tk\":[329,37,329,38],\"els\":[\"0:3\"]},{\"tk\":[329,38,329,43],\"els\":[\"0:3\"]},{\"tk\":[329,43,329,44],\"els\":[\"0:3\"]},{\"tk\":[329,44,329,47],\"els\":[\"0:3\"]},{\"tk\":[329,48,329,49],\"els\":[\"0:3\"]},{\"tk\":[329,50,329,51],\"els\":[\"0:3\"]},{\"tk\":[329,51,329,57],\"els\":[\"0:3\"]},{\"tk\":[329,57,329,58],\"els\":[\"0:3\"]},{\"tk\":[329,59,329,60],\"els\":[\"0:3\"]},{\"tk\":[329,61,329,67],\"els\":[\"0:3\"]},{\"tk\":[329,67,329,68],\"els\":[\"0:3\"]},{\"tk\":[339,5,339,14],\"els\":[\"0:3\"]},{\"tk\":[339,14,339,15],\"els\":[\"0:3\"]},{\"tk\":[339,15,339,21],\"els\":[\"0:3\"]},{\"tk\":[339,21,339,22],\"els\":[\"0:3\"]},{\"tk\":[339,22,339,25],\"els\":[\"0:3\"]},{\"tk\":[339,26,339,27],\"els\":[\"0:3\"]},{\"tk\":[339,28,339,29],\"els\":[\"0:3\"]},{\"tk\":[339,29,339,38],\"els\":[\"0:3\"]},{\"tk\":[339,38,339,39],\"els\":[\"0:3\"]},{\"tk\":[339,39,339,45],\"els\":[\"0:3\"]},{\"tk\":[339,45,339,46],\"els\":[\"0:3\"]},{\"tk\":[339,46,339,49],\"els\":[\"0:3\"]},{\"tk\":[339,50,339,51],\"els\":[\"0:3\"]},{\"tk\":[339,52,339,53],\"els\":[\"0:3\"]},{\"tk\":[339,53,339,58],\"els\":[\"0:3\"]},{\"tk\":[339,58,339,59],\"els\":[\"0:3\"]},{\"tk\":[339,60,339,61],\"els\":[\"0:3\"]},{\"tk\":[339,62,339,66],\"els\":[\"0:3\"]},{\"tk\":[339,66,339,67],\"els\":[\"0:3\"]},{\"tk\":[349,5,349,14],\"els\":[\"0:3\"]},{\"tk\":[349,14,349,15],\"els\":[\"0:3\"]},{\"tk\":[349,15,349,21],\"els\":[\"0:3\"]},{\"tk\":[349,21,349,22],\"els\":[\"0:3\"]},{\"tk\":[349,22,349,25],\"els\":[\"0:3\"]},{\"tk\":[349,26,349,27],\"els\":[\"0:3\"]},{\"tk\":[349,28,349,29],\"els\":[\"0:3\"]},{\"tk\":[349,29,349,38],\"els\":[\"0:3\"]},{\"tk\":[349,38,349,39],\"els\":[\"0:3\"]},{\"tk\":[349,39,349,45],\"els\":[\"0:3\"]},{\"tk\":[349,45,349,46],\"els\":[\"0:3\"]},{\"tk\":[349,46,349,49],\"els\":[\"0:3\"]},{\"tk\":[349,50,349,51],\"els\":[\"0:3\"]},{\"tk\":[349,52,349,53],\"els\":[\"0:3\"]},{\"tk\":[349,53,349,59],\"els\":[\"0:3\"]},{\"tk\":[349,59,349,60],\"els\":[\"0:3\"]},{\"tk\":[349,61,349,62],\"els\":[\"0:3\"]},{\"tk\":[349,63,349,67],\"els\":[\"0:3\"]},{\"tk\":[349,67,349,68],\"els\":[\"0:3\"]},{\"tk\":[359,5,359,14],\"els\":[\"0:3\"]},{\"tk\":[359,14,359,15],\"els\":[\"0:3\"]},{\"tk\":[359,15,359,21],\"els\":[\"0:3\"]},{\"tk\":[359,21,359,22],\"els\":[\"0:3\"]},{\"tk\":[359,22,359,25],\"els\":[\"0:3\"]},{\"tk\":[359,26,359,27],\"els\":[\"0:3\"]},{\"tk\":[359,28,359,29],\"els\":[\"0:3\"]},{\"tk\":[359,29,359,38],\"els\":[\"0:3\"]},{\"tk\":[359,38,359,39],\"els\":[\"0:3\"]},{\"tk\":[359,39,359,45],\"els\":[\"0:3\"]},{\"tk\":[359,45,359,46],\"els\":[\"0:3\"]},{\"tk\":[359,46,359,49],\"els\":[\"0:3\"]},{\"tk\":[359,50,359,51],\"els\":[\"0:3\"]},{\"tk\":[359,52,359,53],\"els\":[\"0:3\"]},{\"tk\":[359,53,359,59],\"els\":[\"0:3\"]},{\"tk\":[359,59,359,60],\"els\":[\"0:3\"]},{\"tk\":[359,61,359,62],\"els\":[\"0:3\"]},{\"tk\":[359,63,359,67],\"els\":[\"0:3\"]},{\"tk\":[359,67,359,68],\"els\":[\"0:3\"]},{\"tk\":[368,5,368,14],\"els\":[\"0:3\"]},{\"tk\":[368,14,368,15],\"els\":[\"0:3\"]},{\"tk\":[368,15,368,24],\"els\":[\"0:3\"]},{\"tk\":[368,24,368,25],\"els\":[\"0:3\"]},{\"tk\":[368,25,368,28],\"els\":[\"0:3\"]},{\"tk\":[368,29,368,30],\"els\":[\"0:3\"]},{\"tk\":[368,31,368,32],\"els\":[\"0:3\"]},{\"tk\":[368,32,368,41],\"els\":[\"0:3\"]},{\"tk\":[368,41,368,42],\"els\":[\"0:3\"]},{\"tk\":[368,42,368,51],\"els\":[\"0:3\"]},{\"tk\":[368,51,368,52],\"els\":[\"0:3\"]},{\"tk\":[368,52,368,55],\"els\":[\"0:3\"]},{\"tk\":[368,56,368,57],\"els\":[\"0:3\"]},{\"tk\":[368,58,368,59],\"els\":[\"0:3\"]},{\"tk\":[368,60,368,67],\"els\":[\"0:3\"]},{\"tk\":[368,67,368,68],\"els\":[\"0:3\"]},{\"tk\":[368,69,368,70],\"els\":[\"0:3\"]},{\"tk\":[368,71,368,78],\"els\":[\"0:3\"]},{\"tk\":[368,78,368,79],\"els\":[\"0:3\"]},{\"tk\":[376,5,376,14],\"els\":[\"0:3\"]},{\"tk\":[376,14,376,15],\"els\":[\"0:3\"]},{\"tk\":[376,15,376,22],\"els\":[\"0:3\"]},{\"tk\":[376,22,376,23],\"els\":[\"0:3\"]},{\"tk\":[376,23,376,26],\"els\":[\"0:3\"]},{\"tk\":[376,27,376,28],\"els\":[\"0:3\"]},{\"tk\":[376,29,376,30],\"els\":[\"0:3\"]},{\"tk\":[376,30,376,39],\"els\":[\"0:3\"]},{\"tk\":[376,39,376,40],\"els\":[\"0:3\"]},{\"tk\":[376,40,376,47],\"els\":[\"0:3\"]},{\"tk\":[376,47,376,48],\"els\":[\"0:3\"]},{\"tk\":[376,48,376,51],\"els\":[\"0:3\"]},{\"tk\":[376,52,376,53],\"els\":[\"0:3\"]},{\"tk\":[376,54,376,55],\"els\":[\"0:3\"]},{\"tk\":[376,55,376,61],\"els\":[\"0:3\"]},{\"tk\":[376,61,376,62],\"els\":[\"0:3\"]},{\"tk\":[376,63,376,64],\"els\":[\"0:3\"]},{\"tk\":[376,65,376,69],\"els\":[\"0:3\"]},{\"tk\":[376,69,376,70],\"els\":[\"0:3\"]},{\"tk\":[384,5,384,14],\"els\":[\"0:3\"]},{\"tk\":[384,14,384,15],\"els\":[\"0:3\"]},{\"tk\":[384,15,384,21],\"els\":[\"0:3\"]},{\"tk\":[384,21,384,22],\"els\":[\"0:3\"]},{\"tk\":[384,22,384,25],\"els\":[\"0:3\"]},{\"tk\":[384,26,384,27],\"els\":[\"0:3\"]},{\"tk\":[384,28,384,29],\"els\":[\"0:3\"]},{\"tk\":[384,29,384,38],\"els\":[\"0:3\"]},{\"tk\":[384,38,384,39],\"els\":[\"0:3\"]},{\"tk\":[384,39,384,45],\"els\":[\"0:3\"]},{\"tk\":[384,45,384,46],\"els\":[\"0:3\"]},{\"tk\":[384,46,384,49],\"els\":[\"0:3\"]},{\"tk\":[384,50,384,51],\"els\":[\"0:3\"]},{\"tk\":[384,52,384,53],\"els\":[\"0:3\"]},{\"tk\":[384,53,384,58],\"els\":[\"0:3\"]},{\"tk\":[384,58,384,59],\"els\":[\"0:3\"]},{\"tk\":[384,60,384,61],\"els\":[\"0:3\"]},{\"tk\":[384,62,384,67],\"els\":[\"0:3\"]},{\"tk\":[384,67,384,68],\"els\":[\"0:3\"]},{\"tk\":[385,5,385,14],\"els\":[\"0:3\"]},{\"tk\":[385,14,385,15],\"els\":[\"0:3\"]},{\"tk\":[385,15,385,24],\"els\":[\"0:3\"]},{\"tk\":[385,25,385,26],\"els\":[\"0:3\"]},{\"tk\":[385,27,385,29],\"els\":[\"0:3\"]},{\"tk\":[385,29,385,30],\"els\":[\"0:3\"]},{\"tk\":[386,5,386,14],\"els\":[\"0:3\"]},{\"tk\":[386,14,386,15],\"els\":[\"0:3\"]},{\"tk\":[386,15,386,24],\"els\":[\"0:3\"]},{\"tk\":[386,25,386,26],\"els\":[\"0:3\"]},{\"tk\":[386,27,386,29],\"els\":[\"0:3\"]},{\"tk\":[386,29,386,30],\"els\":[\"0:3\"]},{\"tk\":[391,5,391,14],\"els\":[\"0:3\"]},{\"tk\":[391,14,391,15],\"els\":[\"0:3\"]},{\"tk\":[391,15,391,23],\"els\":[\"0:3\"]},{\"tk\":[391,23,391,24],\"els\":[\"0:3\"]},{\"tk\":[391,24,391,27],\"els\":[\"0:3\"]},{\"tk\":[391,28,391,29],\"els\":[\"0:3\"]},{\"tk\":[391,30,391,31],\"els\":[\"0:3\"]},{\"tk\":[391,31,391,40],\"els\":[\"0:3\"]},{\"tk\":[391,40,391,41],\"els\":[\"0:3\"]},{\"tk\":[391,41,391,49],\"els\":[\"0:3\"]},{\"tk\":[391,49,391,50],\"els\":[\"0:3\"]},{\"tk\":[391,50,391,53],\"els\":[\"0:3\"]},{\"tk\":[391,54,391,55],\"els\":[\"0:3\"]},{\"tk\":[391,56,391,57],\"els\":[\"0:3\"]},{\"tk\":[391,57,391,61],\"els\":[\"0:3\"]},{\"tk\":[391,61,391,62],\"els\":[\"0:3\"]},{\"tk\":[391,63,391,64],\"els\":[\"0:3\"]},{\"tk\":[391,65,391,69],\"els\":[\"0:3\"]},{\"tk\":[391,69,391,70],\"els\":[\"0:3\"]},{\"tk\":[397,5,397,14],\"els\":[\"0:3\"]},{\"tk\":[397,14,397,15],\"els\":[\"0:3\"]},{\"tk\":[397,15,397,21],\"els\":[\"0:3\"]},{\"tk\":[397,21,397,22],\"els\":[\"0:3\"]},{\"tk\":[397,22,397,25],\"els\":[\"0:3\"]},{\"tk\":[397,26,397,27],\"els\":[\"0:3\"]},{\"tk\":[397,28,397,29],\"els\":[\"0:3\"]},{\"tk\":[397,29,397,38],\"els\":[\"0:3\"]},{\"tk\":[397,38,397,39],\"els\":[\"0:3\"]},{\"tk\":[397,39,397,45],\"els\":[\"0:3\"]},{\"tk\":[397,45,397,46],\"els\":[\"0:3\"]},{\"tk\":[397,46,397,49],\"els\":[\"0:3\"]},{\"tk\":[397,50,397,51],\"els\":[\"0:3\"]},{\"tk\":[397,52,397,53],\"els\":[\"0:3\"]},{\"tk\":[397,53,397,58],\"els\":[\"0:3\"]},{\"tk\":[397,58,397,59],\"els\":[\"0:3\"]},{\"tk\":[397,60,397,61],\"els\":[\"0:3\"]},{\"tk\":[397,62,397,66],\"els\":[\"0:3\"]},{\"tk\":[397,66,397,67],\"els\":[\"0:3\"]},{\"tk\":[401,5,401,14],\"els\":[\"0:3\"]},{\"tk\":[401,14,401,15],\"els\":[\"0:3\"]},{\"tk\":[401,15,401,24],\"els\":[\"0:3\"]},{\"tk\":[401,24,401,25],\"els\":[\"0:3\"]},{\"tk\":[401,25,401,28],\"els\":[\"0:3\"]},{\"tk\":[401,28,401,29],\"els\":[\"0:3\"]},{\"tk\":[401,29,401,38],\"els\":[\"0:3\"]},{\"tk\":[401,39,401,40],\"els\":[\"0:3\"]},{\"tk\":[401,41,401,43],\"els\":[\"0:3\"]},{\"tk\":[401,43,401,44],\"els\":[\"0:3\"]},{\"tk\":[402,5,402,14],\"els\":[\"0:3\"]},{\"tk\":[402,14,402,15],\"els\":[\"0:3\"]},{\"tk\":[402,15,402,24],\"els\":[\"0:3\"]},{\"tk\":[402,24,402,25],\"els\":[\"0:3\"]},{\"tk\":[402,25,402,28],\"els\":[\"0:3\"]},{\"tk\":[402,28,402,29],\"els\":[\"0:3\"]},{\"tk\":[402,29,402,37],\"els\":[\"0:3\"]},{\"tk\":[402,38,402,39],\"els\":[\"0:3\"]},{\"tk\":[402,40,402,42],\"els\":[\"0:3\"]},{\"tk\":[402,42,402,43],\"els\":[\"0:3\"]},{\"tk\":[403,5,403,14],\"els\":[\"0:3\"]},{\"tk\":[403,14,403,15],\"els\":[\"0:3\"]},{\"tk\":[403,15,403,24],\"els\":[\"0:3\"]},{\"tk\":[403,24,403,25],\"els\":[\"0:3\"]},{\"tk\":[403,25,403,28],\"els\":[\"0:3\"]},{\"tk\":[403,28,403,29],\"els\":[\"0:3\"]},{\"tk\":[403,29,403,37],\"els\":[\"0:3\"]},{\"tk\":[403,38,403,39],\"els\":[\"0:3\"]},{\"tk\":[403,40,403,42],\"els\":[\"0:3\"]},{\"tk\":[403,42,403,43],\"els\":[\"0:3\"]},{\"tk\":[404,5,404,14],\"els\":[\"0:3\"]},{\"tk\":[404,14,404,15],\"els\":[\"0:3\"]},{\"tk\":[404,15,404,24],\"els\":[\"0:3\"]},{\"tk\":[404,24,404,25],\"els\":[\"0:3\"]},{\"tk\":[404,25,404,28],\"els\":[\"0:3\"]},{\"tk\":[404,28,404,29],\"els\":[\"0:3\"]},{\"tk\":[404,29,404,37],\"els\":[\"0:3\"]},{\"tk\":[404,38,404,39],\"els\":[\"0:3\"]},{\"tk\":[404,40,404,42],\"els\":[\"0:3\"]},{\"tk\":[404,42,404,43],\"els\":[\"0:3\"]},{\"tk\":[405,5,405,14],\"els\":[\"0:3\"]},{\"tk\":[405,14,405,15],\"els\":[\"0:3\"]},{\"tk\":[405,15,405,24],\"els\":[\"0:3\"]},{\"tk\":[405,24,405,25],\"els\":[\"0:3\"]},{\"tk\":[405,25,405,28],\"els\":[\"0:3\"]},{\"tk\":[405,28,405,29],\"els\":[\"0:3\"]},{\"tk\":[405,29,405,37],\"els\":[\"0:3\"]},{\"tk\":[405,38,405,39],\"els\":[\"0:3\"]},{\"tk\":[405,40,405,42],\"els\":[\"0:3\"]},{\"tk\":[405,42,405,43],\"els\":[\"0:3\"]},{\"tk\":[411,5,411,14],\"els\":[\"0:3\"]},{\"tk\":[411,14,411,15],\"els\":[\"0:3\"]},{\"tk\":[411,15,411,21],\"els\":[\"0:3\"]},{\"tk\":[411,21,411,22],\"els\":[\"0:3\"]},{\"tk\":[411,22,411,25],\"els\":[\"0:3\"]},{\"tk\":[411,26,411,27],\"els\":[\"0:3\"]},{\"tk\":[411,28,411,29],\"els\":[\"0:3\"]},{\"tk\":[411,29,411,38],\"els\":[\"0:3\"]},{\"tk\":[411,38,411,39],\"els\":[\"0:3\"]},{\"tk\":[411,39,411,45],\"els\":[\"0:3\"]},{\"tk\":[411,45,411,46],\"els\":[\"0:3\"]},{\"tk\":[411,46,411,49],\"els\":[\"0:3\"]},{\"tk\":[411,50,411,51],\"els\":[\"0:3\"]},{\"tk\":[411,52,411,53],\"els\":[\"0:3\"]},{\"tk\":[411,53,411,58],\"els\":[\"0:3\"]},{\"tk\":[411,58,411,59],\"els\":[\"0:3\"]},{\"tk\":[411,60,411,61],\"els\":[\"0:3\"]},{\"tk\":[411,62,411,66],\"els\":[\"0:3\"]},{\"tk\":[411,66,411,67],\"els\":[\"0:3\"]},{\"tk\":[412,5,412,9],\"els\":[\"0:3\"]},{\"tk\":[412,9,412,10],\"els\":[\"0:3\"]},{\"tk\":[413,3,413,4],\"els\":[\"0:3\"]},{\"tk\":[418,3,418,4],\"els\":[\"0:23\"]},{\"tk\":[433,5,433,14],\"els\":[\"0:23\"]},{\"tk\":[433,14,433,15],\"els\":[\"0:23\"]},{\"tk\":[433,15,433,20],\"els\":[\"0:23\"]},{\"tk\":[433,20,433,21],\"els\":[\"0:23\"]},{\"tk\":[433,21,433,24],\"els\":[\"0:23\"]},{\"tk\":[433,25,433,26],\"els\":[\"0:23\"]},{\"tk\":[433,27,433,28],\"els\":[\"0:23\"]},{\"tk\":[433,28,433,37],\"els\":[\"0:23\"]},{\"tk\":[433,37,433,38],\"els\":[\"0:23\"]},{\"tk\":[433,38,433,43],\"els\":[\"0:23\"]},{\"tk\":[433,43,433,44],\"els\":[\"0:23\"]},{\"tk\":[433,44,433,47],\"els\":[\"0:23\"]},{\"tk\":[433,48,433,49],\"els\":[\"0:23\"]},{\"tk\":[433,50,433,51],\"els\":[\"0:23\"]},{\"tk\":[433,51,433,58],\"els\":[\"0:23\"]},{\"tk\":[433,58,433,59],\"els\":[\"0:23\"]},{\"tk\":[433,60,433,61],\"els\":[\"0:23\"]},{\"tk\":[433,62,433,67],\"els\":[\"0:23\"]},{\"tk\":[433,67,433,68],\"els\":[\"0:23\"]},{\"tk\":[434,5,434,14],\"els\":[\"0:23\"]},{\"tk\":[434,14,434,15],\"els\":[\"0:23\"]},{\"tk\":[434,15,434,21],\"els\":[\"0:23\"]},{\"tk\":[434,21,434,22],\"els\":[\"0:23\"]},{\"tk\":[434,22,434,25],\"els\":[\"0:23\"]},{\"tk\":[434,26,434,27],\"els\":[\"0:23\"]},{\"tk\":[434,28,434,29],\"els\":[\"0:23\"]},{\"tk\":[434,29,434,38],\"els\":[\"0:23\"]},{\"tk\":[434,38,434,39],\"els\":[\"0:23\"]},{\"tk\":[434,39,434,45],\"els\":[\"0:23\"]},{\"tk\":[434,45,434,46],\"els\":[\"0:23\"]},{\"tk\":[434,46,434,49],\"els\":[\"0:23\"]},{\"tk\":[434,50,434,51],\"els\":[\"0:23\"]},{\"tk\":[434,52,434,53],\"els\":[\"0:23\"]},{\"tk\":[434,53,434,60],\"els\":[\"0:23\"]},{\"tk\":[434,60,434,61],\"els\":[\"0:23\"]},{\"tk\":[434,62,434,63],\"els\":[\"0:23\"]},{\"tk\":[434,64,434,68],\"els\":[\"0:23\"]},{\"tk\":[434,68,434,69],\"els\":[\"0:23\"]},{\"tk\":[437,5,437,14],\"els\":[\"0:23\"]},{\"tk\":[437,14,437,15],\"els\":[\"0:23\"]},{\"tk\":[437,15,437,20],\"els\":[\"0:23\"]},{\"tk\":[437,21,437,22],\"els\":[\"0:23\"]},{\"tk\":[437,23,437,28],\"els\":[\"0:23\"]},{\"tk\":[437,28,437,29],\"els\":[\"0:23\"]},{\"tk\":[442,5,442,14],\"els\":[\"0:23\"]},{\"tk\":[442,14,442,15],\"els\":[\"0:23\"]},{\"tk\":[442,15,442,20],\"els\":[\"0:23\"]},{\"tk\":[442,20,442,21],\"els\":[\"0:23\"]},{\"tk\":[442,21,442,24],\"els\":[\"0:23\"]},{\"tk\":[442,25,442,26],\"els\":[\"0:23\"]},{\"tk\":[442,27,442,28],\"els\":[\"0:23\"]},{\"tk\":[442,28,442,37],\"els\":[\"0:23\"]},{\"tk\":[442,37,442,38],\"els\":[\"0:23\"]},{\"tk\":[442,38,442,43],\"els\":[\"0:23\"]},{\"tk\":[442,43,442,44],\"els\":[\"0:23\"]},{\"tk\":[442,44,442,47],\"els\":[\"0:23\"]},{\"tk\":[442,48,442,49],\"els\":[\"0:23\"]},{\"tk\":[442,50,442,51],\"els\":[\"0:23\"]},{\"tk\":[442,51,442,62],\"els\":[\"0:23\"]},{\"tk\":[442,62,442,63],\"els\":[\"0:23\"]},{\"tk\":[442,64,442,65],\"els\":[\"0:23\"]},{\"tk\":[442,66,442,70],\"els\":[\"0:23\"]},{\"tk\":[442,70,442,71],\"els\":[\"0:23\"]},{\"tk\":[445,5,445,14],\"els\":[\"0:23\"]},{\"tk\":[445,14,445,15],\"els\":[\"0:23\"]},{\"tk\":[445,15,445,20],\"els\":[\"0:23\"]},{\"tk\":[445,21,445,22],\"els\":[\"0:23\"]},{\"tk\":[445,23,445,30],\"els\":[\"0:23\"]},{\"tk\":[445,30,445,31],\"els\":[\"0:23\"]},{\"tk\":[457,5,457,14],\"els\":[\"0:23\"]},{\"tk\":[457,14,457,15],\"els\":[\"0:23\"]},{\"tk\":[457,15,457,21],\"els\":[\"0:23\"]},{\"tk\":[457,21,457,22],\"els\":[\"0:23\"]},{\"tk\":[457,22,457,25],\"els\":[\"0:23\"]},{\"tk\":[457,26,457,27],\"els\":[\"0:23\"]},{\"tk\":[457,28,457,29],\"els\":[\"0:23\"]},{\"tk\":[457,29,457,38],\"els\":[\"0:23\"]},{\"tk\":[457,38,457,39],\"els\":[\"0:23\"]},{\"tk\":[457,39,457,45],\"els\":[\"0:23\"]},{\"tk\":[457,45,457,46],\"els\":[\"0:23\"]},{\"tk\":[457,46,457,49],\"els\":[\"0:23\"]},{\"tk\":[457,50,457,51],\"els\":[\"0:23\"]},{\"tk\":[457,52,457,53],\"els\":[\"0:23\"]},{\"tk\":[457,53,457,60],\"els\":[\"0:23\"]},{\"tk\":[457,60,457,61],\"els\":[\"0:23\"]},{\"tk\":[457,62,457,63],\"els\":[\"0:23\"]},{\"tk\":[457,64,457,68],\"els\":[\"0:23\"]},{\"tk\":[457,68,457,69],\"els\":[\"0:23\"]},{\"tk\":[466,5,466,14],\"els\":[\"0:23\"]},{\"tk\":[466,14,466,15],\"els\":[\"0:23\"]},{\"tk\":[466,15,466,22],\"els\":[\"0:23\"]},{\"tk\":[466,22,466,23],\"els\":[\"0:23\"]},{\"tk\":[466,23,466,26],\"els\":[\"0:23\"]},{\"tk\":[466,27,466,28],\"els\":[\"0:23\"]},{\"tk\":[466,29,466,30],\"els\":[\"0:23\"]},{\"tk\":[466,30,466,39],\"els\":[\"0:23\"]},{\"tk\":[466,39,466,40],\"els\":[\"0:23\"]},{\"tk\":[466,40,466,47],\"els\":[\"0:23\"]},{\"tk\":[466,47,466,48],\"els\":[\"0:23\"]},{\"tk\":[466,48,466,51],\"els\":[\"0:23\"]},{\"tk\":[466,52,466,53],\"els\":[\"0:23\"]},{\"tk\":[466,54,466,55],\"els\":[\"0:23\"]},{\"tk\":[466,55,466,62],\"els\":[\"0:23\"]},{\"tk\":[466,62,466,63],\"els\":[\"0:23\"]},{\"tk\":[466,64,466,65],\"els\":[\"0:23\"]},{\"tk\":[466,66,466,70],\"els\":[\"0:23\"]},{\"tk\":[466,70,466,71],\"els\":[\"0:23\"]},{\"tk\":[467,5,467,14],\"els\":[\"0:23\"]},{\"tk\":[467,14,467,15],\"els\":[\"0:23\"]},{\"tk\":[467,15,467,19],\"els\":[\"0:23\"]},{\"tk\":[467,19,467,20],\"els\":[\"0:23\"]},{\"tk\":[467,20,467,23],\"els\":[\"0:23\"]},{\"tk\":[467,23,467,24],\"els\":[\"0:23\"]},{\"tk\":[467,24,467,28],\"els\":[\"0:23\"]},{\"tk\":[467,29,467,30],\"els\":[\"0:23\"]},{\"tk\":[467,31,467,35],\"els\":[\"0:23\"]},{\"tk\":[467,35,467,36],\"els\":[\"0:23\"]},{\"tk\":[468,5,468,14],\"els\":[\"0:23\"]},{\"tk\":[468,14,468,15],\"els\":[\"0:23\"]},{\"tk\":[468,15,468,19],\"els\":[\"0:23\"]},{\"tk\":[468,19,468,20],\"els\":[\"0:23\"]},{\"tk\":[468,20,468,23],\"els\":[\"0:23\"]},{\"tk\":[468,23,468,24],\"els\":[\"0:23\"]},{\"tk\":[468,24,468,28],\"els\":[\"0:23\"]},{\"tk\":[468,29,468,30],\"els\":[\"0:23\"]},{\"tk\":[468,31,468,35],\"els\":[\"0:23\"]},{\"tk\":[468,35,468,36],\"els\":[\"0:23\"]},{\"tk\":[469,5,469,14],\"els\":[\"0:23\"]},{\"tk\":[469,14,469,15],\"els\":[\"0:23\"]},{\"tk\":[469,15,469,19],\"els\":[\"0:23\"]},{\"tk\":[469,20,469,21],\"els\":[\"0:23\"]},{\"tk\":[469,22,469,28],\"els\":[\"0:23\"]},{\"tk\":[469,28,469,29],\"els\":[\"0:23\"]},{\"tk\":[470,5,470,14],\"els\":[\"0:23\"]},{\"tk\":[470,14,470,15],\"els\":[\"0:23\"]},{\"tk\":[470,15,470,19],\"els\":[\"0:23\"]},{\"tk\":[470,20,470,21],\"els\":[\"0:23\"]},{\"tk\":[470,22,470,28],\"els\":[\"0:23\"]},{\"tk\":[470,28,470,29],\"els\":[\"0:23\"]},{\"tk\":[473,5,473,14],\"els\":[\"0:23\"]},{\"tk\":[473,14,473,15],\"els\":[\"0:23\"]},{\"tk\":[473,15,473,21],\"els\":[\"0:23\"]},{\"tk\":[473,21,473,22],\"els\":[\"0:23\"]},{\"tk\":[473,22,473,25],\"els\":[\"0:23\"]},{\"tk\":[473,26,473,27],\"els\":[\"0:23\"]},{\"tk\":[473,28,473,31],\"els\":[\"0:23\"]},{\"tk\":[473,31,473,32],\"els\":[\"0:23\"]},{\"tk\":[474,5,474,14],\"els\":[\"0:23\"]},{\"tk\":[474,14,474,15],\"els\":[\"0:23\"]},{\"tk\":[474,15,474,21],\"els\":[\"0:23\"]},{\"tk\":[474,21,474,22],\"els\":[\"0:23\"]},{\"tk\":[474,22,474,25],\"els\":[\"0:23\"]},{\"tk\":[474,26,474,27],\"els\":[\"0:23\"]},{\"tk\":[474,28,474,32],\"els\":[\"0:23\"]},{\"tk\":[474,32,474,33],\"els\":[\"0:23\"]},{\"tk\":[480,5,480,14],\"els\":[\"0:23\"]},{\"tk\":[480,14,480,15],\"els\":[\"0:23\"]},{\"tk\":[480,15,480,21],\"els\":[\"0:23\"]},{\"tk\":[480,21,480,22],\"els\":[\"0:23\"]},{\"tk\":[480,22,480,25],\"els\":[\"0:23\"]},{\"tk\":[480,26,480,27],\"els\":[\"0:23\"]},{\"tk\":[480,28,480,29],\"els\":[\"0:23\"]},{\"tk\":[480,29,480,38],\"els\":[\"0:23\"]},{\"tk\":[480,38,480,39],\"els\":[\"0:23\"]},{\"tk\":[480,39,480,45],\"els\":[\"0:23\"]},{\"tk\":[480,45,480,46],\"els\":[\"0:23\"]},{\"tk\":[480,46,480,49],\"els\":[\"0:23\"]},{\"tk\":[480,50,480,51],\"els\":[\"0:23\"]},{\"tk\":[480,52,480,53],\"els\":[\"0:23\"]},{\"tk\":[480,53,480,58],\"els\":[\"0:23\"]},{\"tk\":[480,58,480,59],\"els\":[\"0:23\"]},{\"tk\":[480,60,480,61],\"els\":[\"0:23\"]},{\"tk\":[480,62,480,66],\"els\":[\"0:23\"]},{\"tk\":[480,66,480,67],\"els\":[\"0:23\"]},{\"tk\":[486,5,486,14],\"els\":[\"0:23\"]},{\"tk\":[486,14,486,15],\"els\":[\"0:23\"]},{\"tk\":[486,15,486,22],\"els\":[\"0:23\"]},{\"tk\":[486,22,486,23],\"els\":[\"0:23\"]},{\"tk\":[486,23,486,26],\"els\":[\"0:23\"]},{\"tk\":[486,27,486,28],\"els\":[\"0:23\"]},{\"tk\":[486,29,486,30],\"els\":[\"0:23\"]},{\"tk\":[486,30,486,39],\"els\":[\"0:23\"]},{\"tk\":[486,39,486,40],\"els\":[\"0:23\"]},{\"tk\":[486,40,486,47],\"els\":[\"0:23\"]},{\"tk\":[486,47,486,48],\"els\":[\"0:23\"]},{\"tk\":[486,48,486,51],\"els\":[\"0:23\"]},{\"tk\":[486,52,486,53],\"els\":[\"0:23\"]},{\"tk\":[486,54,486,55],\"els\":[\"0:23\"]},{\"tk\":[486,55,486,59],\"els\":[\"0:23\"]},{\"tk\":[486,59,486,60],\"els\":[\"0:23\"]},{\"tk\":[486,61,486,62],\"els\":[\"0:23\"]},{\"tk\":[486,63,486,67],\"els\":[\"0:23\"]},{\"tk\":[486,67,486,68],\"els\":[\"0:23\"]},{\"tk\":[499,5,499,14],\"els\":[\"0:23\"]},{\"tk\":[499,14,499,15],\"els\":[\"0:23\"]},{\"tk\":[499,15,499,20],\"els\":[\"0:23\"]},{\"tk\":[499,20,499,21],\"els\":[\"0:23\"]},{\"tk\":[499,21,499,24],\"els\":[\"0:23\"]},{\"tk\":[499,25,499,26],\"els\":[\"0:23\"]},{\"tk\":[499,27,499,28],\"els\":[\"0:23\"]},{\"tk\":[499,28,499,37],\"els\":[\"0:23\"]},{\"tk\":[499,37,499,38],\"els\":[\"0:23\"]},{\"tk\":[499,38,499,43],\"els\":[\"0:23\"]},{\"tk\":[499,43,499,44],\"els\":[\"0:23\"]},{\"tk\":[499,44,499,47],\"els\":[\"0:23\"]},{\"tk\":[499,48,499,49],\"els\":[\"0:23\"]},{\"tk\":[499,50,499,51],\"els\":[\"0:23\"]},{\"tk\":[499,51,499,58],\"els\":[\"0:23\"]},{\"tk\":[499,58,499,59],\"els\":[\"0:23\"]},{\"tk\":[499,60,499,61],\"els\":[\"0:23\"]},{\"tk\":[499,62,499,66],\"els\":[\"0:23\"]},{\"tk\":[499,66,499,67],\"els\":[\"0:23\"]},{\"tk\":[500,5,500,14],\"els\":[\"0:23\"]},{\"tk\":[500,14,500,15],\"els\":[\"0:23\"]},{\"tk\":[500,15,500,20],\"els\":[\"0:23\"]},{\"tk\":[500,20,500,21],\"els\":[\"0:23\"]},{\"tk\":[500,21,500,24],\"els\":[\"0:23\"]},{\"tk\":[500,24,500,25],\"els\":[\"0:23\"]},{\"tk\":[500,25,500,30],\"els\":[\"0:23\"]},{\"tk\":[500,31,500,32],\"els\":[\"0:23\"]},{\"tk\":[500,33,500,34],\"els\":[\"0:23\"]},{\"tk\":[500,34,500,42],\"els\":[\"0:23\"]},{\"tk\":[500,42,500,43],\"els\":[\"0:23\"]},{\"tk\":[500,43,500,44],\"els\":[\"0:23\"]},{\"tk\":[500,44,500,45],\"els\":[\"0:23\"]},{\"tk\":[500,45,500,46],\"els\":[\"0:23\"]},{\"tk\":[500,46,500,47],\"els\":[\"0:23\"]},{\"tk\":[502,5,502,14],\"els\":[\"0:23\"]},{\"tk\":[502,14,502,15],\"els\":[\"0:23\"]},{\"tk\":[502,15,502,20],\"els\":[\"0:23\"]},{\"tk\":[502,20,502,21],\"els\":[\"0:23\"]},{\"tk\":[502,21,502,24],\"els\":[\"0:23\"]},{\"tk\":[502,24,502,25],\"els\":[\"0:23\"]},{\"tk\":[502,25,502,30],\"els\":[\"0:23\"]},{\"tk\":[502,31,502,32],\"els\":[\"0:23\"]},{\"tk\":[502,33,502,34],\"els\":[\"0:23\"]},{\"tk\":[502,34,502,42],\"els\":[\"0:23\"]},{\"tk\":[502,42,502,43],\"els\":[\"0:23\"]},{\"tk\":[502,43,502,44],\"els\":[\"0:23\"]},{\"tk\":[502,44,502,45],\"els\":[\"0:23\"]},{\"tk\":[502,45,502,46],\"els\":[\"0:23\"]},{\"tk\":[502,46,502,47],\"els\":[\"0:23\"]},{\"tk\":[523,5,523,14],\"els\":[\"0:23\"]},{\"tk\":[523,14,523,15],\"els\":[\"0:23\"]},{\"tk\":[523,15,523,20],\"els\":[\"0:23\"]},{\"tk\":[523,20,523,21],\"els\":[\"0:23\"]},{\"tk\":[523,21,523,24],\"els\":[\"0:23\"]},{\"tk\":[523,25,523,26],\"els\":[\"0:23\"]},{\"tk\":[523,27,523,28],\"els\":[\"0:23\"]},{\"tk\":[523,28,523,37],\"els\":[\"0:23\"]},{\"tk\":[523,37,523,38],\"els\":[\"0:23\"]},{\"tk\":[523,38,523,43],\"els\":[\"0:23\"]},{\"tk\":[523,43,523,44],\"els\":[\"0:23\"]},{\"tk\":[523,44,523,47],\"els\":[\"0:23\"]},{\"tk\":[523,48,523,49],\"els\":[\"0:23\"]},{\"tk\":[523,50,523,51],\"els\":[\"0:23\"]},{\"tk\":[523,51,523,58],\"els\":[\"0:23\"]},{\"tk\":[523,58,523,59],\"els\":[\"0:23\"]},{\"tk\":[523,60,523,61],\"els\":[\"0:23\"]},{\"tk\":[523,62,523,69],\"els\":[\"0:23\"]},{\"tk\":[523,69,523,70],\"els\":[\"0:23\"]},{\"tk\":[524,5,524,14],\"els\":[\"0:23\"]},{\"tk\":[524,14,524,15],\"els\":[\"0:23\"]},{\"tk\":[524,15,524,19],\"els\":[\"0:23\"]},{\"tk\":[524,19,524,20],\"els\":[\"0:23\"]},{\"tk\":[524,20,524,23],\"els\":[\"0:23\"]},{\"tk\":[524,24,524,25],\"els\":[\"0:23\"]},{\"tk\":[524,26,524,27],\"els\":[\"0:23\"]},{\"tk\":[524,27,524,36],\"els\":[\"0:23\"]},{\"tk\":[524,36,524,37],\"els\":[\"0:23\"]},{\"tk\":[524,37,524,41],\"els\":[\"0:23\"]},{\"tk\":[524,41,524,42],\"els\":[\"0:23\"]},{\"tk\":[524,42,524,45],\"els\":[\"0:23\"]},{\"tk\":[524,46,524,47],\"els\":[\"0:23\"]},{\"tk\":[524,48,524,49],\"els\":[\"0:23\"]},{\"tk\":[524,49,524,54],\"els\":[\"0:23\"]},{\"tk\":[524,54,524,55],\"els\":[\"0:23\"]},{\"tk\":[524,56,524,57],\"els\":[\"0:23\"]},{\"tk\":[524,58,524,63],\"els\":[\"0:23\"]},{\"tk\":[524,63,524,64],\"els\":[\"0:23\"]},{\"tk\":[525,5,525,14],\"els\":[\"0:23\"]},{\"tk\":[525,14,525,15],\"els\":[\"0:23\"]},{\"tk\":[525,15,525,22],\"els\":[\"0:23\"]},{\"tk\":[525,22,525,23],\"els\":[\"0:23\"]},{\"tk\":[525,23,525,26],\"els\":[\"0:23\"]},{\"tk\":[525,27,525,28],\"els\":[\"0:23\"]},{\"tk\":[525,29,525,30],\"els\":[\"0:23\"]},{\"tk\":[525,30,525,39],\"els\":[\"0:23\"]},{\"tk\":[525,39,525,40],\"els\":[\"0:23\"]},{\"tk\":[525,40,525,47],\"els\":[\"0:23\"]},{\"tk\":[525,47,525,48],\"els\":[\"0:23\"]},{\"tk\":[525,48,525,51],\"els\":[\"0:23\"]},{\"tk\":[525,52,525,53],\"els\":[\"0:23\"]},{\"tk\":[525,54,525,55],\"els\":[\"0:23\"]},{\"tk\":[525,55,525,61],\"els\":[\"0:23\"]},{\"tk\":[525,61,525,62],\"els\":[\"0:23\"]},{\"tk\":[525,63,525,64],\"els\":[\"0:23\"]},{\"tk\":[525,65,525,71],\"els\":[\"0:23\"]},{\"tk\":[525,71,525,72],\"els\":[\"0:23\"]},{\"tk\":[526,5,526,14],\"els\":[\"0:23\"]},{\"tk\":[526,14,526,15],\"els\":[\"0:23\"]},{\"tk\":[526,15,526,22],\"els\":[\"0:23\"]},{\"tk\":[526,22,526,23],\"els\":[\"0:23\"]},{\"tk\":[526,23,526,26],\"els\":[\"0:23\"]},{\"tk\":[526,27,526,28],\"els\":[\"0:23\"]},{\"tk\":[526,29,526,30],\"els\":[\"0:23\"]},{\"tk\":[526,30,526,39],\"els\":[\"0:23\"]},{\"tk\":[526,39,526,40],\"els\":[\"0:23\"]},{\"tk\":[526,40,526,47],\"els\":[\"0:23\"]},{\"tk\":[526,47,526,48],\"els\":[\"0:23\"]},{\"tk\":[526,48,526,51],\"els\":[\"0:23\"]},{\"tk\":[526,52,526,53],\"els\":[\"0:23\"]},{\"tk\":[526,54,526,55],\"els\":[\"0:23\"]},{\"tk\":[526,55,526,59],\"els\":[\"0:23\"]},{\"tk\":[526,59,526,60],\"els\":[\"0:23\"]},{\"tk\":[526,61,526,62],\"els\":[\"0:23\"]},{\"tk\":[526,63,526,67],\"els\":[\"0:23\"]},{\"tk\":[526,67,526,68],\"els\":[\"0:23\"]},{\"tk\":[535,5,535,14],\"els\":[\"0:23\"]},{\"tk\":[535,14,535,15],\"els\":[\"0:23\"]},{\"tk\":[535,15,535,20],\"els\":[\"0:23\"]},{\"tk\":[535,20,535,21],\"els\":[\"0:23\"]},{\"tk\":[535,21,535,24],\"els\":[\"0:23\"]},{\"tk\":[535,25,535,26],\"els\":[\"0:23\"]},{\"tk\":[535,27,535,28],\"els\":[\"0:23\"]},{\"tk\":[535,28,535,37],\"els\":[\"0:23\"]},{\"tk\":[535,37,535,38],\"els\":[\"0:23\"]},{\"tk\":[535,38,535,43],\"els\":[\"0:23\"]},{\"tk\":[535,43,535,44],\"els\":[\"0:23\"]},{\"tk\":[535,44,535,47],\"els\":[\"0:23\"]},{\"tk\":[535,48,535,49],\"els\":[\"0:23\"]},{\"tk\":[535,50,535,51],\"els\":[\"0:23\"]},{\"tk\":[535,51,535,57],\"els\":[\"0:23\"]},{\"tk\":[535,57,535,58],\"els\":[\"0:23\"]},{\"tk\":[535,59,535,60],\"els\":[\"0:23\"]},{\"tk\":[535,61,535,65],\"els\":[\"0:23\"]},{\"tk\":[535,65,535,66],\"els\":[\"0:23\"]},{\"tk\":[538,5,538,11],\"els\":[\"0:23\"]},{\"tk\":[538,11,538,12],\"els\":[\"0:23\"]},{\"tk\":[539,5,539,14],\"els\":[\"0:23\"]},{\"tk\":[539,14,539,15],\"els\":[\"0:23\"]},{\"tk\":[539,15,539,20],\"els\":[\"0:23\"]},{\"tk\":[539,20,539,21],\"els\":[\"0:23\"]},{\"tk\":[539,21,539,24],\"els\":[\"0:23\"]},{\"tk\":[539,25,539,26],\"els\":[\"0:23\"]},{\"tk\":[539,27,539,29],\"els\":[\"0:23\"]},{\"tk\":[539,29,539,30],\"els\":[\"0:23\"]},{\"tk\":[549,5,549,14],\"els\":[\"0:23\"]},{\"tk\":[549,14,549,15],\"els\":[\"0:23\"]},{\"tk\":[549,15,549,20],\"els\":[\"0:23\"]},{\"tk\":[549,20,549,21],\"els\":[\"0:23\"]},{\"tk\":[549,21,549,24],\"els\":[\"0:23\"]},{\"tk\":[549,25,549,26],\"els\":[\"0:23\"]},{\"tk\":[549,27,549,28],\"els\":[\"0:23\"]},{\"tk\":[549,28,549,37],\"els\":[\"0:23\"]},{\"tk\":[549,37,549,38],\"els\":[\"0:23\"]},{\"tk\":[549,38,549,43],\"els\":[\"0:23\"]},{\"tk\":[549,43,549,44],\"els\":[\"0:23\"]},{\"tk\":[549,44,549,47],\"els\":[\"0:23\"]},{\"tk\":[549,48,549,49],\"els\":[\"0:23\"]},{\"tk\":[549,50,549,51],\"els\":[\"0:23\"]},{\"tk\":[549,51,549,57],\"els\":[\"0:23\"]},{\"tk\":[549,57,549,58],\"els\":[\"0:23\"]},{\"tk\":[549,59,549,60],\"els\":[\"0:23\"]},{\"tk\":[549,61,549,67],\"els\":[\"0:23\"]},{\"tk\":[549,67,549,68],\"els\":[\"0:23\"]},{\"tk\":[559,5,559,14],\"els\":[\"0:23\"]},{\"tk\":[559,14,559,15],\"els\":[\"0:23\"]},{\"tk\":[559,15,559,21],\"els\":[\"0:23\"]},{\"tk\":[559,21,559,22],\"els\":[\"0:23\"]},{\"tk\":[559,22,559,25],\"els\":[\"0:23\"]},{\"tk\":[559,26,559,27],\"els\":[\"0:23\"]},{\"tk\":[559,28,559,29],\"els\":[\"0:23\"]},{\"tk\":[559,29,559,38],\"els\":[\"0:23\"]},{\"tk\":[559,38,559,39],\"els\":[\"0:23\"]},{\"tk\":[559,39,559,45],\"els\":[\"0:23\"]},{\"tk\":[559,45,559,46],\"els\":[\"0:23\"]},{\"tk\":[559,46,559,49],\"els\":[\"0:23\"]},{\"tk\":[559,50,559,51],\"els\":[\"0:23\"]},{\"tk\":[559,52,559,53],\"els\":[\"0:23\"]},{\"tk\":[559,53,559,58],\"els\":[\"0:23\"]},{\"tk\":[559,58,559,59],\"els\":[\"0:23\"]},{\"tk\":[559,60,559,61],\"els\":[\"0:23\"]},{\"tk\":[559,62,559,66],\"els\":[\"0:23\"]},{\"tk\":[559,66,559,67],\"els\":[\"0:23\"]},{\"tk\":[569,5,569,14],\"els\":[\"0:23\"]},{\"tk\":[569,14,569,15],\"els\":[\"0:23\"]},{\"tk\":[569,15,569,21],\"els\":[\"0:23\"]},{\"tk\":[569,21,569,22],\"els\":[\"0:23\"]},{\"tk\":[569,22,569,25],\"els\":[\"0:23\"]},{\"tk\":[569,26,569,27],\"els\":[\"0:23\"]},{\"tk\":[569,28,569,29],\"els\":[\"0:23\"]},{\"tk\":[569,29,569,38],\"els\":[\"0:23\"]},{\"tk\":[569,38,569,39],\"els\":[\"0:23\"]},{\"tk\":[569,39,569,45],\"els\":[\"0:23\"]},{\"tk\":[569,45,569,46],\"els\":[\"0:23\"]},{\"tk\":[569,46,569,49],\"els\":[\"0:23\"]},{\"tk\":[569,50,569,51],\"els\":[\"0:23\"]},{\"tk\":[569,52,569,53],\"els\":[\"0:23\"]},{\"tk\":[569,53,569,59],\"els\":[\"0:23\"]},{\"tk\":[569,59,569,60],\"els\":[\"0:23\"]},{\"tk\":[569,61,569,62],\"els\":[\"0:23\"]},{\"tk\":[569,63,569,67],\"els\":[\"0:23\"]},{\"tk\":[569,67,569,68],\"els\":[\"0:23\"]},{\"tk\":[579,5,579,14],\"els\":[\"0:23\"]},{\"tk\":[579,14,579,15],\"els\":[\"0:23\"]},{\"tk\":[579,15,579,21],\"els\":[\"0:23\"]},{\"tk\":[579,21,579,22],\"els\":[\"0:23\"]},{\"tk\":[579,22,579,25],\"els\":[\"0:23\"]},{\"tk\":[579,26,579,27],\"els\":[\"0:23\"]},{\"tk\":[579,28,579,29],\"els\":[\"0:23\"]},{\"tk\":[579,29,579,38],\"els\":[\"0:23\"]},{\"tk\":[579,38,579,39],\"els\":[\"0:23\"]},{\"tk\":[579,39,579,45],\"els\":[\"0:23\"]},{\"tk\":[579,45,579,46],\"els\":[\"0:23\"]},{\"tk\":[579,46,579,49],\"els\":[\"0:23\"]},{\"tk\":[579,50,579,51],\"els\":[\"0:23\"]},{\"tk\":[579,52,579,53],\"els\":[\"0:23\"]},{\"tk\":[579,53,579,59],\"els\":[\"0:23\"]},{\"tk\":[579,59,579,60],\"els\":[\"0:23\"]},{\"tk\":[579,61,579,62],\"els\":[\"0:23\"]},{\"tk\":[579,63,579,67],\"els\":[\"0:23\"]},{\"tk\":[579,67,579,68],\"els\":[\"0:23\"]},{\"tk\":[588,5,588,14],\"els\":[\"0:23\"]},{\"tk\":[588,14,588,15],\"els\":[\"0:23\"]},{\"tk\":[588,15,588,24],\"els\":[\"0:23\"]},{\"tk\":[588,24,588,25],\"els\":[\"0:23\"]},{\"tk\":[588,25,588,28],\"els\":[\"0:23\"]},{\"tk\":[588,29,588,30],\"els\":[\"0:23\"]},{\"tk\":[588,31,588,32],\"els\":[\"0:23\"]},{\"tk\":[588,32,588,41],\"els\":[\"0:23\"]},{\"tk\":[588,41,588,42],\"els\":[\"0:23\"]},{\"tk\":[588,42,588,51],\"els\":[\"0:23\"]},{\"tk\":[588,51,588,52],\"els\":[\"0:23\"]},{\"tk\":[588,52,588,55],\"els\":[\"0:23\"]},{\"tk\":[588,56,588,57],\"els\":[\"0:23\"]},{\"tk\":[588,58,588,59],\"els\":[\"0:23\"]},{\"tk\":[588,60,588,67],\"els\":[\"0:23\"]},{\"tk\":[588,67,588,68],\"els\":[\"0:23\"]},{\"tk\":[588,69,588,70],\"els\":[\"0:23\"]},{\"tk\":[588,71,588,78],\"els\":[\"0:23\"]},{\"tk\":[588,78,588,79],\"els\":[\"0:23\"]},{\"tk\":[596,5,596,14],\"els\":[\"0:23\"]},{\"tk\":[596,14,596,15],\"els\":[\"0:23\"]},{\"tk\":[596,15,596,22],\"els\":[\"0:23\"]},{\"tk\":[596,22,596,23],\"els\":[\"0:23\"]},{\"tk\":[596,23,596,26],\"els\":[\"0:23\"]},{\"tk\":[596,27,596,28],\"els\":[\"0:23\"]},{\"tk\":[596,29,596,30],\"els\":[\"0:23\"]},{\"tk\":[596,30,596,39],\"els\":[\"0:23\"]},{\"tk\":[596,39,596,40],\"els\":[\"0:23\"]},{\"tk\":[596,40,596,47],\"els\":[\"0:23\"]},{\"tk\":[596,47,596,48],\"els\":[\"0:23\"]},{\"tk\":[596,48,596,51],\"els\":[\"0:23\"]},{\"tk\":[596,52,596,53],\"els\":[\"0:23\"]},{\"tk\":[596,54,596,55],\"els\":[\"0:23\"]},{\"tk\":[596,55,596,61],\"els\":[\"0:23\"]},{\"tk\":[596,61,596,62],\"els\":[\"0:23\"]},{\"tk\":[596,63,596,64],\"els\":[\"0:23\"]},{\"tk\":[596,65,596,69],\"els\":[\"0:23\"]},{\"tk\":[596,69,596,70],\"els\":[\"0:23\"]},{\"tk\":[604,5,604,14],\"els\":[\"0:23\"]},{\"tk\":[604,14,604,15],\"els\":[\"0:23\"]},{\"tk\":[604,15,604,21],\"els\":[\"0:23\"]},{\"tk\":[604,21,604,22],\"els\":[\"0:23\"]},{\"tk\":[604,22,604,25],\"els\":[\"0:23\"]},{\"tk\":[604,26,604,27],\"els\":[\"0:23\"]},{\"tk\":[604,28,604,29],\"els\":[\"0:23\"]},{\"tk\":[604,29,604,38],\"els\":[\"0:23\"]},{\"tk\":[604,38,604,39],\"els\":[\"0:23\"]},{\"tk\":[604,39,604,45],\"els\":[\"0:23\"]},{\"tk\":[604,45,604,46],\"els\":[\"0:23\"]},{\"tk\":[604,46,604,49],\"els\":[\"0:23\"]},{\"tk\":[604,50,604,51],\"els\":[\"0:23\"]},{\"tk\":[604,52,604,53],\"els\":[\"0:23\"]},{\"tk\":[604,53,604,58],\"els\":[\"0:23\"]},{\"tk\":[604,58,604,59],\"els\":[\"0:23\"]},{\"tk\":[604,60,604,61],\"els\":[\"0:23\"]},{\"tk\":[604,62,604,67],\"els\":[\"0:23\"]},{\"tk\":[604,67,604,68],\"els\":[\"0:23\"]},{\"tk\":[605,5,605,14],\"els\":[\"0:23\"]},{\"tk\":[605,14,605,15],\"els\":[\"0:23\"]},{\"tk\":[605,15,605,24],\"els\":[\"0:23\"]},{\"tk\":[605,25,605,26],\"els\":[\"0:23\"]},{\"tk\":[605,27,605,29],\"els\":[\"0:23\"]},{\"tk\":[605,29,605,30],\"els\":[\"0:23\"]},{\"tk\":[606,5,606,14],\"els\":[\"0:23\"]},{\"tk\":[606,14,606,15],\"els\":[\"0:23\"]},{\"tk\":[606,15,606,24],\"els\":[\"0:23\"]},{\"tk\":[606,25,606,26],\"els\":[\"0:23\"]},{\"tk\":[606,27,606,29],\"els\":[\"0:23\"]},{\"tk\":[606,29,606,30],\"els\":[\"0:23\"]},{\"tk\":[611,5,611,14],\"els\":[\"0:23\"]},{\"tk\":[611,14,611,15],\"els\":[\"0:23\"]},{\"tk\":[611,15,611,23],\"els\":[\"0:23\"]},{\"tk\":[611,23,611,24],\"els\":[\"0:23\"]},{\"tk\":[611,24,611,27],\"els\":[\"0:23\"]},{\"tk\":[611,28,611,29],\"els\":[\"0:23\"]},{\"tk\":[611,30,611,31],\"els\":[\"0:23\"]},{\"tk\":[611,31,611,40],\"els\":[\"0:23\"]},{\"tk\":[611,40,611,41],\"els\":[\"0:23\"]},{\"tk\":[611,41,611,49],\"els\":[\"0:23\"]},{\"tk\":[611,49,611,50],\"els\":[\"0:23\"]},{\"tk\":[611,50,611,53],\"els\":[\"0:23\"]},{\"tk\":[611,54,611,55],\"els\":[\"0:23\"]},{\"tk\":[611,56,611,57],\"els\":[\"0:23\"]},{\"tk\":[611,57,611,61],\"els\":[\"0:23\"]},{\"tk\":[611,61,611,62],\"els\":[\"0:23\"]},{\"tk\":[611,63,611,64],\"els\":[\"0:23\"]},{\"tk\":[611,65,611,69],\"els\":[\"0:23\"]},{\"tk\":[611,69,611,70],\"els\":[\"0:23\"]},{\"tk\":[617,5,617,14],\"els\":[\"0:23\"]},{\"tk\":[617,14,617,15],\"els\":[\"0:23\"]},{\"tk\":[617,15,617,21],\"els\":[\"0:23\"]},{\"tk\":[617,21,617,22],\"els\":[\"0:23\"]},{\"tk\":[617,22,617,25],\"els\":[\"0:23\"]},{\"tk\":[617,26,617,27],\"els\":[\"0:23\"]},{\"tk\":[617,28,617,29],\"els\":[\"0:23\"]},{\"tk\":[617,29,617,38],\"els\":[\"0:23\"]},{\"tk\":[617,38,617,39],\"els\":[\"0:23\"]},{\"tk\":[617,39,617,45],\"els\":[\"0:23\"]},{\"tk\":[617,45,617,46],\"els\":[\"0:23\"]},{\"tk\":[617,46,617,49],\"els\":[\"0:23\"]},{\"tk\":[617,50,617,51],\"els\":[\"0:23\"]},{\"tk\":[617,52,617,53],\"els\":[\"0:23\"]},{\"tk\":[617,53,617,58],\"els\":[\"0:23\"]},{\"tk\":[617,58,617,59],\"els\":[\"0:23\"]},{\"tk\":[617,60,617,61],\"els\":[\"0:23\"]},{\"tk\":[617,62,617,66],\"els\":[\"0:23\"]},{\"tk\":[617,66,617,67],\"els\":[\"0:23\"]},{\"tk\":[621,5,621,14],\"els\":[\"0:23\"]},{\"tk\":[621,14,621,15],\"els\":[\"0:23\"]},{\"tk\":[621,15,621,24],\"els\":[\"0:23\"]},{\"tk\":[621,24,621,25],\"els\":[\"0:23\"]},{\"tk\":[621,25,621,28],\"els\":[\"0:23\"]},{\"tk\":[621,28,621,29],\"els\":[\"0:23\"]},{\"tk\":[621,29,621,38],\"els\":[\"0:23\"]},{\"tk\":[621,39,621,40],\"els\":[\"0:23\"]},{\"tk\":[621,41,621,43],\"els\":[\"0:23\"]},{\"tk\":[621,43,621,44],\"els\":[\"0:23\"]},{\"tk\":[622,5,622,14],\"els\":[\"0:23\"]},{\"tk\":[622,14,622,15],\"els\":[\"0:23\"]},{\"tk\":[622,15,622,24],\"els\":[\"0:23\"]},{\"tk\":[622,24,622,25],\"els\":[\"0:23\"]},{\"tk\":[622,25,622,28],\"els\":[\"0:23\"]},{\"tk\":[622,28,622,29],\"els\":[\"0:23\"]},{\"tk\":[622,29,622,37],\"els\":[\"0:23\"]},{\"tk\":[622,38,622,39],\"els\":[\"0:23\"]},{\"tk\":[622,40,622,42],\"els\":[\"0:23\"]},{\"tk\":[622,42,622,43],\"els\":[\"0:23\"]},{\"tk\":[623,5,623,14],\"els\":[\"0:23\"]},{\"tk\":[623,14,623,15],\"els\":[\"0:23\"]},{\"tk\":[623,15,623,24],\"els\":[\"0:23\"]},{\"tk\":[623,24,623,25],\"els\":[\"0:23\"]},{\"tk\":[623,25,623,28],\"els\":[\"0:23\"]},{\"tk\":[623,28,623,29],\"els\":[\"0:23\"]},{\"tk\":[623,29,623,37],\"els\":[\"0:23\"]},{\"tk\":[623,38,623,39],\"els\":[\"0:23\"]},{\"tk\":[623,40,623,42],\"els\":[\"0:23\"]},{\"tk\":[623,42,623,43],\"els\":[\"0:23\"]},{\"tk\":[624,5,624,14],\"els\":[\"0:23\"]},{\"tk\":[624,14,624,15],\"els\":[\"0:23\"]},{\"tk\":[624,15,624,24],\"els\":[\"0:23\"]},{\"tk\":[624,24,624,25],\"els\":[\"0:23\"]},{\"tk\":[624,25,624,28],\"els\":[\"0:23\"]},{\"tk\":[624,28,624,29],\"els\":[\"0:23\"]},{\"tk\":[624,29,624,37],\"els\":[\"0:23\"]},{\"tk\":[624,38,624,39],\"els\":[\"0:23\"]},{\"tk\":[624,40,624,42],\"els\":[\"0:23\"]},{\"tk\":[624,42,624,43],\"els\":[\"0:23\"]},{\"tk\":[625,5,625,14],\"els\":[\"0:23\"]},{\"tk\":[625,14,625,15],\"els\":[\"0:23\"]},{\"tk\":[625,15,625,24],\"els\":[\"0:23\"]},{\"tk\":[625,24,625,25],\"els\":[\"0:23\"]},{\"tk\":[625,25,625,28],\"els\":[\"0:23\"]},{\"tk\":[625,28,625,29],\"els\":[\"0:23\"]},{\"tk\":[625,29,625,37],\"els\":[\"0:23\"]},{\"tk\":[625,38,625,39],\"els\":[\"0:23\"]},{\"tk\":[625,40,625,42],\"els\":[\"0:23\"]},{\"tk\":[625,42,625,43],\"els\":[\"0:23\"]},{\"tk\":[631,5,631,14],\"els\":[\"0:23\"]},{\"tk\":[631,14,631,15],\"els\":[\"0:23\"]},{\"tk\":[631,15,631,21],\"els\":[\"0:23\"]},{\"tk\":[631,21,631,22],\"els\":[\"0:23\"]},{\"tk\":[631,22,631,25],\"els\":[\"0:23\"]},{\"tk\":[631,26,631,27],\"els\":[\"0:23\"]},{\"tk\":[631,28,631,29],\"els\":[\"0:23\"]},{\"tk\":[631,29,631,38],\"els\":[\"0:23\"]},{\"tk\":[631,38,631,39],\"els\":[\"0:23\"]},{\"tk\":[631,39,631,45],\"els\":[\"0:23\"]},{\"tk\":[631,45,631,46],\"els\":[\"0:23\"]},{\"tk\":[631,46,631,49],\"els\":[\"0:23\"]},{\"tk\":[631,50,631,51],\"els\":[\"0:23\"]},{\"tk\":[631,52,631,53],\"els\":[\"0:23\"]},{\"tk\":[631,53,631,58],\"els\":[\"0:23\"]},{\"tk\":[631,58,631,59],\"els\":[\"0:23\"]},{\"tk\":[631,60,631,61],\"els\":[\"0:23\"]},{\"tk\":[631,62,631,66],\"els\":[\"0:23\"]},{\"tk\":[631,66,631,67],\"els\":[\"0:23\"]},{\"tk\":[632,5,632,9],\"els\":[\"0:23\"]},{\"tk\":[632,9,632,10],\"els\":[\"0:23\"]},{\"tk\":[633,3,633,4],\"els\":[\"0:23\"]},{\"tk\":[636,3,636,9],\"els\":[\"0:2\"]},{\"tk\":[636,10,636,26],\"els\":[\"0:2\"]},{\"tk\":[636,27,636,28],\"els\":[\"0:2\"]},{\"tk\":[636,29,636,31],\"els\":[\"0:2\"]}]},\"1\":{\"records\":[{\"tk\":[60,3,60,9],\"els\":[\"0:12\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[60,10,60,14],\"els\":[\"0:12\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[60,14,60,15],\"els\":[\"0:12\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[61,3,61,9],\"els\":[\"0:2\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[61,10,61,24],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[61,24,61,25],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[66,3,66,10],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[66,11,66,27],\"els\":[\"0:2\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[66,27,66,28],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[67,3,67,10],\"els\":[\"0:1\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[67,11,67,33],\"els\":[\"0:1\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[67,33,67,34],\"els\":[\"0:1\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[72,3,72,9],\"els\":[\"0:13\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[72,10,72,20],\"els\":[\"0:13\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[72,20,72,21],\"els\":[\"0:13\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[75,3,75,9],\"els\":[\"0:16\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[75,10,75,25],\"els\":[\"0:16\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[75,25,75,26],\"els\":[\"0:16\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[78,3,78,9],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[78,10,78,28],\"els\":[\"0:2\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[78,28,78,29],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[81,3,81,9],\"els\":[\"0:2\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[81,10,81,31],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[81,31,81,32],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[84,3,84,9],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[84,10,84,29],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[84,29,84,30],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[87,3,87,9],\"els\":[\"0:2\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[87,10,87,35],\"els\":[\"0:2\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[87,35,87,36],\"els\":[\"0:2\"],\"ct\":{\"0\":2,\"1\":1}}]}}}","blocks":[{"RTWName":"<Root>/ADC1","SIDString":"pwm:12"},{"RTWName":"<Root>/Add","SIDString":"pwm:14"},{"RTWName":"<Root>/Constant5","SIDString":"pwm:16"},{"RTWName":"<Root>/Digital Output","SIDString":"pwm:1"},{"RTWName":"<Root>/Gain1","SIDString":"pwm:13"},{"RTWName":"<Root>/Pulse\nGenerator","SIDString":"pwm:2"},{"RTWName":"<Root>/ePWM","SIDString":"pwm:3"},{"RTWName":"<Root>/ePWM1","SIDString":"pwm:23"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};